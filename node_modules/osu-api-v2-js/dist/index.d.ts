import { Beatmap } from "./namespaces/Beatmap.js";
import { Beatmapset } from "./namespaces/Beatmapset.js";
import { Changelog } from "./namespaces/Changelog.js";
import { Chat } from "./namespaces/Chat.js";
import { Comment } from "./namespaces/Comment.js";
import { Event } from "./namespaces/Event.js";
import { Forum } from "./namespaces/Forum.js";
import { Home } from "./namespaces/Home.js";
import { Match } from "./namespaces/Match.js";
import { Miscellaneous } from "./namespaces/Miscellaneous.js";
import { Multiplayer } from "./namespaces/Multiplayer.js";
import { NewsPost } from "./namespaces/NewsPost.js";
import { Score } from "./namespaces/Score.js";
import { Spotlight } from "./namespaces/Spotlight.js";
import { User } from "./namespaces/User.js";
import { WikiPage } from "./namespaces/Wiki.js";
export { Beatmap, Beatmapset, Changelog, Chat, Comment, Event, Forum, Home, Match, Miscellaneous, Multiplayer, NewsPost, Score, Spotlight, User, WikiPage };
/** The name "Ruleset" is synonymous with "Game mode" or "Gamemode" */
export declare enum Ruleset {
    osu = 0,
    taiko = 1,
    /** Better known as "osu!catch" or "Catch the Beat", "fruits" is the name used throughout the API */
    fruits = 2,
    mania = 3
}
export type Mod = {
    acronym: string;
    settings?: {
        [k: string]: any;
    };
};
/**
 * Scopes determine what the API instance can do as a user!
 * https://osu.ppy.sh/docs/index.html#scopes
 * @remarks "identify" is always implicity provided, **"public" is implicitly needed for almost everything!!**
 * The need for the "public" scope is only made explicit when the function can't be used unless the application acts as as a user (non-guest)
 */
export type Scope = "chat.read" | "chat.write" | "chat.write_manage" | "delegate" | "forum.write" | "friends.read" | "identify" | "public";
/**
 * Generates a link for users to click on in order to use your application!
 * @param client_id The Client ID, find it at https://osu.ppy.sh/home/account/edit#new-oauth-application
 * @param redirect_uri The specified Application Callback URL, aka where the user will be redirected upon clicking the button to authorize
 * @param scopes What you want to do with/as the user
 * @param server The API server (defaults to **https://osu.ppy.sh**, leave as is if you don't know exactly what you're doing)
 * @returns The link people should click on
 */
export declare function generateAuthorizationURL(client_id: number, redirect_uri: string, scopes: Scope[], server?: string): string;
/** If the {@link API} throws an error, it should always be an {@link APIError}! */
export declare class APIError {
    message: string;
    server: API["server"];
    method: Parameters<API["request"]>[0];
    endpoint: Parameters<API["request"]>[1];
    parameters: Parameters<API["request"]>[2];
    status_code?: number | undefined;
    original_error?: Error | undefined;
    /**
     * @param message The reason why things didn't go as expected
     * @param server The server to which the request was sent
     * @param method The method used for this request (like "get", "post", etc...)
     * @param endpoint The type of resource that was requested from the server
     * @param parameters The filters that were used to specify what resource was wanted
     * @param status_code The status code that was returned by the server, if there is one
     * @param original_error The error that caused the api to throw an {@link APIError} in the first place, if there is one
     */
    constructor(message: string, server: API["server"], method: Parameters<API["request"]>[0], endpoint: Parameters<API["request"]>[1], parameters: Parameters<API["request"]>[2], status_code?: number | undefined, original_error?: Error | undefined);
}
/** You can create an API instance without directly providing an access_token by using {@link API.createAsync}! */
export declare class API {
    /**
     * **Please use {@link API.createAsync} instead of the default constructor** if you don't have at least an {@link API.access_token}!
     * An API object without an `access_token` is pretty much useless!
     */
    constructor(properties: Partial<API>);
    /**
     * The normal way to create an API instance! Make sure to `await` it
     * @param client_id The ID of your client, which you can get on https://osu.ppy.sh/home/account/edit#oauth
     * @param client_secret The Secret of your client, which you can get or reset on https://osu.ppy.sh/home/account/edit#oauth
     * @param user If the instance is supposed to represent a user, use their Authorization Code and the Application Callback URL of your application!
     * @param settings Additional settings you'd like to specify now rather than later, check out the Accessors at https://osu-v2.taevas.xyz/classes/API.html
     * @returns A promise with an API instance
     */
    static createAsync(client_id: API["client_id"], client_secret: API["client_secret"], user?: {
        /** The Application Callback URL; Where the User has been redirected to after saying "okay" to your application doing stuff */
        redirect_uri: string;
        /** The code that appeared as a GET argument when they got redirected to the Application Callback URL (`redirect_uri`) */
        code: string;
    }, settings?: Partial<API>): Promise<API>;
    private _client_id;
    /** The ID of your client, which you can get on https://osu.ppy.sh/home/account/edit#oauth */
    get client_id(): number;
    set client_id(client_id: number);
    private _client_secret;
    /** The Secret of your client, which you can get or reset on https://osu.ppy.sh/home/account/edit#oauth */
    get client_secret(): string;
    set client_secret(client_secret: string);
    private _server;
    /** The base url of the server where the requests should land (defaults to **https://osu.ppy.sh**) */
    get server(): string;
    set server(server: string);
    private _route_api;
    /** Used by practically every method to interact with the {@link API.server} (defaults to **api/v2**) */
    get route_api(): (string | number)[];
    set route_api(route_api: (string | number)[]);
    private _route_token;
    /** Used for getting an {@link API.access_token} and using your {@link API.refresh_token} (defaults to **oauth/token**) */
    get route_token(): (string | number)[];
    set route_token(route_token: (string | number)[]);
    private _scopes;
    /** The {@link Scope}s your application has, assuming it acts as a user */
    get scopes(): Scope[];
    set scopes(scopes: Scope[]);
    private _headers;
    /** Used in practically all requests, those are all the headers the package uses excluding `Authorization`, the one with the token */
    get headers(): {
        [key: string]: any;
    };
    set headers(headers: {
        [key: string]: any;
    });
    private _user?;
    /** The osu! user id of the user who went through the Authorization Code Grant */
    get user(): number | undefined;
    set user(user: number | undefined);
    private _verbose?;
    /** Which events should be logged (defaults to **none**) */
    get verbose(): "none" | "all" | "errors" | undefined;
    set verbose(verbose: "none" | "all" | "errors" | undefined);
    private _timeout;
    /**
     * The maximum **amount of seconds** requests should take before returning an answer (defaults to **20**)
     * @remarks 0 means no maximum, no timeout
     */
    get timeout(): number;
    set timeout(timeout: number);
    private _retry_delay;
    /** In seconds, how long should it wait after a request failed before retrying? (defaults to **2**) */
    get retry_delay(): number;
    set retry_delay(retry_delay: number);
    private _retry_maximum_amount;
    /**
     * How many retries maximum before throwing an {@link APIError} (defaults to **4**)
     * @remarks Pro tip: Set that to 0 to **completely** disable retries!
     */
    get retry_maximum_amount(): number;
    set retry_maximum_amount(retry_maximum_amount: number);
    private _retry_on_automatic_token_refresh;
    /** Should it retry a request upon successfully refreshing the token due to {@link API.refresh_token_on_401} being `true`? (defaults to **true**) */
    get retry_on_automatic_token_refresh(): boolean;
    set retry_on_automatic_token_refresh(retry_on_automatic_token_refresh: boolean);
    private _retry_on_status_codes;
    /** Upon failing a request and receiving a response, because of which received status code should the request be retried? (defaults to **[429]**) */
    get retry_on_status_codes(): number[];
    set retry_on_status_codes(retry_on_status_codes: number[]);
    private _retry_on_timeout;
    /** Should it retry a request if that request failed because it has been aborted by the {@link API.timeout}? (defaults to **false**) */
    get retry_on_timeout(): boolean;
    set retry_on_timeout(retry_on_timeout: boolean);
    private _access_token;
    /** The key that allows you to talk with the API */
    get access_token(): string;
    set access_token(token: string);
    private _token_type;
    /** Should always be "Bearer" */
    get token_type(): string;
    set token_type(token: string);
    private _expires;
    /** The expiration date of your access_token */
    get expires(): Date;
    set expires(date: Date);
    /**
     * Set most of an `api`'s properties, like tokens, token_type, scopes, expiration_date
     * @param body An Object with the client id & secret, grant_type, and stuff that depends of the grant_type
     * @param api The `api` which will see its properties change
     * @returns `api`, just in case, because in theory it should modify the original object
     */
    private getAndSetToken;
    /**
     * Revoke your current token! This revokes the refresh token as well
     * @remarks Uses {@link API.route_api} instead of {@link API.route_token}, as normally expected by the server
     */
    revokeToken(): Promise<void>;
    private _refresh_token?;
    /**
     * Valid for an unknown amount of time, it allows you to get a new token without going through the Authorization Code Grant again!
     * Use {@link API.refreshToken} to do that
     */
    get refresh_token(): string | undefined;
    set refresh_token(token: string | undefined);
    private _refresh_token_on_401;
    /** If true, upon failing a request due to a 401, it will use the {@link API.refresh_token} if it exists (defaults to **true**) */
    get refresh_token_on_401(): boolean;
    set refresh_token_on_401(refresh: boolean);
    private _refresh_token_on_expires;
    /**
     * If true, the application will silently use the {@link API.refresh_token} right before the {@link API.access_token} expires,
     * as determined by {@link API.expires} (defaults to **true**)
     */
    get refresh_token_on_expires(): boolean;
    set refresh_token_on_expires(enabled: boolean);
    private _refresh_token_timer?;
    get refresh_token_timer(): API["_refresh_token_timer"];
    set refresh_token_timer(timer: NodeJS.Timeout);
    /** Add, remove, change the timeout used for refreshing the token automatically whenever certain properties change */
    private updateRefreshTokenTimer;
    /** @returns Whether or not the token has been refreshed */
    refreshToken(): Promise<boolean>;
    /**
     * Use this instead of `console.log` to log any information
     * @param is_error Is the logging happening because of an error?
     * @param to_log Whatever you would put between the parentheses of `console.log()`
     */
    private log;
    /**
     * You can use this to specify additional settings for the method you're going to call, such as `headers`, an `AbortSignal`, and more advanced things!
     * @example
     * ```ts
     * const controller = new AbortController() // this controller can be used to abort any request that uses its signal!
     * const user = await api.withSettings({signal: controller.signal}).getUser(7276846)
     * ```
     * @param additional_fetch_settings You may get more info at https://developer.mozilla.org/en-US/docs/Web/API/RequestInit#instance_properties
     * @returns A special version of the `API` that changes how requests are done
     */
    withSettings(additional_fetch_settings: ChildAPI["additional_fetch_settings"]): ChildAPI;
    /**
     * The function that directly communicates with the API! Almost every functions of the API object uses this function!
     * @param method The type of request, each endpoint uses a specific one (if it uses multiple, the intent and parameters become different)
     * @param endpoint What comes in the URL after `api/`, **DO NOT USE TEMPLATE LITERALS (`) OR THE ADDITION OPERATOR (+), put everything separately for type safety**
     * @param parameters The things to specify in the request, such as the beatmap_id when looking for a beatmap
     * @param settings Additional settings **to add** to the current settings of the `fetch()` request
     * @param info Context given by a prior request
     * @returns A Promise with the API's response
     */
    request(method: "get" | "post" | "put" | "delete", endpoint: Array<string | number>, parameters?: {
        [k: string]: any;
    }, settings?: ChildAPI["additional_fetch_settings"], info?: {
        number_try: number;
        just_refreshed: boolean;
    }): Promise<any>;
    /** {@inheritDoc Beatmap.lookup} @group Beatmap Methods */
    readonly lookupBeatmap: typeof Beatmap.lookup;
    /** {@inheritDoc Beatmap.getOne} @group Beatmap Methods */
    readonly getBeatmap: typeof Beatmap.getOne;
    /** {@inheritDoc Beatmap.getMultiple} @group Beatmap Methods */
    readonly getBeatmaps: typeof Beatmap.getMultiple;
    /** {@inheritDoc Beatmap.DifficultyAttributes.get} @group Beatmap Methods */
    readonly getBeatmapDifficultyAttributes: typeof Beatmap.DifficultyAttributes.get;
    /** {@inheritDoc Beatmap.DifficultyAttributes.getOsu} @group Beatmap Methods */
    readonly getBeatmapDifficultyAttributesOsu: typeof Beatmap.DifficultyAttributes.getOsu;
    /** {@inheritDoc Beatmap.DifficultyAttributes.getTaiko} @group Beatmap Methods */
    readonly getBeatmapDifficultyAttributesTaiko: typeof Beatmap.DifficultyAttributes.getTaiko;
    /** {@inheritDoc Beatmap.DifficultyAttributes.getFruits} @group Beatmap Methods */
    readonly getBeatmapDifficultyAttributesFruits: typeof Beatmap.DifficultyAttributes.getFruits;
    /** {@inheritDoc Beatmap.DifficultyAttributes.getMania} @group Beatmap Methods */
    readonly getBeatmapDifficultyAttributesMania: typeof Beatmap.DifficultyAttributes.getMania;
    /** {@inheritDoc Beatmap.getScores} @group Beatmap Methods */
    readonly getBeatmapScores: typeof Beatmap.getScores;
    /** {@inheritDoc Beatmap.getUserScore} @group Beatmap Methods */
    readonly getBeatmapUserScore: typeof Beatmap.getUserScore;
    /** {@inheritDoc Beatmap.getUserScores} @group Beatmap Methods */
    readonly getBeatmapUserScores: typeof Beatmap.getUserScores;
    /** {@inheritDoc Beatmap.UserTag.getAll} @group Beatmap Methods */
    readonly getBeatmapUserTags: typeof Beatmap.UserTag.getAll;
    /** {@inheritDoc Beatmap.Pack.getOne} @group Beatmap Methods */
    readonly getBeatmapPack: typeof Beatmap.Pack.getOne;
    /** {@inheritDoc Beatmap.Pack.getMultiple} @group Beatmap Methods */
    readonly getBeatmapPacks: typeof Beatmap.Pack.getMultiple;
    /** {@inheritDoc Beatmapset.search} @group Beatmapset Methods */
    readonly searchBeatmapsets: typeof Beatmapset.search;
    /** {@inheritDoc Beatmapset.lookup} @group Beatmapset Methods */
    readonly lookupBeatmapset: typeof Beatmapset.lookup;
    /** {@inheritDoc Beatmapset.getOne} @group Beatmapset Methods */
    readonly getBeatmapset: typeof Beatmapset.getOne;
    /** {@inheritDoc Beatmapset.Discussion.getMultiple} @group Beatmapset Methods */
    readonly getBeatmapsetDiscussions: typeof Beatmapset.Discussion.getMultiple;
    /** {@inheritDoc Beatmapset.Discussion.Post.getMultiple} @group Beatmapset Methods */
    readonly getBeatmapsetDiscussionPosts: typeof Beatmapset.Discussion.Post.getMultiple;
    /** {@inheritDoc Beatmapset.Discussion.Vote.getMultiple} @group Beatmapset Methods */
    readonly getBeatmapsetDiscussionVotes: typeof Beatmapset.Discussion.Vote.getMultiple;
    /** {@inheritDoc Beatmapset.Event.getMultiple} @group Beatmapset Methods */
    readonly getBeatmapsetEvents: typeof Beatmapset.Event.getMultiple;
    /** {@inheritDoc Changelog.Build.lookup} @group Changelog Methods */
    readonly lookupChangelogBuild: typeof Changelog.Build.lookup;
    /** {@inheritDoc Changelog.Build.getOne} @group Changelog Methods */
    readonly getChangelogBuild: typeof Changelog.Build.getOne;
    /** {@inheritDoc Changelog.Build.getMultiple} @group Changelog Methods */
    readonly getChangelogBuilds: typeof Changelog.Build.getMultiple;
    /** {@inheritDoc Changelog.UpdateStream.getAll} @group Changelog Methods */
    readonly getChangelogStreams: typeof Changelog.UpdateStream.getAll;
    /** {@inheritDoc Chat.keepAlive} @group Chat Methods */
    readonly keepChatAlive: typeof Chat.keepAlive;
    /** {@inheritDoc Chat.Message.getMultiple} @group Chat Methods */
    readonly getChatMessages: typeof Chat.Message.getMultiple;
    /** {@inheritDoc Chat.Message.send} @group Chat Methods */
    readonly sendChatMessage: typeof Chat.Message.send;
    /** {@inheritDoc Chat.Message.sendPrivate} @group Chat Methods */
    readonly sendChatPrivateMessage: typeof Chat.Message.sendPrivate;
    /** {@inheritDoc Chat.Channel.getOne} @group Chat Methods */
    readonly getChatChannel: typeof Chat.Channel.getOne;
    /** {@inheritDoc Chat.Channel.getAll} @group Chat Methods */
    readonly getChatChannels: typeof Chat.Channel.getAll;
    /** {@inheritDoc Chat.Channel.markAsRead} @group Chat Methods */
    readonly markChatChannelAsRead: typeof Chat.Channel.markAsRead;
    /** {@inheritDoc Chat.Channel.createPrivate} @group Chat Methods */
    readonly createChatPrivateChannel: typeof Chat.Channel.createPrivate;
    /** {@inheritDoc Chat.Channel.createAnnouncement} @group Chat Methods */
    readonly createChatAnnouncementChannel: typeof Chat.Channel.createAnnouncement;
    /** {@inheritDoc Chat.Channel.joinOne} @group Chat Methods */
    readonly joinChatChannel: typeof Chat.Channel.joinOne;
    /** {@inheritDoc Chat.Channel.leaveOne} @group Chat Methods */
    readonly leaveChatChannel: typeof Chat.Channel.leaveOne;
    /** {@inheritDoc Chat.Websocket.getHeaders} @group Chat Methods */
    readonly getChatWebsocketHeaders: typeof Chat.Websocket.getHeaders;
    /** {@inheritDoc Chat.Websocket.generate} @group Chat Methods */
    readonly generateChatWebsocket: typeof Chat.Websocket.generate;
    /** {@inheritDoc Comment.getOne} @group Comment Methods */
    readonly getComment: typeof Comment.getOne;
    /** {@inheritDoc Comment.getMultiple} @group Comment Methods */
    readonly getComments: typeof Comment.getMultiple;
    /** {@inheritDoc Event.getMultiple} @group Event Methods */
    readonly getEvents: typeof Event.getMultiple;
    /** {@inheritDoc Forum.getOne} @group Forum Methods */
    readonly getForum: typeof Forum.getOne;
    /** {@inheritDoc Forum.getMultiple} @group Forum Methods */
    readonly getForums: typeof Forum.getMultiple;
    /** {@inheritDoc Forum.Topic.getOne} @group Forum Methods */
    readonly getForumTopic: typeof Forum.Topic.getOne;
    /** {@inheritDoc Forum.Topic.getMultiple} @group Forum Methods */
    readonly getForumTopics: typeof Forum.Topic.getMultiple;
    /** {@inheritDoc Forum.Topic.create} @group Forum Methods */
    readonly createForumTopic: typeof Forum.Topic.create;
    /** {@inheritDoc Forum.Topic.reply} @group Forum Methods */
    readonly replyForumTopic: typeof Forum.Topic.reply;
    /** {@inheritDoc Forum.Topic.editTitle} @group Forum Methods */
    readonly editForumTopicTitle: typeof Forum.Topic.editTitle;
    /** {@inheritDoc Forum.Post.edit} @group Forum Methods */
    readonly editForumPost: typeof Forum.Post.edit;
    /** {@inheritDoc Home.Search.getUsers} @group Home Methods */
    readonly searchUser: typeof Home.Search.getUsers;
    /** {@inheritDoc Home.Search.getWikiPages} @group Home Methods */
    readonly searchWiki: typeof Home.Search.getWikiPages;
    /** {@inheritDoc Match.getOne} @group Match Methods */
    readonly getMatch: typeof Match.getOne;
    /** {@inheritDoc Match.getMultiple} @group Match Methods */
    readonly getMatches: typeof Match.getMultiple;
    /** {@inheritDoc Miscellaneous.Country.getRanking} @group Miscellaneous Methods */
    readonly getCountryRanking: typeof Miscellaneous.Country.getRanking;
    /** {@inheritDoc Miscellaneous.getSeasonalBackgrounds} @group Miscellaneous Methods */
    readonly getSeasonalBackgrounds: typeof Miscellaneous.getSeasonalBackgrounds;
    /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Methods */
    readonly getRoom: typeof Multiplayer.Room.getOne;
    /** {@inheritDoc Multiplayer.Room.getMultiple} @group Multiplayer Methods */
    readonly getRooms: typeof Multiplayer.Room.getMultiple;
    /** {@inheritDoc Multiplayer.Room.Leader.getMultiple} @group Multiplayer Methods */
    readonly getRoomLeaderboard: typeof Multiplayer.Room.Leader.getMultiple;
    /** {@inheritDoc Multiplayer.Room.PlaylistItem.getScores} @group Multiplayer Methods */
    readonly getPlaylistItemScores: typeof Multiplayer.Room.PlaylistItem.getScores;
    /** {@inheritDoc Multiplayer.Room.Event.getAll} @group Multiplayer Methods */
    readonly getRoomEvents: typeof Multiplayer.Room.Event.getAll;
    /** {@inheritDoc NewsPost.getOne} @group NewsPost Methods */
    readonly getNewsPost: typeof NewsPost.getOne;
    /** {@inheritDoc NewsPost.getMultiple} @group NewsPost Methods */
    readonly getNewsPosts: typeof NewsPost.getMultiple;
    /** {@inheritDoc Score.getSome} @group Score Methods */
    readonly getScores: typeof Score.getSome;
    /** {@inheritDoc Score.getReplay} @group Score Methods */
    readonly getReplay: typeof Score.getReplay;
    /** {@inheritDoc Spotlight.getAll} @group Spotlight Methods */
    readonly getSpotlights: typeof Spotlight.getAll;
    /** {@inheritDoc Spotlight.getRanking} @group Spotlight Methods */
    readonly getSpotlightRanking: typeof Spotlight.getRanking;
    /** {@inheritDoc User.getResourceOwner} @group User Methods */
    readonly getResourceOwner: typeof User.getResourceOwner;
    /** {@inheritDoc User.getOne} @group User Methods */
    readonly getUser: typeof User.getOne;
    /** {@inheritDoc User.getMultiple} @group User Methods */
    readonly getUsers: typeof User.getMultiple;
    /** {@inheritDoc User.lookupMultiple} @group User Methods */
    readonly lookupUsers: typeof User.lookupMultiple;
    /** {@inheritDoc User.getScores} @group User Methods */
    readonly getUserScores: typeof User.getScores;
    /** {@inheritDoc User.getBeatmaps} @group User Methods */
    readonly getUserBeatmaps: typeof User.getBeatmaps;
    /** {@inheritDoc User.getMostPlayed} @group User Methods */
    readonly getUserMostPlayed: typeof User.getMostPlayed;
    /** {@inheritDoc User.getRecentActivity} @group User Methods */
    readonly getUserRecentActivity: typeof User.getRecentActivity;
    /** {@inheritDoc User.getRanking} @group User Methods */
    readonly getUserRanking: typeof User.getRanking;
    /** {@inheritDoc User.getFriends} @group User Methods */
    readonly getFriends: typeof User.getFriends;
    /** {@inheritDoc User.Kudosu.getHistory} @group User Methods */
    readonly getUserKudosuHistory: typeof User.Kudosu.getHistory;
    /** {@inheritDoc User.Kudosu.getRanking} @group User Methods */
    readonly getKudosuRanking: typeof User.Kudosu.getRanking;
    /** {@inheritDoc WikiPage.getOne} @group WikiPage Methods */
    readonly getWikiPage: typeof WikiPage.getOne;
}
/**
 * Created with {@link API.withSettings}, this special version of the {@link API} specifies additional fetch settings to every request!
 * @remarks This **is not** to be used for any purpose other than calling methods; The original {@link ChildAPI.original} handles tokens & configuration
 */
export declare class ChildAPI extends API {
    /** The {@link API} where {@link API.withSettings} was used; this `ChildAPI` gets everything from it! */
    original: API;
    /** The additional settings that are used for every request made by this object */
    additional_fetch_settings: Omit<RequestInit, "body">;
    request: (...args: Parameters<API["request"]>) => Promise<any>;
    /** @hidden @deprecated use API equivalent */
    get access_token(): string;
    /** @hidden @deprecated use API equivalent */
    get client_id(): number;
    /** @hidden @deprecated use API equivalent */
    get client_secret(): string;
    /** @hidden @deprecated use API equivalent */
    get expires(): Date;
    /** @hidden @deprecated use API equivalent */
    get refresh_token_on_401(): boolean;
    /** @hidden @deprecated use API equivalent */
    get refresh_token_on_expires(): boolean;
    /** @hidden @deprecated use API equivalent */
    get refresh_token_timer(): NodeJS.Timeout | undefined;
    /** @hidden @deprecated use API equivalent */
    get refresh_token(): string | undefined;
    /** @hidden @deprecated use API equivalent */
    get retry_delay(): number;
    /** @hidden @deprecated use API equivalent */
    get retry_maximum_amount(): number;
    /** @hidden @deprecated use API equivalent */
    get retry_on_automatic_token_refresh(): boolean;
    /** @hidden @deprecated use API equivalent */
    get retry_on_status_codes(): number[];
    /** @hidden @deprecated use API equivalent */
    get retry_on_timeout(): boolean;
    /** @hidden @deprecated use API equivalent */
    get route_api(): (string | number)[];
    /** @hidden @deprecated use API equivalent */
    get route_token(): (string | number)[];
    /** @hidden @deprecated use API equivalent */
    get scopes(): Scope[];
    /** @hidden @deprecated use API equivalent */
    get server(): string;
    /** @hidden @deprecated use API equivalent */
    get timeout(): number;
    /** @hidden @deprecated use API equivalent */
    get token_type(): string;
    /** @hidden @deprecated use API equivalent */
    get user(): number | undefined;
    /** @hidden @deprecated use API equivalent */
    get verbose(): "none" | "all" | "errors" | undefined;
    /** @hidden @deprecated use API equivalent */
    refreshToken: () => Promise<boolean>;
    /** @hidden @deprecated use API equivalent */
    revokeToken: () => Promise<void>;
    /** @hidden @deprecated use API equivalent */
    withSettings: (...args: Parameters<API["withSettings"]>) => ChildAPI;
    constructor(original: ChildAPI["original"], additional_fetch_settings: ChildAPI["additional_fetch_settings"]);
}
