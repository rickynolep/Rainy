export var Beatmapset;
(function (Beatmapset) {
    let RankStatus;
    (function (RankStatus) {
        RankStatus[RankStatus["Graveyard"] = -2] = "Graveyard";
        RankStatus[RankStatus["Wip"] = -1] = "Wip";
        RankStatus[RankStatus["Pending"] = 0] = "Pending";
        RankStatus[RankStatus["Ranked"] = 1] = "Ranked";
        RankStatus[RankStatus["Approved"] = 2] = "Approved";
        RankStatus[RankStatus["Qualified"] = 3] = "Qualified";
        RankStatus[RankStatus["Loved"] = 4] = "Loved";
    })(RankStatus = Beatmapset.RankStatus || (Beatmapset.RankStatus = {}));
    let Genre;
    (function (Genre) {
        Genre[Genre["Any"] = 0] = "Any";
        Genre[Genre["Unspecified"] = 1] = "Unspecified";
        Genre[Genre["Video Game"] = 2] = "Video Game";
        Genre[Genre["Anime"] = 3] = "Anime";
        Genre[Genre["Rock"] = 4] = "Rock";
        Genre[Genre["Pop"] = 5] = "Pop";
        Genre[Genre["Other"] = 6] = "Other";
        Genre[Genre["Novelty"] = 7] = "Novelty";
        Genre[Genre["Hip Hop"] = 9] = "Hip Hop";
        Genre[Genre["Electronic"] = 10] = "Electronic";
        Genre[Genre["Metal"] = 11] = "Metal";
        Genre[Genre["Classical"] = 12] = "Classical";
        Genre[Genre["Folk"] = 13] = "Folk";
        Genre[Genre["Jazz"] = 14] = "Jazz";
    })(Genre = Beatmapset.Genre || (Beatmapset.Genre = {}));
    let Language;
    (function (Language) {
        Language[Language["Any"] = 0] = "Any";
        Language[Language["Unspecified"] = 1] = "Unspecified";
        Language[Language["English"] = 2] = "English";
        Language[Language["Japanese"] = 3] = "Japanese";
        Language[Language["Chinese"] = 4] = "Chinese";
        Language[Language["Instrumental"] = 5] = "Instrumental";
        Language[Language["Korean"] = 6] = "Korean";
        Language[Language["French"] = 7] = "French";
        Language[Language["German"] = 8] = "German";
        Language[Language["Swedish"] = 9] = "Swedish";
        Language[Language["Spanish"] = 10] = "Spanish";
        Language[Language["Italian"] = 11] = "Italian";
        Language[Language["Russian"] = 12] = "Russian";
        Language[Language["Polish"] = 13] = "Polish";
        Language[Language["Other"] = 14] = "Other";
    })(Language = Beatmapset.Language || (Beatmapset.Language = {}));
    let Event;
    (function (Event) {
        /**
         * Get complex data about the events of a beatmapset and the users involved with them!
         * @param from Which beatmapset, or caused by which user? When?
         * @param types What kinds of events?
         * @param config How many results maximum, how to sort them, which page of those, maybe a cursor_string...
         * @returns Relevant events and users
         * @remarks This route is undocumented in the API docs, so this is only the result of my interpretation of the website's code and could be unstable
         */
        async function getMultiple(from, types, config) {
            const beatmapset = typeof from?.beatmapset === "object" ? from.beatmapset.id : from?.beatmapset;
            const user = typeof from?.user === "object" ? from.user.id : from?.user;
            return await this.request("get", ["beatmapsets", "events"], { beatmapset_id: beatmapset, user, min_date: from?.min_date?.toISOString(),
                max_date: from?.max_date?.toISOString(), types, ...config });
        }
        Event.getMultiple = getMultiple;
    })(Event = Beatmapset.Event || (Beatmapset.Event = {}));
    let Discussion;
    (function (Discussion) {
        let Post;
        (function (Post) {
            /**
             * Get complex data about the posts of a beatmapset's discussion or of a user!
             * @param from From where/who are the posts coming from? A specific discussion, a specific user?
             * @param types What kind of posts?
             * @param config How many results maximum, how to sort them, which page of those, maybe a cursor_string...
             * @returns Relevant posts and info about them
             * @remarks (2024-03-11) For months now, the API's documentation says the response is likely to change, so beware
             */
            async function getMultiple(from, types, config) {
                const discussion = typeof from?.discussion === "object" ? from.discussion.id : from?.discussion;
                const user = typeof from?.user === "object" ? from.user.id : from?.user;
                return await this.request("get", ["beatmapsets", "discussions", "posts"], { beatmapset_discussion_id: discussion, types, user, ...config });
            }
            Post.getMultiple = getMultiple;
        })(Post = Discussion.Post || (Discussion.Post = {}));
        let Vote;
        (function (Vote) {
            /**
             * Get complex data about the votes of a beatmapset's discussions or/and received/given by a specific user!
             * @param from The discussion with the votes, the user who voted, the user who's gotten the votes...
             * @param score An upvote (1) or a downvote (-1)
             * @param config How many results maximum, how to sort them, which page of those, maybe a cursor_string...
             * @returns Relevant votes and info about them
             * @remarks (2024-03-11) For months now, the API's documentation says the response is likely to change, so beware
             */
            async function getMultiple(from, score, config) {
                const discussion = typeof from?.discussion === "object" ? from.discussion.id : from?.discussion;
                const user = typeof from?.vote_giver === "object" ? from.vote_giver.id : from?.vote_giver;
                const receiver = typeof from?.vote_receiver === "object" ? from.vote_receiver.id : from?.vote_receiver;
                return await this.request("get", ["beatmapsets", "discussions", "votes"], { beatmapset_discussion_id: discussion, receiver, score, user, ...config });
            }
            Vote.getMultiple = getMultiple;
        })(Vote = Discussion.Vote || (Discussion.Vote = {}));
        /**
         * Get complex data about the discussion page of any beatmapet that you want!
         * @param from From where/who are the discussions coming from? Maybe only qualified sets?
         * @param filter Should those discussions only be unresolved problems, for example?
         * @param config How many results maximum, how to sort them, which page of those, maybe a cursor_string...
         * @returns Relevant discussions and info about them
         * @remarks (2024-03-11) For months now, the API's documentation says the response is likely to change, so beware
         * @privateRemarks I don't allow setting `beatmap_id` because my testing has led me to believe it does nothing (and is therefore misleading)
         */
        async function getMultiple(from, filter, config) {
            const beatmapset_id = typeof from?.beatmapset === "object" ? from.beatmapset.id : from?.beatmapset;
            const user_id = typeof from?.user === "object" ? from.user.id : from?.user;
            return await this.request("get", ["beatmapsets", "discussions"], { beatmapset_id, beatmapset_status: from?.status,
                message_types: filter?.types, only_unresolved: filter?.only_unresolved, user: user_id, ...config });
        }
        Discussion.getMultiple = getMultiple;
    })(Discussion = Beatmapset.Discussion || (Beatmapset.Discussion = {}));
    /**
     * Search for beatmapsets as if you were on the website or on lazer!
     * @param query All the filters and sorting options that you'd normally find on the website or on lazer
     * @returns Relevant Beatmapsets that contain Beatmaps, and a cursor_string to allow you to look for more of the same!
     * @remarks This does not bypass the current osu!supporter requirement for certain filters
     */
    async function search(query) {
        const sort = query?.sort ? (query.sort.by + "_" + query.sort.in) : undefined;
        /** General */
        const c = query?.general ? query.general.map((general_value) => {
            if (general_value === "Recommended difficulty")
                return "recommended";
            if (general_value === "Include converted beatmaps")
                return "converts";
            if (general_value === "Subscribed mappers")
                return "follows";
            if (general_value === "Spotlighted beatmaps")
                return "spotlights";
            if (general_value === "Featured Artists")
                return "featured_artists";
        }).join(".") : undefined;
        /** Categories */
        const s = query?.categories ? query.categories === "My Maps" ? "mine" : query.categories.toLowerCase() : undefined;
        /** Explicit Content */
        const nsfw = query?.hide_explicit_content ? false : undefined;
        /** Extra */
        const e = query?.extra ? query.extra.map((extra_value) => {
            if (extra_value === "must_have_video")
                return "video";
            if (extra_value === "must_have_storyboard")
                return "storyboard";
        }).join(".") : undefined;
        /** Rank Achieved */
        const r = query?.rank_achieved ? query.rank_achieved.map((rank_achieved_value) => {
            if (rank_achieved_value === "Silver SS")
                return "XH";
            if (rank_achieved_value === "SS")
                return "X";
            if (rank_achieved_value === "Silver S")
                return "SH";
            return rank_achieved_value;
        }).join("x") : undefined;
        /** Played */
        const played = query?.played ? query.played.toLowerCase() : undefined;
        return await this.request("get", ["beatmapsets", "search"], { q: query?.keywords, sort, c, m: query?.mode, s, nsfw, g: query?.genre, l: query?.language, e, r, played, cursor_string: query?.cursor_string });
    }
    Beatmapset.search = search;
    /**
     * Get extensive data about a beatmapset by using a beatmap!
     * @param beatmap A beatmap from the beatmapset you're looking for
     */
    async function lookup(beatmap) {
        const beatmap_id = typeof beatmap === "number" ? beatmap : beatmap.id;
        return await this.request("get", ["beatmapsets", "lookup"], { beatmap_id });
    }
    Beatmapset.lookup = lookup;
    /**
     * Get extensive beatmapset data about whichever beatmapset you want!
     * @param beatmapset The beatmapset or the id of the beatmapset you're trying to get
     */
    async function getOne(beatmapset) {
        beatmapset = typeof beatmapset === "number" ? beatmapset : beatmapset.id;
        return await this.request("get", ["beatmapsets", beatmapset]);
    }
    Beatmapset.getOne = getOne;
})(Beatmapset || (Beatmapset = {}));
