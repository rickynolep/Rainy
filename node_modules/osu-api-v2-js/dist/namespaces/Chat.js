export var Chat;
(function (Chat) {
    let Channel;
    (function (Channel) {
        /**
         * Get a ChatChannel that you have joined, and the users in it if it is a private channel!
         * @scope {@link Scope"chat.read"}
         * @param channel The channel in question
         * @remarks Will 404 if the user has not joined the channel (use `joinChatChannel` for that)
         */
        async function getOne(channel) {
            const channel_id = typeof channel === "number" ? channel : channel.channel_id;
            const response = await this.request("get", ["chat", "channels", channel_id]);
            return response.channel; // NOT the only property; `users` is already provided within `channel` so it is useless
        }
        Channel.getOne = getOne;
        /**
         * Get a list of all publicly joinable channels!
         * @scope {@link Scope"chat.read"}
         */
        async function getAll() {
            return await this.request("get", ["chat", "channels"]);
        }
        Channel.getAll = getAll;
        /**
         * Mark a certain channel as read up to a given message!
         * @scope {@link Scope"chat.read"}
         * @param channel The channel in question
         * @param message You're marking this and all the messages before it as read!
         */
        async function markAsRead(channel, message) {
            const channel_id = typeof channel === "number" ? channel : channel.channel_id;
            const message_id = typeof message === "number" ? message : message.message_id;
            return await this.request("put", ["chat", "channels", channel_id, "mark-as-read", message_id], { channel_id, message_id });
        }
        Channel.markAsRead = markAsRead;
        /**
         * Create/Open/Join a private messages chat channel!
         * @scope {@link Scope"chat.read"}
         * @param user_target The other user able to read and send messages in this channel
         * @returns The newly created channel!
         */
        async function createPrivate(user_target) {
            const target_id = typeof user_target === "number" ? user_target : user_target.id;
            return await this.request("post", ["chat", "channels"], { type: "PM", target_id });
        }
        Channel.createPrivate = createPrivate;
        /**
         * Create a new announcement!
         * @scope {@link Scope"chat.write_manage"}
         * @param channel Details of the channel you're creating
         * @param user_targets The people that will receive your message
         * @param message The message to send with the announcement
         * @returns The newly created channel!
         * @remarks From my understanding, this WILL 403 unless the user is kinda special
         */
        async function createAnnouncement(channel, user_targets, message) {
            const target_ids = user_targets.map((user) => typeof user === "number" ? user : user.id);
            return await this.request("post", ["chat", "channels"], { type: "ANNOUNCE", channel, target_ids, message });
        }
        Channel.createAnnouncement = createAnnouncement;
        /**
         * Join a public or multiplayer ChatChannel, allowing you to interact with it!
         * @scope {@link Scope"chat.write_manage"}
         * @param channel The channel you wanna join
         * @param user The user joining the channel (defaults to the **presumed authorized user** (api.user))
         */
        async function joinOne(channel, user) {
            const channel_id = typeof channel === "number" ? channel : channel.channel_id;
            const user_id = typeof user === "number" ? user : typeof user === "object" ? user.id : this.user;
            return await this.request("put", ["chat", "channels", channel_id, "users", user_id]);
        }
        Channel.joinOne = joinOne;
        /**
         * Leave/Close a public ChatChannel!
         * @scope {@link Scope"chat.write_manage"}
         * @param channel The channel you wanna leave/close
         * @param user The user leaving/closing the channel (defaults to the **presumed authorized user** (api.user))
         */
        async function leaveOne(channel, user) {
            const channel_id = typeof channel === "number" ? channel : channel.channel_id;
            const user_id = typeof user === "number" ? user : typeof user === "object" ? user.id : this.user;
            return await this.request("delete", ["chat", "channels", channel_id, "users", user_id]);
        }
        Channel.leaveOne = leaveOne;
    })(Channel = Chat.Channel || (Chat.Channel = {}));
    let Message;
    (function (Message) {
        /**
         * Get the recent messages of a specific ChatChannel!
         * @scope {@link Scope"chat.read"}
         * @param channel The Channel you wanna get the messages from
         * @param limit The maximum amount of messages you want to get, up to 50! (defaults to **20**)
         * @param since Get the messages sent after this message
         * @param until Get the messages sent up to but not including this message
         */
        async function getMultiple(channel, limit = 20, since, until) {
            const channel_id = typeof channel === "number" ? channel : channel.channel_id;
            since = typeof since === "number" ? since : since?.message_id;
            until = typeof until === "number" ? until : until?.message_id;
            return await this.request("get", ["chat", "channels", channel_id, "messages"], { limit, since, until });
        }
        Message.getMultiple = getMultiple;
        /**
         * Send a message in a ChatChannel!
         * @scope {@link Scope"chat.write"}
         * @param channel The channel in which you want to send your message
         * @param message The message you wanna send
         * @param is_action Is it a command? Like `/me dances` (defaults to **false**)
         * @returns The newly sent ChatMessage!
         */
        async function send(channel, message, is_action = false) {
            const channel_id = typeof channel === "number" ? channel : channel.channel_id;
            return await this.request("post", ["chat", "channels", channel_id, "messages"], { message, is_action });
        }
        Message.send = send;
        /**
         * Send a private message to someone!
         * @scope {@link Scope"chat.write"}
         * @param user_target The User you wanna send your message to!
         * @param message The message you wanna send
         * @param is_action Is it a command? Like `/me dances` (defaults to **false**)
         * @param uuid A client-side message identifier
         * @returns The message you sent
         * @remarks You don't need to use `createChatPrivateChannel` before sending a message
         */
        async function sendPrivate(user_target, message, is_action = false, uuid) {
            const target_id = typeof user_target === "number" ? user_target : user_target.id;
            return await this.request("post", ["chat", "new"], { target_id, message, is_action, uuid });
        }
        Message.sendPrivate = sendPrivate;
    })(Message = Chat.Message || (Chat.Message = {}));
    /** Everything here is great to use with the WebSocket you can get with {@link API.generateChatWebsocket}! */
    let Websocket;
    (function (Websocket) {
        /**
        * Use any of those with `socket.send()` to send a command to the WebSocket!
        * @example `socket.send(osu.Chat.Websocket.Command.chatStart)`
        */
        let Command;
        (function (Command) {
            Command.chatStart = JSON.stringify({ event: "chat.start" });
            Command.chatEnd = JSON.stringify({ event: "chat.end" });
        })(Command = Websocket.Command || (Websocket.Command = {}));
        /**
         * Get the headers you might require in order to create a WebSocket connection!
         * @returns An object with the proper `Authorization: Bearer` header, in addition to the headers used in other requests,
         * which are all specified in {@link API.headers}
         * @remarks Feel free to use this and ignore {@link API.generateChatWebsocket} if for example
         * you're gonna use a third party package for handling websockets
         */
        function getHeaders() {
            return { ...this.headers, Authorization: `${this.token_type} ${this.access_token}` };
        }
        Websocket.getHeaders = getHeaders;
        /**
        * Get a WebSocket to get Websocket events from!
        * @param headers The headers that will be used to create the WebSocket (defaults to **running `getChatWebsocketHeaders()`**)
        * @param server The "notification websocket/server" URL (defaults to **wss://notify.ppy.sh**)
        */
        function generate(headers, server = "wss://notify.ppy.sh") {
            return new WebSocket(server, { headers: headers ?? this.getChatWebsocketHeaders() });
        }
        Websocket.generate = generate;
    })(Websocket = Chat.Websocket || (Chat.Websocket = {}));
    /**
     * Needs to be done periodically to reset chat activity timeout
     * @scope {@link Scope"chat.read"}
     * @param since UserSilences that are before that will not be returned!
     * @returns A list of recent silences
     * @remarks Every 30 seconds is a good idea
     */
    async function keepAlive(since) {
        const history_since = typeof since?.user_silence === "object" ? since.user_silence.id : since?.user_silence;
        const message_since = typeof since?.message === "object" ? since.message.message_id : since?.message;
        const response = await this.request("post", ["chat", "ack"], { history_since, since: message_since });
        return response.silences; // It's the only property
    }
    Chat.keepAlive = keepAlive;
})(Chat || (Chat = {}));
