// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);

// node_modules/@discordjs/util/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var lazy = function(cb) {
    let defaultValue;
    return () => defaultValue ??= cb();
  };
  function* range(range2) {
    let rangeEnd;
    let start = 0;
    let step = 1;
    if (typeof range2 === "number") {
      rangeEnd = range2;
    } else {
      start = range2.start;
      rangeEnd = range2.end;
      step = range2.step ?? 1;
    }
    for (let index = start;index < rangeEnd; index += step) {
      yield index;
    }
  }
  var calculateShardId = function(guildId, shardCount) {
    return Number(BigInt(guildId) >> 22n) % shardCount;
  };
  var shouldUseGlobalFetchAndWebSocket = function() {
    if (typeof globalThis.process === "undefined") {
      return "fetch" in globalThis && "WebSocket" in globalThis;
    }
    if ("versions" in globalThis.process) {
      return "deno" in globalThis.process.versions || "bun" in globalThis.process.versions;
    }
    return false;
  };
  var getUserAgentAppendix = function() {
    if (typeof globalThis.EdgeRuntime !== "undefined") {
      return "Vercel-Edge-Functions";
    }
    if (typeof globalThis.R2 !== "undefined" && typeof globalThis.WebSocketPair !== "undefined") {
      return "Cloudflare-Workers";
    }
    if (typeof globalThis.Netlify !== "undefined") {
      return "Netlify-Edge-Functions";
    }
    if (typeof globalThis.process !== "object") {
      if (typeof globalThis.navigator === "object") {
        return globalThis.navigator.userAgent;
      }
      return "UnknownEnvironment";
    }
    if ("versions" in globalThis.process) {
      if ("deno" in globalThis.process.versions) {
        return `Deno/${globalThis.process.versions.deno}`;
      }
      if ("bun" in globalThis.process.versions) {
        return `Bun/${globalThis.process.versions.bun}`;
      }
      if ("node" in globalThis.process.versions) {
        return `Node.js/${globalThis.process.versions.node}`;
      }
    }
    return "UnknownEnvironment";
  };
  var polyfillDispose = function() {
    Symbol.dispose ??= Symbol("Symbol.dispose");
    Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
  };
  var isJSONEncodable = function(maybeEncodable) {
    return maybeEncodable !== null && typeof maybeEncodable === "object" && "toJSON" in maybeEncodable;
  };
  var isEquatable = function(maybeEquatable) {
    return maybeEquatable !== null && typeof maybeEquatable === "object" && "equals" in maybeEquatable;
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    calculateShardId: () => calculateShardId,
    getUserAgentAppendix: () => getUserAgentAppendix,
    isEquatable: () => isEquatable,
    isJSONEncodable: () => isJSONEncodable,
    lazy: () => lazy,
    polyfillDispose: () => polyfillDispose,
    range: () => range,
    shouldUseGlobalFetchAndWebSocket: () => shouldUseGlobalFetchAndWebSocket,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  __name(lazy, "lazy");
  __name(range, "range");
  __name(calculateShardId, "calculateShardId");
  __name(shouldUseGlobalFetchAndWebSocket, "shouldUseGlobalFetchAndWebSocket");
  __name(getUserAgentAppendix, "getUserAgentAppendix");
  __name(polyfillDispose, "polyfillDispose");
  __name(isJSONEncodable, "isJSONEncodable");
  __name(isEquatable, "isEquatable");
  var version = "1.1.1";
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/discord-api-types/gateway/common.js
var require_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/gateway/v10.js
var require_v10 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VoiceChannelEffectSendAnimationType = exports.GatewayDispatchEvents = exports.GatewayIntentBits = exports.GatewayCloseCodes = exports.GatewayOpcodes = exports.GatewayVersion = undefined;
  __exportStar(require_common(), exports);
  exports.GatewayVersion = "10";
  var GatewayOpcodes;
  (function(GatewayOpcodes2) {
    GatewayOpcodes2[GatewayOpcodes2["Dispatch"] = 0] = "Dispatch";
    GatewayOpcodes2[GatewayOpcodes2["Heartbeat"] = 1] = "Heartbeat";
    GatewayOpcodes2[GatewayOpcodes2["Identify"] = 2] = "Identify";
    GatewayOpcodes2[GatewayOpcodes2["PresenceUpdate"] = 3] = "PresenceUpdate";
    GatewayOpcodes2[GatewayOpcodes2["VoiceStateUpdate"] = 4] = "VoiceStateUpdate";
    GatewayOpcodes2[GatewayOpcodes2["Resume"] = 6] = "Resume";
    GatewayOpcodes2[GatewayOpcodes2["Reconnect"] = 7] = "Reconnect";
    GatewayOpcodes2[GatewayOpcodes2["RequestGuildMembers"] = 8] = "RequestGuildMembers";
    GatewayOpcodes2[GatewayOpcodes2["InvalidSession"] = 9] = "InvalidSession";
    GatewayOpcodes2[GatewayOpcodes2["Hello"] = 10] = "Hello";
    GatewayOpcodes2[GatewayOpcodes2["HeartbeatAck"] = 11] = "HeartbeatAck";
    GatewayOpcodes2[GatewayOpcodes2["RequestSoundboardSounds"] = 31] = "RequestSoundboardSounds";
  })(GatewayOpcodes || (exports.GatewayOpcodes = GatewayOpcodes = {}));
  var GatewayCloseCodes;
  (function(GatewayCloseCodes2) {
    GatewayCloseCodes2[GatewayCloseCodes2["UnknownError"] = 4000] = "UnknownError";
    GatewayCloseCodes2[GatewayCloseCodes2["UnknownOpcode"] = 4001] = "UnknownOpcode";
    GatewayCloseCodes2[GatewayCloseCodes2["DecodeError"] = 4002] = "DecodeError";
    GatewayCloseCodes2[GatewayCloseCodes2["NotAuthenticated"] = 4003] = "NotAuthenticated";
    GatewayCloseCodes2[GatewayCloseCodes2["AuthenticationFailed"] = 4004] = "AuthenticationFailed";
    GatewayCloseCodes2[GatewayCloseCodes2["AlreadyAuthenticated"] = 4005] = "AlreadyAuthenticated";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidSeq"] = 4007] = "InvalidSeq";
    GatewayCloseCodes2[GatewayCloseCodes2["RateLimited"] = 4008] = "RateLimited";
    GatewayCloseCodes2[GatewayCloseCodes2["SessionTimedOut"] = 4009] = "SessionTimedOut";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidShard"] = 4010] = "InvalidShard";
    GatewayCloseCodes2[GatewayCloseCodes2["ShardingRequired"] = 4011] = "ShardingRequired";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidAPIVersion"] = 4012] = "InvalidAPIVersion";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidIntents"] = 4013] = "InvalidIntents";
    GatewayCloseCodes2[GatewayCloseCodes2["DisallowedIntents"] = 4014] = "DisallowedIntents";
  })(GatewayCloseCodes || (exports.GatewayCloseCodes = GatewayCloseCodes = {}));
  var GatewayIntentBits;
  (function(GatewayIntentBits2) {
    GatewayIntentBits2[GatewayIntentBits2["Guilds"] = 1] = "Guilds";
    GatewayIntentBits2[GatewayIntentBits2["GuildMembers"] = 2] = "GuildMembers";
    GatewayIntentBits2[GatewayIntentBits2["GuildModeration"] = 4] = "GuildModeration";
    GatewayIntentBits2[GatewayIntentBits2["GuildBans"] = 4] = "GuildBans";
    GatewayIntentBits2[GatewayIntentBits2["GuildExpressions"] = 8] = "GuildExpressions";
    GatewayIntentBits2[GatewayIntentBits2["GuildEmojisAndStickers"] = 8] = "GuildEmojisAndStickers";
    GatewayIntentBits2[GatewayIntentBits2["GuildIntegrations"] = 16] = "GuildIntegrations";
    GatewayIntentBits2[GatewayIntentBits2["GuildWebhooks"] = 32] = "GuildWebhooks";
    GatewayIntentBits2[GatewayIntentBits2["GuildInvites"] = 64] = "GuildInvites";
    GatewayIntentBits2[GatewayIntentBits2["GuildVoiceStates"] = 128] = "GuildVoiceStates";
    GatewayIntentBits2[GatewayIntentBits2["GuildPresences"] = 256] = "GuildPresences";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessages"] = 512] = "GuildMessages";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessageReactions"] = 1024] = "GuildMessageReactions";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessageTyping"] = 2048] = "GuildMessageTyping";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessages"] = 4096] = "DirectMessages";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessageReactions"] = 8192] = "DirectMessageReactions";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessageTyping"] = 16384] = "DirectMessageTyping";
    GatewayIntentBits2[GatewayIntentBits2["MessageContent"] = 32768] = "MessageContent";
    GatewayIntentBits2[GatewayIntentBits2["GuildScheduledEvents"] = 65536] = "GuildScheduledEvents";
    GatewayIntentBits2[GatewayIntentBits2["AutoModerationConfiguration"] = 1048576] = "AutoModerationConfiguration";
    GatewayIntentBits2[GatewayIntentBits2["AutoModerationExecution"] = 2097152] = "AutoModerationExecution";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessagePolls"] = 16777216] = "GuildMessagePolls";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessagePolls"] = 33554432] = "DirectMessagePolls";
  })(GatewayIntentBits || (exports.GatewayIntentBits = GatewayIntentBits = {}));
  var GatewayDispatchEvents;
  (function(GatewayDispatchEvents2) {
    GatewayDispatchEvents2["ApplicationCommandPermissionsUpdate"] = "APPLICATION_COMMAND_PERMISSIONS_UPDATE";
    GatewayDispatchEvents2["AutoModerationActionExecution"] = "AUTO_MODERATION_ACTION_EXECUTION";
    GatewayDispatchEvents2["AutoModerationRuleCreate"] = "AUTO_MODERATION_RULE_CREATE";
    GatewayDispatchEvents2["AutoModerationRuleDelete"] = "AUTO_MODERATION_RULE_DELETE";
    GatewayDispatchEvents2["AutoModerationRuleUpdate"] = "AUTO_MODERATION_RULE_UPDATE";
    GatewayDispatchEvents2["ChannelCreate"] = "CHANNEL_CREATE";
    GatewayDispatchEvents2["ChannelDelete"] = "CHANNEL_DELETE";
    GatewayDispatchEvents2["ChannelPinsUpdate"] = "CHANNEL_PINS_UPDATE";
    GatewayDispatchEvents2["ChannelUpdate"] = "CHANNEL_UPDATE";
    GatewayDispatchEvents2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
    GatewayDispatchEvents2["EntitlementDelete"] = "ENTITLEMENT_DELETE";
    GatewayDispatchEvents2["EntitlementUpdate"] = "ENTITLEMENT_UPDATE";
    GatewayDispatchEvents2["GuildAuditLogEntryCreate"] = "GUILD_AUDIT_LOG_ENTRY_CREATE";
    GatewayDispatchEvents2["GuildBanAdd"] = "GUILD_BAN_ADD";
    GatewayDispatchEvents2["GuildBanRemove"] = "GUILD_BAN_REMOVE";
    GatewayDispatchEvents2["GuildCreate"] = "GUILD_CREATE";
    GatewayDispatchEvents2["GuildDelete"] = "GUILD_DELETE";
    GatewayDispatchEvents2["GuildEmojisUpdate"] = "GUILD_EMOJIS_UPDATE";
    GatewayDispatchEvents2["GuildIntegrationsUpdate"] = "GUILD_INTEGRATIONS_UPDATE";
    GatewayDispatchEvents2["GuildMemberAdd"] = "GUILD_MEMBER_ADD";
    GatewayDispatchEvents2["GuildMemberRemove"] = "GUILD_MEMBER_REMOVE";
    GatewayDispatchEvents2["GuildMembersChunk"] = "GUILD_MEMBERS_CHUNK";
    GatewayDispatchEvents2["GuildMemberUpdate"] = "GUILD_MEMBER_UPDATE";
    GatewayDispatchEvents2["GuildRoleCreate"] = "GUILD_ROLE_CREATE";
    GatewayDispatchEvents2["GuildRoleDelete"] = "GUILD_ROLE_DELETE";
    GatewayDispatchEvents2["GuildRoleUpdate"] = "GUILD_ROLE_UPDATE";
    GatewayDispatchEvents2["GuildScheduledEventCreate"] = "GUILD_SCHEDULED_EVENT_CREATE";
    GatewayDispatchEvents2["GuildScheduledEventDelete"] = "GUILD_SCHEDULED_EVENT_DELETE";
    GatewayDispatchEvents2["GuildScheduledEventUpdate"] = "GUILD_SCHEDULED_EVENT_UPDATE";
    GatewayDispatchEvents2["GuildScheduledEventUserAdd"] = "GUILD_SCHEDULED_EVENT_USER_ADD";
    GatewayDispatchEvents2["GuildScheduledEventUserRemove"] = "GUILD_SCHEDULED_EVENT_USER_REMOVE";
    GatewayDispatchEvents2["GuildSoundboardSoundCreate"] = "GUILD_SOUNDBOARD_SOUND_CREATE";
    GatewayDispatchEvents2["GuildSoundboardSoundDelete"] = "GUILD_SOUNDBOARD_SOUND_DELETE";
    GatewayDispatchEvents2["GuildSoundboardSoundsUpdate"] = "GUILD_SOUNDBOARD_SOUNDS_UPDATE";
    GatewayDispatchEvents2["GuildSoundboardSoundUpdate"] = "GUILD_SOUNDBOARD_SOUND_UPDATE";
    GatewayDispatchEvents2["SoundboardSounds"] = "SOUNDBOARD_SOUNDS";
    GatewayDispatchEvents2["GuildStickersUpdate"] = "GUILD_STICKERS_UPDATE";
    GatewayDispatchEvents2["GuildUpdate"] = "GUILD_UPDATE";
    GatewayDispatchEvents2["IntegrationCreate"] = "INTEGRATION_CREATE";
    GatewayDispatchEvents2["IntegrationDelete"] = "INTEGRATION_DELETE";
    GatewayDispatchEvents2["IntegrationUpdate"] = "INTEGRATION_UPDATE";
    GatewayDispatchEvents2["InteractionCreate"] = "INTERACTION_CREATE";
    GatewayDispatchEvents2["InviteCreate"] = "INVITE_CREATE";
    GatewayDispatchEvents2["InviteDelete"] = "INVITE_DELETE";
    GatewayDispatchEvents2["MessageCreate"] = "MESSAGE_CREATE";
    GatewayDispatchEvents2["MessageDelete"] = "MESSAGE_DELETE";
    GatewayDispatchEvents2["MessageDeleteBulk"] = "MESSAGE_DELETE_BULK";
    GatewayDispatchEvents2["MessagePollVoteAdd"] = "MESSAGE_POLL_VOTE_ADD";
    GatewayDispatchEvents2["MessagePollVoteRemove"] = "MESSAGE_POLL_VOTE_REMOVE";
    GatewayDispatchEvents2["MessageReactionAdd"] = "MESSAGE_REACTION_ADD";
    GatewayDispatchEvents2["MessageReactionRemove"] = "MESSAGE_REACTION_REMOVE";
    GatewayDispatchEvents2["MessageReactionRemoveAll"] = "MESSAGE_REACTION_REMOVE_ALL";
    GatewayDispatchEvents2["MessageReactionRemoveEmoji"] = "MESSAGE_REACTION_REMOVE_EMOJI";
    GatewayDispatchEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
    GatewayDispatchEvents2["PresenceUpdate"] = "PRESENCE_UPDATE";
    GatewayDispatchEvents2["Ready"] = "READY";
    GatewayDispatchEvents2["Resumed"] = "RESUMED";
    GatewayDispatchEvents2["StageInstanceCreate"] = "STAGE_INSTANCE_CREATE";
    GatewayDispatchEvents2["StageInstanceDelete"] = "STAGE_INSTANCE_DELETE";
    GatewayDispatchEvents2["StageInstanceUpdate"] = "STAGE_INSTANCE_UPDATE";
    GatewayDispatchEvents2["SubscriptionCreate"] = "SUBSCRIPTION_CREATE";
    GatewayDispatchEvents2["SubscriptionDelete"] = "SUBSCRIPTION_DELETE";
    GatewayDispatchEvents2["SubscriptionUpdate"] = "SUBSCRIPTION_UPDATE";
    GatewayDispatchEvents2["ThreadCreate"] = "THREAD_CREATE";
    GatewayDispatchEvents2["ThreadDelete"] = "THREAD_DELETE";
    GatewayDispatchEvents2["ThreadListSync"] = "THREAD_LIST_SYNC";
    GatewayDispatchEvents2["ThreadMembersUpdate"] = "THREAD_MEMBERS_UPDATE";
    GatewayDispatchEvents2["ThreadMemberUpdate"] = "THREAD_MEMBER_UPDATE";
    GatewayDispatchEvents2["ThreadUpdate"] = "THREAD_UPDATE";
    GatewayDispatchEvents2["TypingStart"] = "TYPING_START";
    GatewayDispatchEvents2["UserUpdate"] = "USER_UPDATE";
    GatewayDispatchEvents2["VoiceChannelEffectSend"] = "VOICE_CHANNEL_EFFECT_SEND";
    GatewayDispatchEvents2["VoiceServerUpdate"] = "VOICE_SERVER_UPDATE";
    GatewayDispatchEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
    GatewayDispatchEvents2["WebhooksUpdate"] = "WEBHOOKS_UPDATE";
  })(GatewayDispatchEvents || (exports.GatewayDispatchEvents = GatewayDispatchEvents = {}));
  var VoiceChannelEffectSendAnimationType;
  (function(VoiceChannelEffectSendAnimationType2) {
    VoiceChannelEffectSendAnimationType2[VoiceChannelEffectSendAnimationType2["Premium"] = 0] = "Premium";
    VoiceChannelEffectSendAnimationType2[VoiceChannelEffectSendAnimationType2["Basic"] = 1] = "Basic";
  })(VoiceChannelEffectSendAnimationType || (exports.VoiceChannelEffectSendAnimationType = VoiceChannelEffectSendAnimationType = {}));
});

// node_modules/discord-api-types/globals.js
var require_globals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FormattingPatterns = undefined;
  exports.FormattingPatterns = {
    User: /<@(?<id>\d{17,20})>/,
    UserWithNickname: /<@!(?<id>\d{17,20})>/,
    UserWithOptionalNickname: /<@!?(?<id>\d{17,20})>/,
    Channel: /<#(?<id>\d{17,20})>/,
    Role: /<@&(?<id>\d{17,20})>/,
    SlashCommand: /<\/(?<fullName>(?<name>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32})(?: (?<subcommandOrGroup>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?(?: (?<subcommand>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?):(?<id>\d{17,20})>/u,
    Emoji: /<(?<animated>a)?:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    AnimatedEmoji: /<(?<animated>a):(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    StaticEmoji: /<:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    Timestamp: /<t:(?<timestamp>-?\d{1,13})(:(?<style>[DFRTdft]))?>/,
    DefaultStyledTimestamp: /<t:(?<timestamp>-?\d{1,13})>/,
    StyledTimestamp: /<t:(?<timestamp>-?\d{1,13}):(?<style>[DFRTdft])>/,
    GuildNavigation: /<id:(?<type>customize|browse|guide|linked-roles)>/,
    LinkedRole: /<id:linked-roles:(?<id>\d{17,20})>/
  };
  Object.freeze(exports.FormattingPatterns);
});

// node_modules/discord-api-types/payloads/common.js
var require_common2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PermissionFlagsBits = undefined;
  exports.PermissionFlagsBits = {
    CreateInstantInvite: 1n << 0n,
    KickMembers: 1n << 1n,
    BanMembers: 1n << 2n,
    Administrator: 1n << 3n,
    ManageChannels: 1n << 4n,
    ManageGuild: 1n << 5n,
    AddReactions: 1n << 6n,
    ViewAuditLog: 1n << 7n,
    PrioritySpeaker: 1n << 8n,
    Stream: 1n << 9n,
    ViewChannel: 1n << 10n,
    SendMessages: 1n << 11n,
    SendTTSMessages: 1n << 12n,
    ManageMessages: 1n << 13n,
    EmbedLinks: 1n << 14n,
    AttachFiles: 1n << 15n,
    ReadMessageHistory: 1n << 16n,
    MentionEveryone: 1n << 17n,
    UseExternalEmojis: 1n << 18n,
    ViewGuildInsights: 1n << 19n,
    Connect: 1n << 20n,
    Speak: 1n << 21n,
    MuteMembers: 1n << 22n,
    DeafenMembers: 1n << 23n,
    MoveMembers: 1n << 24n,
    UseVAD: 1n << 25n,
    ChangeNickname: 1n << 26n,
    ManageNicknames: 1n << 27n,
    ManageRoles: 1n << 28n,
    ManageWebhooks: 1n << 29n,
    ManageEmojisAndStickers: 1n << 30n,
    ManageGuildExpressions: 1n << 30n,
    UseApplicationCommands: 1n << 31n,
    RequestToSpeak: 1n << 32n,
    ManageEvents: 1n << 33n,
    ManageThreads: 1n << 34n,
    CreatePublicThreads: 1n << 35n,
    CreatePrivateThreads: 1n << 36n,
    UseExternalStickers: 1n << 37n,
    SendMessagesInThreads: 1n << 38n,
    UseEmbeddedActivities: 1n << 39n,
    ModerateMembers: 1n << 40n,
    ViewCreatorMonetizationAnalytics: 1n << 41n,
    UseSoundboard: 1n << 42n,
    CreateGuildExpressions: 1n << 43n,
    CreateEvents: 1n << 44n,
    UseExternalSounds: 1n << 45n,
    SendVoiceMessages: 1n << 46n,
    SendPolls: 1n << 49n,
    UseExternalApps: 1n << 50n
  };
  Object.freeze(exports.PermissionFlagsBits);
});

// node_modules/discord-api-types/payloads/v10/application.js
var require_application = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationWebhookEventStatus = exports.ApplicationRoleConnectionMetadataType = exports.ApplicationFlags = undefined;
  var ApplicationFlags;
  (function(ApplicationFlags2) {
    ApplicationFlags2[ApplicationFlags2["EmbeddedReleased"] = 2] = "EmbeddedReleased";
    ApplicationFlags2[ApplicationFlags2["ManagedEmoji"] = 4] = "ManagedEmoji";
    ApplicationFlags2[ApplicationFlags2["EmbeddedIAP"] = 8] = "EmbeddedIAP";
    ApplicationFlags2[ApplicationFlags2["GroupDMCreate"] = 16] = "GroupDMCreate";
    ApplicationFlags2[ApplicationFlags2["ApplicationAutoModerationRuleCreateBadge"] = 64] = "ApplicationAutoModerationRuleCreateBadge";
    ApplicationFlags2[ApplicationFlags2["RPCHasConnected"] = 2048] = "RPCHasConnected";
    ApplicationFlags2[ApplicationFlags2["GatewayPresence"] = 4096] = "GatewayPresence";
    ApplicationFlags2[ApplicationFlags2["GatewayPresenceLimited"] = 8192] = "GatewayPresenceLimited";
    ApplicationFlags2[ApplicationFlags2["GatewayGuildMembers"] = 16384] = "GatewayGuildMembers";
    ApplicationFlags2[ApplicationFlags2["GatewayGuildMembersLimited"] = 32768] = "GatewayGuildMembersLimited";
    ApplicationFlags2[ApplicationFlags2["VerificationPendingGuildLimit"] = 65536] = "VerificationPendingGuildLimit";
    ApplicationFlags2[ApplicationFlags2["Embedded"] = 131072] = "Embedded";
    ApplicationFlags2[ApplicationFlags2["GatewayMessageContent"] = 262144] = "GatewayMessageContent";
    ApplicationFlags2[ApplicationFlags2["GatewayMessageContentLimited"] = 524288] = "GatewayMessageContentLimited";
    ApplicationFlags2[ApplicationFlags2["EmbeddedFirstParty"] = 1048576] = "EmbeddedFirstParty";
    ApplicationFlags2[ApplicationFlags2["ApplicationCommandBadge"] = 8388608] = "ApplicationCommandBadge";
  })(ApplicationFlags || (exports.ApplicationFlags = ApplicationFlags = {}));
  var ApplicationRoleConnectionMetadataType;
  (function(ApplicationRoleConnectionMetadataType2) {
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerLessThanOrEqual"] = 1] = "IntegerLessThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerGreaterThanOrEqual"] = 2] = "IntegerGreaterThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerEqual"] = 3] = "IntegerEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerNotEqual"] = 4] = "IntegerNotEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeLessThanOrEqual"] = 5] = "DatetimeLessThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeGreaterThanOrEqual"] = 6] = "DatetimeGreaterThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanEqual"] = 7] = "BooleanEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanNotEqual"] = 8] = "BooleanNotEqual";
  })(ApplicationRoleConnectionMetadataType || (exports.ApplicationRoleConnectionMetadataType = ApplicationRoleConnectionMetadataType = {}));
  var ApplicationWebhookEventStatus;
  (function(ApplicationWebhookEventStatus2) {
    ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["Disabled"] = 1] = "Disabled";
    ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["Enabled"] = 2] = "Enabled";
    ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["DisabledByDiscord"] = 3] = "DisabledByDiscord";
  })(ApplicationWebhookEventStatus || (exports.ApplicationWebhookEventStatus = ApplicationWebhookEventStatus = {}));
});

// node_modules/discord-api-types/payloads/v10/auditLog.js
var require_auditLog = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AuditLogOptionsType = exports.AuditLogEvent = undefined;
  var AuditLogEvent;
  (function(AuditLogEvent2) {
    AuditLogEvent2[AuditLogEvent2["GuildUpdate"] = 1] = "GuildUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelCreate"] = 10] = "ChannelCreate";
    AuditLogEvent2[AuditLogEvent2["ChannelUpdate"] = 11] = "ChannelUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelDelete"] = 12] = "ChannelDelete";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteCreate"] = 13] = "ChannelOverwriteCreate";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteUpdate"] = 14] = "ChannelOverwriteUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteDelete"] = 15] = "ChannelOverwriteDelete";
    AuditLogEvent2[AuditLogEvent2["MemberKick"] = 20] = "MemberKick";
    AuditLogEvent2[AuditLogEvent2["MemberPrune"] = 21] = "MemberPrune";
    AuditLogEvent2[AuditLogEvent2["MemberBanAdd"] = 22] = "MemberBanAdd";
    AuditLogEvent2[AuditLogEvent2["MemberBanRemove"] = 23] = "MemberBanRemove";
    AuditLogEvent2[AuditLogEvent2["MemberUpdate"] = 24] = "MemberUpdate";
    AuditLogEvent2[AuditLogEvent2["MemberRoleUpdate"] = 25] = "MemberRoleUpdate";
    AuditLogEvent2[AuditLogEvent2["MemberMove"] = 26] = "MemberMove";
    AuditLogEvent2[AuditLogEvent2["MemberDisconnect"] = 27] = "MemberDisconnect";
    AuditLogEvent2[AuditLogEvent2["BotAdd"] = 28] = "BotAdd";
    AuditLogEvent2[AuditLogEvent2["RoleCreate"] = 30] = "RoleCreate";
    AuditLogEvent2[AuditLogEvent2["RoleUpdate"] = 31] = "RoleUpdate";
    AuditLogEvent2[AuditLogEvent2["RoleDelete"] = 32] = "RoleDelete";
    AuditLogEvent2[AuditLogEvent2["InviteCreate"] = 40] = "InviteCreate";
    AuditLogEvent2[AuditLogEvent2["InviteUpdate"] = 41] = "InviteUpdate";
    AuditLogEvent2[AuditLogEvent2["InviteDelete"] = 42] = "InviteDelete";
    AuditLogEvent2[AuditLogEvent2["WebhookCreate"] = 50] = "WebhookCreate";
    AuditLogEvent2[AuditLogEvent2["WebhookUpdate"] = 51] = "WebhookUpdate";
    AuditLogEvent2[AuditLogEvent2["WebhookDelete"] = 52] = "WebhookDelete";
    AuditLogEvent2[AuditLogEvent2["EmojiCreate"] = 60] = "EmojiCreate";
    AuditLogEvent2[AuditLogEvent2["EmojiUpdate"] = 61] = "EmojiUpdate";
    AuditLogEvent2[AuditLogEvent2["EmojiDelete"] = 62] = "EmojiDelete";
    AuditLogEvent2[AuditLogEvent2["MessageDelete"] = 72] = "MessageDelete";
    AuditLogEvent2[AuditLogEvent2["MessageBulkDelete"] = 73] = "MessageBulkDelete";
    AuditLogEvent2[AuditLogEvent2["MessagePin"] = 74] = "MessagePin";
    AuditLogEvent2[AuditLogEvent2["MessageUnpin"] = 75] = "MessageUnpin";
    AuditLogEvent2[AuditLogEvent2["IntegrationCreate"] = 80] = "IntegrationCreate";
    AuditLogEvent2[AuditLogEvent2["IntegrationUpdate"] = 81] = "IntegrationUpdate";
    AuditLogEvent2[AuditLogEvent2["IntegrationDelete"] = 82] = "IntegrationDelete";
    AuditLogEvent2[AuditLogEvent2["StageInstanceCreate"] = 83] = "StageInstanceCreate";
    AuditLogEvent2[AuditLogEvent2["StageInstanceUpdate"] = 84] = "StageInstanceUpdate";
    AuditLogEvent2[AuditLogEvent2["StageInstanceDelete"] = 85] = "StageInstanceDelete";
    AuditLogEvent2[AuditLogEvent2["StickerCreate"] = 90] = "StickerCreate";
    AuditLogEvent2[AuditLogEvent2["StickerUpdate"] = 91] = "StickerUpdate";
    AuditLogEvent2[AuditLogEvent2["StickerDelete"] = 92] = "StickerDelete";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventCreate"] = 100] = "GuildScheduledEventCreate";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventUpdate"] = 101] = "GuildScheduledEventUpdate";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventDelete"] = 102] = "GuildScheduledEventDelete";
    AuditLogEvent2[AuditLogEvent2["ThreadCreate"] = 110] = "ThreadCreate";
    AuditLogEvent2[AuditLogEvent2["ThreadUpdate"] = 111] = "ThreadUpdate";
    AuditLogEvent2[AuditLogEvent2["ThreadDelete"] = 112] = "ThreadDelete";
    AuditLogEvent2[AuditLogEvent2["ApplicationCommandPermissionUpdate"] = 121] = "ApplicationCommandPermissionUpdate";
    AuditLogEvent2[AuditLogEvent2["SoundboardSoundCreate"] = 130] = "SoundboardSoundCreate";
    AuditLogEvent2[AuditLogEvent2["SoundboardSoundUpdate"] = 131] = "SoundboardSoundUpdate";
    AuditLogEvent2[AuditLogEvent2["SoundboardSoundDelete"] = 132] = "SoundboardSoundDelete";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleCreate"] = 140] = "AutoModerationRuleCreate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleUpdate"] = 141] = "AutoModerationRuleUpdate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleDelete"] = 142] = "AutoModerationRuleDelete";
    AuditLogEvent2[AuditLogEvent2["AutoModerationBlockMessage"] = 143] = "AutoModerationBlockMessage";
    AuditLogEvent2[AuditLogEvent2["AutoModerationFlagToChannel"] = 144] = "AutoModerationFlagToChannel";
    AuditLogEvent2[AuditLogEvent2["AutoModerationUserCommunicationDisabled"] = 145] = "AutoModerationUserCommunicationDisabled";
    AuditLogEvent2[AuditLogEvent2["CreatorMonetizationRequestCreated"] = 150] = "CreatorMonetizationRequestCreated";
    AuditLogEvent2[AuditLogEvent2["CreatorMonetizationTermsAccepted"] = 151] = "CreatorMonetizationTermsAccepted";
    AuditLogEvent2[AuditLogEvent2["OnboardingPromptCreate"] = 163] = "OnboardingPromptCreate";
    AuditLogEvent2[AuditLogEvent2["OnboardingPromptUpdate"] = 164] = "OnboardingPromptUpdate";
    AuditLogEvent2[AuditLogEvent2["OnboardingPromptDelete"] = 165] = "OnboardingPromptDelete";
    AuditLogEvent2[AuditLogEvent2["OnboardingCreate"] = 166] = "OnboardingCreate";
    AuditLogEvent2[AuditLogEvent2["OnboardingUpdate"] = 167] = "OnboardingUpdate";
    AuditLogEvent2[AuditLogEvent2["HomeSettingsCreate"] = 190] = "HomeSettingsCreate";
    AuditLogEvent2[AuditLogEvent2["HomeSettingsUpdate"] = 191] = "HomeSettingsUpdate";
  })(AuditLogEvent || (exports.AuditLogEvent = AuditLogEvent = {}));
  var AuditLogOptionsType;
  (function(AuditLogOptionsType2) {
    AuditLogOptionsType2["Role"] = "0";
    AuditLogOptionsType2["Member"] = "1";
  })(AuditLogOptionsType || (exports.AuditLogOptionsType = AuditLogOptionsType = {}));
});

// node_modules/discord-api-types/payloads/v10/autoModeration.js
var require_autoModeration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutoModerationActionType = exports.AutoModerationRuleEventType = exports.AutoModerationRuleKeywordPresetType = exports.AutoModerationRuleTriggerType = undefined;
  var AutoModerationRuleTriggerType;
  (function(AutoModerationRuleTriggerType2) {
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Keyword"] = 1] = "Keyword";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Spam"] = 3] = "Spam";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["KeywordPreset"] = 4] = "KeywordPreset";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MentionSpam"] = 5] = "MentionSpam";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MemberProfile"] = 6] = "MemberProfile";
  })(AutoModerationRuleTriggerType || (exports.AutoModerationRuleTriggerType = AutoModerationRuleTriggerType = {}));
  var AutoModerationRuleKeywordPresetType;
  (function(AutoModerationRuleKeywordPresetType2) {
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Profanity"] = 1] = "Profanity";
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["SexualContent"] = 2] = "SexualContent";
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Slurs"] = 3] = "Slurs";
  })(AutoModerationRuleKeywordPresetType || (exports.AutoModerationRuleKeywordPresetType = AutoModerationRuleKeywordPresetType = {}));
  var AutoModerationRuleEventType;
  (function(AutoModerationRuleEventType2) {
    AutoModerationRuleEventType2[AutoModerationRuleEventType2["MessageSend"] = 1] = "MessageSend";
    AutoModerationRuleEventType2[AutoModerationRuleEventType2["MemberUpdate"] = 2] = "MemberUpdate";
  })(AutoModerationRuleEventType || (exports.AutoModerationRuleEventType = AutoModerationRuleEventType = {}));
  var AutoModerationActionType;
  (function(AutoModerationActionType2) {
    AutoModerationActionType2[AutoModerationActionType2["BlockMessage"] = 1] = "BlockMessage";
    AutoModerationActionType2[AutoModerationActionType2["SendAlertMessage"] = 2] = "SendAlertMessage";
    AutoModerationActionType2[AutoModerationActionType2["Timeout"] = 3] = "Timeout";
    AutoModerationActionType2[AutoModerationActionType2["BlockMemberInteraction"] = 4] = "BlockMemberInteraction";
  })(AutoModerationActionType || (exports.AutoModerationActionType = AutoModerationActionType = {}));
});

// node_modules/discord-api-types/payloads/v10/channel.js
var require_channel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChannelFlags = exports.SeparatorSpacingSize = exports.UnfurledMediaItemLoadingState = exports.SelectMenuDefaultValueType = exports.TextInputStyle = exports.ButtonStyle = exports.ComponentType = exports.AllowedMentionsTypes = exports.AttachmentFlags = exports.EmbedType = exports.ThreadMemberFlags = exports.ThreadAutoArchiveDuration = exports.OverwriteType = exports.MessageFlags = exports.MessageReferenceType = exports.MessageActivityType = exports.MessageType = exports.VideoQualityMode = exports.ChannelType = exports.ForumLayoutType = exports.SortOrderType = undefined;
  var SortOrderType;
  (function(SortOrderType2) {
    SortOrderType2[SortOrderType2["LatestActivity"] = 0] = "LatestActivity";
    SortOrderType2[SortOrderType2["CreationDate"] = 1] = "CreationDate";
  })(SortOrderType || (exports.SortOrderType = SortOrderType = {}));
  var ForumLayoutType;
  (function(ForumLayoutType2) {
    ForumLayoutType2[ForumLayoutType2["NotSet"] = 0] = "NotSet";
    ForumLayoutType2[ForumLayoutType2["ListView"] = 1] = "ListView";
    ForumLayoutType2[ForumLayoutType2["GalleryView"] = 2] = "GalleryView";
  })(ForumLayoutType || (exports.ForumLayoutType = ForumLayoutType = {}));
  var ChannelType;
  (function(ChannelType2) {
    ChannelType2[ChannelType2["GuildText"] = 0] = "GuildText";
    ChannelType2[ChannelType2["DM"] = 1] = "DM";
    ChannelType2[ChannelType2["GuildVoice"] = 2] = "GuildVoice";
    ChannelType2[ChannelType2["GroupDM"] = 3] = "GroupDM";
    ChannelType2[ChannelType2["GuildCategory"] = 4] = "GuildCategory";
    ChannelType2[ChannelType2["GuildAnnouncement"] = 5] = "GuildAnnouncement";
    ChannelType2[ChannelType2["AnnouncementThread"] = 10] = "AnnouncementThread";
    ChannelType2[ChannelType2["PublicThread"] = 11] = "PublicThread";
    ChannelType2[ChannelType2["PrivateThread"] = 12] = "PrivateThread";
    ChannelType2[ChannelType2["GuildStageVoice"] = 13] = "GuildStageVoice";
    ChannelType2[ChannelType2["GuildDirectory"] = 14] = "GuildDirectory";
    ChannelType2[ChannelType2["GuildForum"] = 15] = "GuildForum";
    ChannelType2[ChannelType2["GuildMedia"] = 16] = "GuildMedia";
    ChannelType2[ChannelType2["GuildNews"] = 5] = "GuildNews";
    ChannelType2[ChannelType2["GuildNewsThread"] = 10] = "GuildNewsThread";
    ChannelType2[ChannelType2["GuildPublicThread"] = 11] = "GuildPublicThread";
    ChannelType2[ChannelType2["GuildPrivateThread"] = 12] = "GuildPrivateThread";
  })(ChannelType || (exports.ChannelType = ChannelType = {}));
  var VideoQualityMode;
  (function(VideoQualityMode2) {
    VideoQualityMode2[VideoQualityMode2["Auto"] = 1] = "Auto";
    VideoQualityMode2[VideoQualityMode2["Full"] = 2] = "Full";
  })(VideoQualityMode || (exports.VideoQualityMode = VideoQualityMode = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2[MessageType2["Default"] = 0] = "Default";
    MessageType2[MessageType2["RecipientAdd"] = 1] = "RecipientAdd";
    MessageType2[MessageType2["RecipientRemove"] = 2] = "RecipientRemove";
    MessageType2[MessageType2["Call"] = 3] = "Call";
    MessageType2[MessageType2["ChannelNameChange"] = 4] = "ChannelNameChange";
    MessageType2[MessageType2["ChannelIconChange"] = 5] = "ChannelIconChange";
    MessageType2[MessageType2["ChannelPinnedMessage"] = 6] = "ChannelPinnedMessage";
    MessageType2[MessageType2["UserJoin"] = 7] = "UserJoin";
    MessageType2[MessageType2["GuildBoost"] = 8] = "GuildBoost";
    MessageType2[MessageType2["GuildBoostTier1"] = 9] = "GuildBoostTier1";
    MessageType2[MessageType2["GuildBoostTier2"] = 10] = "GuildBoostTier2";
    MessageType2[MessageType2["GuildBoostTier3"] = 11] = "GuildBoostTier3";
    MessageType2[MessageType2["ChannelFollowAdd"] = 12] = "ChannelFollowAdd";
    MessageType2[MessageType2["GuildDiscoveryDisqualified"] = 14] = "GuildDiscoveryDisqualified";
    MessageType2[MessageType2["GuildDiscoveryRequalified"] = 15] = "GuildDiscoveryRequalified";
    MessageType2[MessageType2["GuildDiscoveryGracePeriodInitialWarning"] = 16] = "GuildDiscoveryGracePeriodInitialWarning";
    MessageType2[MessageType2["GuildDiscoveryGracePeriodFinalWarning"] = 17] = "GuildDiscoveryGracePeriodFinalWarning";
    MessageType2[MessageType2["ThreadCreated"] = 18] = "ThreadCreated";
    MessageType2[MessageType2["Reply"] = 19] = "Reply";
    MessageType2[MessageType2["ChatInputCommand"] = 20] = "ChatInputCommand";
    MessageType2[MessageType2["ThreadStarterMessage"] = 21] = "ThreadStarterMessage";
    MessageType2[MessageType2["GuildInviteReminder"] = 22] = "GuildInviteReminder";
    MessageType2[MessageType2["ContextMenuCommand"] = 23] = "ContextMenuCommand";
    MessageType2[MessageType2["AutoModerationAction"] = 24] = "AutoModerationAction";
    MessageType2[MessageType2["RoleSubscriptionPurchase"] = 25] = "RoleSubscriptionPurchase";
    MessageType2[MessageType2["InteractionPremiumUpsell"] = 26] = "InteractionPremiumUpsell";
    MessageType2[MessageType2["StageStart"] = 27] = "StageStart";
    MessageType2[MessageType2["StageEnd"] = 28] = "StageEnd";
    MessageType2[MessageType2["StageSpeaker"] = 29] = "StageSpeaker";
    MessageType2[MessageType2["StageRaiseHand"] = 30] = "StageRaiseHand";
    MessageType2[MessageType2["StageTopic"] = 31] = "StageTopic";
    MessageType2[MessageType2["GuildApplicationPremiumSubscription"] = 32] = "GuildApplicationPremiumSubscription";
    MessageType2[MessageType2["GuildIncidentAlertModeEnabled"] = 36] = "GuildIncidentAlertModeEnabled";
    MessageType2[MessageType2["GuildIncidentAlertModeDisabled"] = 37] = "GuildIncidentAlertModeDisabled";
    MessageType2[MessageType2["GuildIncidentReportRaid"] = 38] = "GuildIncidentReportRaid";
    MessageType2[MessageType2["GuildIncidentReportFalseAlarm"] = 39] = "GuildIncidentReportFalseAlarm";
    MessageType2[MessageType2["PurchaseNotification"] = 44] = "PurchaseNotification";
    MessageType2[MessageType2["PollResult"] = 46] = "PollResult";
  })(MessageType || (exports.MessageType = MessageType = {}));
  var MessageActivityType;
  (function(MessageActivityType2) {
    MessageActivityType2[MessageActivityType2["Join"] = 1] = "Join";
    MessageActivityType2[MessageActivityType2["Spectate"] = 2] = "Spectate";
    MessageActivityType2[MessageActivityType2["Listen"] = 3] = "Listen";
    MessageActivityType2[MessageActivityType2["JoinRequest"] = 5] = "JoinRequest";
  })(MessageActivityType || (exports.MessageActivityType = MessageActivityType = {}));
  var MessageReferenceType;
  (function(MessageReferenceType2) {
    MessageReferenceType2[MessageReferenceType2["Default"] = 0] = "Default";
    MessageReferenceType2[MessageReferenceType2["Forward"] = 1] = "Forward";
  })(MessageReferenceType || (exports.MessageReferenceType = MessageReferenceType = {}));
  var MessageFlags;
  (function(MessageFlags2) {
    MessageFlags2[MessageFlags2["Crossposted"] = 1] = "Crossposted";
    MessageFlags2[MessageFlags2["IsCrosspost"] = 2] = "IsCrosspost";
    MessageFlags2[MessageFlags2["SuppressEmbeds"] = 4] = "SuppressEmbeds";
    MessageFlags2[MessageFlags2["SourceMessageDeleted"] = 8] = "SourceMessageDeleted";
    MessageFlags2[MessageFlags2["Urgent"] = 16] = "Urgent";
    MessageFlags2[MessageFlags2["HasThread"] = 32] = "HasThread";
    MessageFlags2[MessageFlags2["Ephemeral"] = 64] = "Ephemeral";
    MessageFlags2[MessageFlags2["Loading"] = 128] = "Loading";
    MessageFlags2[MessageFlags2["FailedToMentionSomeRolesInThread"] = 256] = "FailedToMentionSomeRolesInThread";
    MessageFlags2[MessageFlags2["ShouldShowLinkNotDiscordWarning"] = 1024] = "ShouldShowLinkNotDiscordWarning";
    MessageFlags2[MessageFlags2["SuppressNotifications"] = 4096] = "SuppressNotifications";
    MessageFlags2[MessageFlags2["IsVoiceMessage"] = 8192] = "IsVoiceMessage";
    MessageFlags2[MessageFlags2["HasSnapshot"] = 16384] = "HasSnapshot";
    MessageFlags2[MessageFlags2["IsComponentsV2"] = 32768] = "IsComponentsV2";
  })(MessageFlags || (exports.MessageFlags = MessageFlags = {}));
  var OverwriteType;
  (function(OverwriteType2) {
    OverwriteType2[OverwriteType2["Role"] = 0] = "Role";
    OverwriteType2[OverwriteType2["Member"] = 1] = "Member";
  })(OverwriteType || (exports.OverwriteType = OverwriteType = {}));
  var ThreadAutoArchiveDuration;
  (function(ThreadAutoArchiveDuration2) {
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneHour"] = 60] = "OneHour";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneDay"] = 1440] = "OneDay";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["ThreeDays"] = 4320] = "ThreeDays";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneWeek"] = 10080] = "OneWeek";
  })(ThreadAutoArchiveDuration || (exports.ThreadAutoArchiveDuration = ThreadAutoArchiveDuration = {}));
  var ThreadMemberFlags;
  (function(ThreadMemberFlags2) {
    ThreadMemberFlags2[ThreadMemberFlags2["HasInteracted"] = 1] = "HasInteracted";
    ThreadMemberFlags2[ThreadMemberFlags2["AllMessages"] = 2] = "AllMessages";
    ThreadMemberFlags2[ThreadMemberFlags2["OnlyMentions"] = 4] = "OnlyMentions";
    ThreadMemberFlags2[ThreadMemberFlags2["NoMessages"] = 8] = "NoMessages";
  })(ThreadMemberFlags || (exports.ThreadMemberFlags = ThreadMemberFlags = {}));
  var EmbedType;
  (function(EmbedType2) {
    EmbedType2["Rich"] = "rich";
    EmbedType2["Image"] = "image";
    EmbedType2["Video"] = "video";
    EmbedType2["GIFV"] = "gifv";
    EmbedType2["Article"] = "article";
    EmbedType2["Link"] = "link";
    EmbedType2["AutoModerationMessage"] = "auto_moderation_message";
    EmbedType2["PollResult"] = "poll_result";
  })(EmbedType || (exports.EmbedType = EmbedType = {}));
  var AttachmentFlags;
  (function(AttachmentFlags2) {
    AttachmentFlags2[AttachmentFlags2["IsRemix"] = 4] = "IsRemix";
  })(AttachmentFlags || (exports.AttachmentFlags = AttachmentFlags = {}));
  var AllowedMentionsTypes;
  (function(AllowedMentionsTypes2) {
    AllowedMentionsTypes2["Everyone"] = "everyone";
    AllowedMentionsTypes2["Role"] = "roles";
    AllowedMentionsTypes2["User"] = "users";
  })(AllowedMentionsTypes || (exports.AllowedMentionsTypes = AllowedMentionsTypes = {}));
  var ComponentType;
  (function(ComponentType2) {
    ComponentType2[ComponentType2["ActionRow"] = 1] = "ActionRow";
    ComponentType2[ComponentType2["Button"] = 2] = "Button";
    ComponentType2[ComponentType2["StringSelect"] = 3] = "StringSelect";
    ComponentType2[ComponentType2["TextInput"] = 4] = "TextInput";
    ComponentType2[ComponentType2["UserSelect"] = 5] = "UserSelect";
    ComponentType2[ComponentType2["RoleSelect"] = 6] = "RoleSelect";
    ComponentType2[ComponentType2["MentionableSelect"] = 7] = "MentionableSelect";
    ComponentType2[ComponentType2["ChannelSelect"] = 8] = "ChannelSelect";
    ComponentType2[ComponentType2["Section"] = 9] = "Section";
    ComponentType2[ComponentType2["TextDisplay"] = 10] = "TextDisplay";
    ComponentType2[ComponentType2["Thumbnail"] = 11] = "Thumbnail";
    ComponentType2[ComponentType2["MediaGallery"] = 12] = "MediaGallery";
    ComponentType2[ComponentType2["File"] = 13] = "File";
    ComponentType2[ComponentType2["Separator"] = 14] = "Separator";
    ComponentType2[ComponentType2["ContentInventoryEntry"] = 16] = "ContentInventoryEntry";
    ComponentType2[ComponentType2["Container"] = 17] = "Container";
    ComponentType2[ComponentType2["SelectMenu"] = 3] = "SelectMenu";
  })(ComponentType || (exports.ComponentType = ComponentType = {}));
  var ButtonStyle;
  (function(ButtonStyle2) {
    ButtonStyle2[ButtonStyle2["Primary"] = 1] = "Primary";
    ButtonStyle2[ButtonStyle2["Secondary"] = 2] = "Secondary";
    ButtonStyle2[ButtonStyle2["Success"] = 3] = "Success";
    ButtonStyle2[ButtonStyle2["Danger"] = 4] = "Danger";
    ButtonStyle2[ButtonStyle2["Link"] = 5] = "Link";
    ButtonStyle2[ButtonStyle2["Premium"] = 6] = "Premium";
  })(ButtonStyle || (exports.ButtonStyle = ButtonStyle = {}));
  var TextInputStyle;
  (function(TextInputStyle2) {
    TextInputStyle2[TextInputStyle2["Short"] = 1] = "Short";
    TextInputStyle2[TextInputStyle2["Paragraph"] = 2] = "Paragraph";
  })(TextInputStyle || (exports.TextInputStyle = TextInputStyle = {}));
  var SelectMenuDefaultValueType;
  (function(SelectMenuDefaultValueType2) {
    SelectMenuDefaultValueType2["Channel"] = "channel";
    SelectMenuDefaultValueType2["Role"] = "role";
    SelectMenuDefaultValueType2["User"] = "user";
  })(SelectMenuDefaultValueType || (exports.SelectMenuDefaultValueType = SelectMenuDefaultValueType = {}));
  var UnfurledMediaItemLoadingState;
  (function(UnfurledMediaItemLoadingState2) {
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["Unknown"] = 0] = "Unknown";
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["Loading"] = 1] = "Loading";
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["LoadedSuccess"] = 2] = "LoadedSuccess";
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["LoadedNotFound"] = 3] = "LoadedNotFound";
  })(UnfurledMediaItemLoadingState || (exports.UnfurledMediaItemLoadingState = UnfurledMediaItemLoadingState = {}));
  var SeparatorSpacingSize;
  (function(SeparatorSpacingSize2) {
    SeparatorSpacingSize2[SeparatorSpacingSize2["Small"] = 1] = "Small";
    SeparatorSpacingSize2[SeparatorSpacingSize2["Large"] = 2] = "Large";
  })(SeparatorSpacingSize || (exports.SeparatorSpacingSize = SeparatorSpacingSize = {}));
  var ChannelFlags;
  (function(ChannelFlags2) {
    ChannelFlags2[ChannelFlags2["GuildFeedRemoved"] = 1] = "GuildFeedRemoved";
    ChannelFlags2[ChannelFlags2["Pinned"] = 2] = "Pinned";
    ChannelFlags2[ChannelFlags2["ActiveChannelsRemoved"] = 4] = "ActiveChannelsRemoved";
    ChannelFlags2[ChannelFlags2["RequireTag"] = 16] = "RequireTag";
    ChannelFlags2[ChannelFlags2["IsSpam"] = 32] = "IsSpam";
    ChannelFlags2[ChannelFlags2["IsGuildResourceChannel"] = 128] = "IsGuildResourceChannel";
    ChannelFlags2[ChannelFlags2["ClydeAI"] = 256] = "ClydeAI";
    ChannelFlags2[ChannelFlags2["IsScheduledForDeletion"] = 512] = "IsScheduledForDeletion";
    ChannelFlags2[ChannelFlags2["HideMediaDownloadOptions"] = 32768] = "HideMediaDownloadOptions";
  })(ChannelFlags || (exports.ChannelFlags = ChannelFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/emoji.js
var require_emoji = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/gateway.js
var require_gateway = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ActivityFlags = exports.ActivityType = exports.ActivityPlatform = exports.PresenceUpdateStatus = undefined;
  var PresenceUpdateStatus;
  (function(PresenceUpdateStatus2) {
    PresenceUpdateStatus2["Online"] = "online";
    PresenceUpdateStatus2["DoNotDisturb"] = "dnd";
    PresenceUpdateStatus2["Idle"] = "idle";
    PresenceUpdateStatus2["Invisible"] = "invisible";
    PresenceUpdateStatus2["Offline"] = "offline";
  })(PresenceUpdateStatus || (exports.PresenceUpdateStatus = PresenceUpdateStatus = {}));
  var ActivityPlatform;
  (function(ActivityPlatform2) {
    ActivityPlatform2["Desktop"] = "desktop";
    ActivityPlatform2["Xbox"] = "xbox";
    ActivityPlatform2["Samsung"] = "samsung";
    ActivityPlatform2["IOS"] = "ios";
    ActivityPlatform2["Android"] = "android";
    ActivityPlatform2["Embedded"] = "embedded";
    ActivityPlatform2["PS4"] = "ps4";
    ActivityPlatform2["PS5"] = "ps5";
  })(ActivityPlatform || (exports.ActivityPlatform = ActivityPlatform = {}));
  var ActivityType;
  (function(ActivityType2) {
    ActivityType2[ActivityType2["Playing"] = 0] = "Playing";
    ActivityType2[ActivityType2["Streaming"] = 1] = "Streaming";
    ActivityType2[ActivityType2["Listening"] = 2] = "Listening";
    ActivityType2[ActivityType2["Watching"] = 3] = "Watching";
    ActivityType2[ActivityType2["Custom"] = 4] = "Custom";
    ActivityType2[ActivityType2["Competing"] = 5] = "Competing";
  })(ActivityType || (exports.ActivityType = ActivityType = {}));
  var ActivityFlags;
  (function(ActivityFlags2) {
    ActivityFlags2[ActivityFlags2["Instance"] = 1] = "Instance";
    ActivityFlags2[ActivityFlags2["Join"] = 2] = "Join";
    ActivityFlags2[ActivityFlags2["Spectate"] = 4] = "Spectate";
    ActivityFlags2[ActivityFlags2["JoinRequest"] = 8] = "JoinRequest";
    ActivityFlags2[ActivityFlags2["Sync"] = 16] = "Sync";
    ActivityFlags2[ActivityFlags2["Play"] = 32] = "Play";
    ActivityFlags2[ActivityFlags2["PartyPrivacyFriends"] = 64] = "PartyPrivacyFriends";
    ActivityFlags2[ActivityFlags2["PartyPrivacyVoiceChannel"] = 128] = "PartyPrivacyVoiceChannel";
    ActivityFlags2[ActivityFlags2["Embedded"] = 256] = "Embedded";
  })(ActivityFlags || (exports.ActivityFlags = ActivityFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/guild.js
var require_guild = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GuildOnboardingPromptType = exports.GuildOnboardingMode = exports.MembershipScreeningFieldType = exports.GuildWidgetStyle = exports.IntegrationExpireBehavior = exports.GuildMemberFlags = exports.GuildFeature = exports.GuildSystemChannelFlags = exports.GuildHubType = exports.GuildPremiumTier = exports.GuildVerificationLevel = exports.GuildNSFWLevel = exports.GuildMFALevel = exports.GuildExplicitContentFilter = exports.GuildDefaultMessageNotifications = undefined;
  var GuildDefaultMessageNotifications;
  (function(GuildDefaultMessageNotifications2) {
    GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["AllMessages"] = 0] = "AllMessages";
    GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["OnlyMentions"] = 1] = "OnlyMentions";
  })(GuildDefaultMessageNotifications || (exports.GuildDefaultMessageNotifications = GuildDefaultMessageNotifications = {}));
  var GuildExplicitContentFilter;
  (function(GuildExplicitContentFilter2) {
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["Disabled"] = 0] = "Disabled";
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["MembersWithoutRoles"] = 1] = "MembersWithoutRoles";
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["AllMembers"] = 2] = "AllMembers";
  })(GuildExplicitContentFilter || (exports.GuildExplicitContentFilter = GuildExplicitContentFilter = {}));
  var GuildMFALevel;
  (function(GuildMFALevel2) {
    GuildMFALevel2[GuildMFALevel2["None"] = 0] = "None";
    GuildMFALevel2[GuildMFALevel2["Elevated"] = 1] = "Elevated";
  })(GuildMFALevel || (exports.GuildMFALevel = GuildMFALevel = {}));
  var GuildNSFWLevel;
  (function(GuildNSFWLevel2) {
    GuildNSFWLevel2[GuildNSFWLevel2["Default"] = 0] = "Default";
    GuildNSFWLevel2[GuildNSFWLevel2["Explicit"] = 1] = "Explicit";
    GuildNSFWLevel2[GuildNSFWLevel2["Safe"] = 2] = "Safe";
    GuildNSFWLevel2[GuildNSFWLevel2["AgeRestricted"] = 3] = "AgeRestricted";
  })(GuildNSFWLevel || (exports.GuildNSFWLevel = GuildNSFWLevel = {}));
  var GuildVerificationLevel;
  (function(GuildVerificationLevel2) {
    GuildVerificationLevel2[GuildVerificationLevel2["None"] = 0] = "None";
    GuildVerificationLevel2[GuildVerificationLevel2["Low"] = 1] = "Low";
    GuildVerificationLevel2[GuildVerificationLevel2["Medium"] = 2] = "Medium";
    GuildVerificationLevel2[GuildVerificationLevel2["High"] = 3] = "High";
    GuildVerificationLevel2[GuildVerificationLevel2["VeryHigh"] = 4] = "VeryHigh";
  })(GuildVerificationLevel || (exports.GuildVerificationLevel = GuildVerificationLevel = {}));
  var GuildPremiumTier;
  (function(GuildPremiumTier2) {
    GuildPremiumTier2[GuildPremiumTier2["None"] = 0] = "None";
    GuildPremiumTier2[GuildPremiumTier2["Tier1"] = 1] = "Tier1";
    GuildPremiumTier2[GuildPremiumTier2["Tier2"] = 2] = "Tier2";
    GuildPremiumTier2[GuildPremiumTier2["Tier3"] = 3] = "Tier3";
  })(GuildPremiumTier || (exports.GuildPremiumTier = GuildPremiumTier = {}));
  var GuildHubType;
  (function(GuildHubType2) {
    GuildHubType2[GuildHubType2["Default"] = 0] = "Default";
    GuildHubType2[GuildHubType2["HighSchool"] = 1] = "HighSchool";
    GuildHubType2[GuildHubType2["College"] = 2] = "College";
  })(GuildHubType || (exports.GuildHubType = GuildHubType = {}));
  var GuildSystemChannelFlags;
  (function(GuildSystemChannelFlags2) {
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotifications"] = 1] = "SuppressJoinNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressPremiumSubscriptions"] = 2] = "SuppressPremiumSubscriptions";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressGuildReminderNotifications"] = 4] = "SuppressGuildReminderNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotificationReplies"] = 8] = "SuppressJoinNotificationReplies";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotifications"] = 16] = "SuppressRoleSubscriptionPurchaseNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotificationReplies"] = 32] = "SuppressRoleSubscriptionPurchaseNotificationReplies";
  })(GuildSystemChannelFlags || (exports.GuildSystemChannelFlags = GuildSystemChannelFlags = {}));
  var GuildFeature;
  (function(GuildFeature2) {
    GuildFeature2["AnimatedBanner"] = "ANIMATED_BANNER";
    GuildFeature2["AnimatedIcon"] = "ANIMATED_ICON";
    GuildFeature2["ApplicationCommandPermissionsV2"] = "APPLICATION_COMMAND_PERMISSIONS_V2";
    GuildFeature2["AutoModeration"] = "AUTO_MODERATION";
    GuildFeature2["Banner"] = "BANNER";
    GuildFeature2["Community"] = "COMMUNITY";
    GuildFeature2["CreatorMonetizableProvisional"] = "CREATOR_MONETIZABLE_PROVISIONAL";
    GuildFeature2["CreatorStorePage"] = "CREATOR_STORE_PAGE";
    GuildFeature2["DeveloperSupportServer"] = "DEVELOPER_SUPPORT_SERVER";
    GuildFeature2["Discoverable"] = "DISCOVERABLE";
    GuildFeature2["Featurable"] = "FEATURABLE";
    GuildFeature2["HasDirectoryEntry"] = "HAS_DIRECTORY_ENTRY";
    GuildFeature2["Hub"] = "HUB";
    GuildFeature2["InvitesDisabled"] = "INVITES_DISABLED";
    GuildFeature2["InviteSplash"] = "INVITE_SPLASH";
    GuildFeature2["LinkedToHub"] = "LINKED_TO_HUB";
    GuildFeature2["MemberVerificationGateEnabled"] = "MEMBER_VERIFICATION_GATE_ENABLED";
    GuildFeature2["MoreSoundboard"] = "MORE_SOUNDBOARD";
    GuildFeature2["MonetizationEnabled"] = "MONETIZATION_ENABLED";
    GuildFeature2["MoreStickers"] = "MORE_STICKERS";
    GuildFeature2["News"] = "NEWS";
    GuildFeature2["Partnered"] = "PARTNERED";
    GuildFeature2["PreviewEnabled"] = "PREVIEW_ENABLED";
    GuildFeature2["PrivateThreads"] = "PRIVATE_THREADS";
    GuildFeature2["RaidAlertsDisabled"] = "RAID_ALERTS_DISABLED";
    GuildFeature2["RelayEnabled"] = "RELAY_ENABLED";
    GuildFeature2["RoleIcons"] = "ROLE_ICONS";
    GuildFeature2["RoleSubscriptionsAvailableForPurchase"] = "ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE";
    GuildFeature2["RoleSubscriptionsEnabled"] = "ROLE_SUBSCRIPTIONS_ENABLED";
    GuildFeature2["Soundboard"] = "SOUNDBOARD";
    GuildFeature2["TicketedEventsEnabled"] = "TICKETED_EVENTS_ENABLED";
    GuildFeature2["VanityURL"] = "VANITY_URL";
    GuildFeature2["Verified"] = "VERIFIED";
    GuildFeature2["VIPRegions"] = "VIP_REGIONS";
    GuildFeature2["WelcomeScreenEnabled"] = "WELCOME_SCREEN_ENABLED";
  })(GuildFeature || (exports.GuildFeature = GuildFeature = {}));
  var GuildMemberFlags;
  (function(GuildMemberFlags2) {
    GuildMemberFlags2[GuildMemberFlags2["DidRejoin"] = 1] = "DidRejoin";
    GuildMemberFlags2[GuildMemberFlags2["CompletedOnboarding"] = 2] = "CompletedOnboarding";
    GuildMemberFlags2[GuildMemberFlags2["BypassesVerification"] = 4] = "BypassesVerification";
    GuildMemberFlags2[GuildMemberFlags2["StartedOnboarding"] = 8] = "StartedOnboarding";
    GuildMemberFlags2[GuildMemberFlags2["IsGuest"] = 16] = "IsGuest";
    GuildMemberFlags2[GuildMemberFlags2["StartedHomeActions"] = 32] = "StartedHomeActions";
    GuildMemberFlags2[GuildMemberFlags2["CompletedHomeActions"] = 64] = "CompletedHomeActions";
    GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedUsernameOrGuildNickname"] = 128] = "AutomodQuarantinedUsernameOrGuildNickname";
    GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedBio"] = 256] = "AutomodQuarantinedBio";
    GuildMemberFlags2[GuildMemberFlags2["DmSettingsUpsellAcknowledged"] = 512] = "DmSettingsUpsellAcknowledged";
  })(GuildMemberFlags || (exports.GuildMemberFlags = GuildMemberFlags = {}));
  var IntegrationExpireBehavior;
  (function(IntegrationExpireBehavior2) {
    IntegrationExpireBehavior2[IntegrationExpireBehavior2["RemoveRole"] = 0] = "RemoveRole";
    IntegrationExpireBehavior2[IntegrationExpireBehavior2["Kick"] = 1] = "Kick";
  })(IntegrationExpireBehavior || (exports.IntegrationExpireBehavior = IntegrationExpireBehavior = {}));
  var GuildWidgetStyle;
  (function(GuildWidgetStyle2) {
    GuildWidgetStyle2["Shield"] = "shield";
    GuildWidgetStyle2["Banner1"] = "banner1";
    GuildWidgetStyle2["Banner2"] = "banner2";
    GuildWidgetStyle2["Banner3"] = "banner3";
    GuildWidgetStyle2["Banner4"] = "banner4";
  })(GuildWidgetStyle || (exports.GuildWidgetStyle = GuildWidgetStyle = {}));
  var MembershipScreeningFieldType;
  (function(MembershipScreeningFieldType2) {
    MembershipScreeningFieldType2["Terms"] = "TERMS";
  })(MembershipScreeningFieldType || (exports.MembershipScreeningFieldType = MembershipScreeningFieldType = {}));
  var GuildOnboardingMode;
  (function(GuildOnboardingMode2) {
    GuildOnboardingMode2[GuildOnboardingMode2["OnboardingDefault"] = 0] = "OnboardingDefault";
    GuildOnboardingMode2[GuildOnboardingMode2["OnboardingAdvanced"] = 1] = "OnboardingAdvanced";
  })(GuildOnboardingMode || (exports.GuildOnboardingMode = GuildOnboardingMode = {}));
  var GuildOnboardingPromptType;
  (function(GuildOnboardingPromptType2) {
    GuildOnboardingPromptType2[GuildOnboardingPromptType2["MultipleChoice"] = 0] = "MultipleChoice";
    GuildOnboardingPromptType2[GuildOnboardingPromptType2["Dropdown"] = 1] = "Dropdown";
  })(GuildOnboardingPromptType || (exports.GuildOnboardingPromptType = GuildOnboardingPromptType = {}));
});

// node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js
var require_guildScheduledEvent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GuildScheduledEventPrivacyLevel = exports.GuildScheduledEventStatus = exports.GuildScheduledEventEntityType = exports.GuildScheduledEventRecurrenceRuleMonth = exports.GuildScheduledEventRecurrenceRuleWeekday = exports.GuildScheduledEventRecurrenceRuleFrequency = undefined;
  var GuildScheduledEventRecurrenceRuleFrequency;
  (function(GuildScheduledEventRecurrenceRuleFrequency2) {
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Yearly"] = 0] = "Yearly";
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Monthly"] = 1] = "Monthly";
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Weekly"] = 2] = "Weekly";
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Daily"] = 3] = "Daily";
  })(GuildScheduledEventRecurrenceRuleFrequency || (exports.GuildScheduledEventRecurrenceRuleFrequency = GuildScheduledEventRecurrenceRuleFrequency = {}));
  var GuildScheduledEventRecurrenceRuleWeekday;
  (function(GuildScheduledEventRecurrenceRuleWeekday2) {
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Monday"] = 0] = "Monday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Tuesday"] = 1] = "Tuesday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Wednesday"] = 2] = "Wednesday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Thursday"] = 3] = "Thursday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Friday"] = 4] = "Friday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Saturday"] = 5] = "Saturday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Sunday"] = 6] = "Sunday";
  })(GuildScheduledEventRecurrenceRuleWeekday || (exports.GuildScheduledEventRecurrenceRuleWeekday = GuildScheduledEventRecurrenceRuleWeekday = {}));
  var GuildScheduledEventRecurrenceRuleMonth;
  (function(GuildScheduledEventRecurrenceRuleMonth2) {
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["January"] = 1] = "January";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["February"] = 2] = "February";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["March"] = 3] = "March";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["April"] = 4] = "April";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["May"] = 5] = "May";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["June"] = 6] = "June";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["July"] = 7] = "July";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["August"] = 8] = "August";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["September"] = 9] = "September";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["October"] = 10] = "October";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["November"] = 11] = "November";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["December"] = 12] = "December";
  })(GuildScheduledEventRecurrenceRuleMonth || (exports.GuildScheduledEventRecurrenceRuleMonth = GuildScheduledEventRecurrenceRuleMonth = {}));
  var GuildScheduledEventEntityType;
  (function(GuildScheduledEventEntityType2) {
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["StageInstance"] = 1] = "StageInstance";
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["Voice"] = 2] = "Voice";
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["External"] = 3] = "External";
  })(GuildScheduledEventEntityType || (exports.GuildScheduledEventEntityType = GuildScheduledEventEntityType = {}));
  var GuildScheduledEventStatus;
  (function(GuildScheduledEventStatus2) {
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Scheduled"] = 1] = "Scheduled";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Active"] = 2] = "Active";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Completed"] = 3] = "Completed";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Canceled"] = 4] = "Canceled";
  })(GuildScheduledEventStatus || (exports.GuildScheduledEventStatus = GuildScheduledEventStatus = {}));
  var GuildScheduledEventPrivacyLevel;
  (function(GuildScheduledEventPrivacyLevel2) {
    GuildScheduledEventPrivacyLevel2[GuildScheduledEventPrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
  })(GuildScheduledEventPrivacyLevel || (exports.GuildScheduledEventPrivacyLevel = GuildScheduledEventPrivacyLevel = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/attachment.js
var require_attachment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/base.js
var require_base = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/boolean.js
var require_boolean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/channel.js
var require_channel2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/integer.js
var require_integer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/mentionable.js
var require_mentionable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/number.js
var require_number = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/role.js
var require_role = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js
var require_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationCommandOptionType = undefined;
  var ApplicationCommandOptionType;
  (function(ApplicationCommandOptionType2) {
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Subcommand"] = 1] = "Subcommand";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["SubcommandGroup"] = 2] = "SubcommandGroup";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["String"] = 3] = "String";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Integer"] = 4] = "Integer";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Boolean"] = 5] = "Boolean";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["User"] = 6] = "User";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Channel"] = 7] = "Channel";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Role"] = 8] = "Role";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Mentionable"] = 9] = "Mentionable";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Number"] = 10] = "Number";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Attachment"] = 11] = "Attachment";
  })(ApplicationCommandOptionType || (exports.ApplicationCommandOptionType = ApplicationCommandOptionType = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/string.js
var require_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommand.js
var require_subcommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommandGroup.js
var require_subcommandGroup = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/user.js
var require_user = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js
var require_chatInput = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_attachment(), exports);
  __exportStar(require_base(), exports);
  __exportStar(require_boolean(), exports);
  __exportStar(require_channel2(), exports);
  __exportStar(require_integer(), exports);
  __exportStar(require_mentionable(), exports);
  __exportStar(require_number(), exports);
  __exportStar(require_role(), exports);
  __exportStar(require_shared(), exports);
  __exportStar(require_string(), exports);
  __exportStar(require_subcommand(), exports);
  __exportStar(require_subcommandGroup(), exports);
  __exportStar(require_user(), exports);
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/contextMenu.js
var require_contextMenu = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js
var require_permissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.APIApplicationCommandPermissionsConstant = exports.ApplicationCommandPermissionType = undefined;
  var ApplicationCommandPermissionType;
  (function(ApplicationCommandPermissionType2) {
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Role"] = 1] = "Role";
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["User"] = 2] = "User";
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Channel"] = 3] = "Channel";
  })(ApplicationCommandPermissionType || (exports.ApplicationCommandPermissionType = ApplicationCommandPermissionType = {}));
  exports.APIApplicationCommandPermissionsConstant = {
    Everyone: (guildId) => String(guildId),
    AllChannels: (guildId) => String(BigInt(guildId) - 1n)
  };
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/entryPoint.js
var require_entryPoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/internals.js
var require_internals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js
var require_applicationCommands = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntryPointCommandHandlerType = exports.InteractionContextType = exports.ApplicationIntegrationType = exports.ApplicationCommandType = undefined;
  __exportStar(require_chatInput(), exports);
  __exportStar(require_contextMenu(), exports);
  __exportStar(require_permissions(), exports);
  __exportStar(require_entryPoint(), exports);
  __exportStar(require_internals(), exports);
  var ApplicationCommandType;
  (function(ApplicationCommandType2) {
    ApplicationCommandType2[ApplicationCommandType2["ChatInput"] = 1] = "ChatInput";
    ApplicationCommandType2[ApplicationCommandType2["User"] = 2] = "User";
    ApplicationCommandType2[ApplicationCommandType2["Message"] = 3] = "Message";
    ApplicationCommandType2[ApplicationCommandType2["PrimaryEntryPoint"] = 4] = "PrimaryEntryPoint";
  })(ApplicationCommandType || (exports.ApplicationCommandType = ApplicationCommandType = {}));
  var ApplicationIntegrationType;
  (function(ApplicationIntegrationType2) {
    ApplicationIntegrationType2[ApplicationIntegrationType2["GuildInstall"] = 0] = "GuildInstall";
    ApplicationIntegrationType2[ApplicationIntegrationType2["UserInstall"] = 1] = "UserInstall";
  })(ApplicationIntegrationType || (exports.ApplicationIntegrationType = ApplicationIntegrationType = {}));
  var InteractionContextType;
  (function(InteractionContextType2) {
    InteractionContextType2[InteractionContextType2["Guild"] = 0] = "Guild";
    InteractionContextType2[InteractionContextType2["BotDM"] = 1] = "BotDM";
    InteractionContextType2[InteractionContextType2["PrivateChannel"] = 2] = "PrivateChannel";
  })(InteractionContextType || (exports.InteractionContextType = InteractionContextType = {}));
  var EntryPointCommandHandlerType;
  (function(EntryPointCommandHandlerType2) {
    EntryPointCommandHandlerType2[EntryPointCommandHandlerType2["AppHandler"] = 1] = "AppHandler";
    EntryPointCommandHandlerType2[EntryPointCommandHandlerType2["DiscordLaunchActivity"] = 2] = "DiscordLaunchActivity";
  })(EntryPointCommandHandlerType || (exports.EntryPointCommandHandlerType = EntryPointCommandHandlerType = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/autocomplete.js
var require_autocomplete = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/base.js
var require_base2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/messageComponents.js
var require_messageComponents = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/modalSubmit.js
var require_modalSubmit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/ping.js
var require_ping = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/responses.js
var require_responses = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InteractionResponseType = exports.InteractionType = undefined;
  var InteractionType;
  (function(InteractionType2) {
    InteractionType2[InteractionType2["Ping"] = 1] = "Ping";
    InteractionType2[InteractionType2["ApplicationCommand"] = 2] = "ApplicationCommand";
    InteractionType2[InteractionType2["MessageComponent"] = 3] = "MessageComponent";
    InteractionType2[InteractionType2["ApplicationCommandAutocomplete"] = 4] = "ApplicationCommandAutocomplete";
    InteractionType2[InteractionType2["ModalSubmit"] = 5] = "ModalSubmit";
  })(InteractionType || (exports.InteractionType = InteractionType = {}));
  var InteractionResponseType;
  (function(InteractionResponseType2) {
    InteractionResponseType2[InteractionResponseType2["Pong"] = 1] = "Pong";
    InteractionResponseType2[InteractionResponseType2["ChannelMessageWithSource"] = 4] = "ChannelMessageWithSource";
    InteractionResponseType2[InteractionResponseType2["DeferredChannelMessageWithSource"] = 5] = "DeferredChannelMessageWithSource";
    InteractionResponseType2[InteractionResponseType2["DeferredMessageUpdate"] = 6] = "DeferredMessageUpdate";
    InteractionResponseType2[InteractionResponseType2["UpdateMessage"] = 7] = "UpdateMessage";
    InteractionResponseType2[InteractionResponseType2["ApplicationCommandAutocompleteResult"] = 8] = "ApplicationCommandAutocompleteResult";
    InteractionResponseType2[InteractionResponseType2["Modal"] = 9] = "Modal";
    InteractionResponseType2[InteractionResponseType2["PremiumRequired"] = 10] = "PremiumRequired";
    InteractionResponseType2[InteractionResponseType2["LaunchActivity"] = 12] = "LaunchActivity";
  })(InteractionResponseType || (exports.InteractionResponseType = InteractionResponseType = {}));
});

// node_modules/discord-api-types/payloads/v10/interactions.js
var require_interactions = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_applicationCommands(), exports);
  __exportStar(require_autocomplete(), exports);
  __exportStar(require_base2(), exports);
  __exportStar(require_messageComponents(), exports);
  __exportStar(require_modalSubmit(), exports);
  __exportStar(require_ping(), exports);
  __exportStar(require_responses(), exports);
});

// node_modules/discord-api-types/payloads/v10/invite.js
var require_invite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InviteTargetType = exports.InviteType = undefined;
  var InviteType;
  (function(InviteType2) {
    InviteType2[InviteType2["Guild"] = 0] = "Guild";
    InviteType2[InviteType2["GroupDM"] = 1] = "GroupDM";
    InviteType2[InviteType2["Friend"] = 2] = "Friend";
  })(InviteType || (exports.InviteType = InviteType = {}));
  var InviteTargetType;
  (function(InviteTargetType2) {
    InviteTargetType2[InviteTargetType2["Stream"] = 1] = "Stream";
    InviteTargetType2[InviteTargetType2["EmbeddedApplication"] = 2] = "EmbeddedApplication";
  })(InviteTargetType || (exports.InviteTargetType = InviteTargetType = {}));
});

// node_modules/discord-api-types/payloads/v10/monetization.js
var require_monetization = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SubscriptionStatus = exports.SKUType = exports.SKUFlags = exports.EntitlementType = undefined;
  var EntitlementType;
  (function(EntitlementType2) {
    EntitlementType2[EntitlementType2["Purchase"] = 1] = "Purchase";
    EntitlementType2[EntitlementType2["PremiumSubscription"] = 2] = "PremiumSubscription";
    EntitlementType2[EntitlementType2["DeveloperGift"] = 3] = "DeveloperGift";
    EntitlementType2[EntitlementType2["TestModePurchase"] = 4] = "TestModePurchase";
    EntitlementType2[EntitlementType2["FreePurchase"] = 5] = "FreePurchase";
    EntitlementType2[EntitlementType2["UserGift"] = 6] = "UserGift";
    EntitlementType2[EntitlementType2["PremiumPurchase"] = 7] = "PremiumPurchase";
    EntitlementType2[EntitlementType2["ApplicationSubscription"] = 8] = "ApplicationSubscription";
  })(EntitlementType || (exports.EntitlementType = EntitlementType = {}));
  var SKUFlags;
  (function(SKUFlags2) {
    SKUFlags2[SKUFlags2["Available"] = 4] = "Available";
    SKUFlags2[SKUFlags2["GuildSubscription"] = 128] = "GuildSubscription";
    SKUFlags2[SKUFlags2["UserSubscription"] = 256] = "UserSubscription";
  })(SKUFlags || (exports.SKUFlags = SKUFlags = {}));
  var SKUType;
  (function(SKUType2) {
    SKUType2[SKUType2["Durable"] = 2] = "Durable";
    SKUType2[SKUType2["Consumable"] = 3] = "Consumable";
    SKUType2[SKUType2["Subscription"] = 5] = "Subscription";
    SKUType2[SKUType2["SubscriptionGroup"] = 6] = "SubscriptionGroup";
  })(SKUType || (exports.SKUType = SKUType = {}));
  var SubscriptionStatus;
  (function(SubscriptionStatus2) {
    SubscriptionStatus2[SubscriptionStatus2["Active"] = 0] = "Active";
    SubscriptionStatus2[SubscriptionStatus2["Ending"] = 1] = "Ending";
    SubscriptionStatus2[SubscriptionStatus2["Inactive"] = 2] = "Inactive";
  })(SubscriptionStatus || (exports.SubscriptionStatus = SubscriptionStatus = {}));
});

// node_modules/discord-api-types/payloads/v10/oauth2.js
var require_oauth2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Scopes = undefined;
  var OAuth2Scopes;
  (function(OAuth2Scopes2) {
    OAuth2Scopes2["Bot"] = "bot";
    OAuth2Scopes2["Connections"] = "connections";
    OAuth2Scopes2["DMChannelsRead"] = "dm_channels.read";
    OAuth2Scopes2["Email"] = "email";
    OAuth2Scopes2["Identify"] = "identify";
    OAuth2Scopes2["Guilds"] = "guilds";
    OAuth2Scopes2["GuildsJoin"] = "guilds.join";
    OAuth2Scopes2["GuildsMembersRead"] = "guilds.members.read";
    OAuth2Scopes2["GroupDMJoins"] = "gdm.join";
    OAuth2Scopes2["MessagesRead"] = "messages.read";
    OAuth2Scopes2["RoleConnectionsWrite"] = "role_connections.write";
    OAuth2Scopes2["RPC"] = "rpc";
    OAuth2Scopes2["RPCActivitiesWrite"] = "rpc.activities.write";
    OAuth2Scopes2["RPCVoiceRead"] = "rpc.voice.read";
    OAuth2Scopes2["RPCVoiceWrite"] = "rpc.voice.write";
    OAuth2Scopes2["RPCNotificationsRead"] = "rpc.notifications.read";
    OAuth2Scopes2["WebhookIncoming"] = "webhook.incoming";
    OAuth2Scopes2["Voice"] = "voice";
    OAuth2Scopes2["ApplicationsBuildsUpload"] = "applications.builds.upload";
    OAuth2Scopes2["ApplicationsBuildsRead"] = "applications.builds.read";
    OAuth2Scopes2["ApplicationsStoreUpdate"] = "applications.store.update";
    OAuth2Scopes2["ApplicationsEntitlements"] = "applications.entitlements";
    OAuth2Scopes2["RelationshipsRead"] = "relationships.read";
    OAuth2Scopes2["ActivitiesRead"] = "activities.read";
    OAuth2Scopes2["ActivitiesWrite"] = "activities.write";
    OAuth2Scopes2["ApplicationsCommands"] = "applications.commands";
    OAuth2Scopes2["ApplicationsCommandsUpdate"] = "applications.commands.update";
    OAuth2Scopes2["ApplicationCommandsPermissionsUpdate"] = "applications.commands.permissions.update";
  })(OAuth2Scopes || (exports.OAuth2Scopes = OAuth2Scopes = {}));
});

// node_modules/discord-api-types/payloads/v10/permissions.js
var require_permissions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RoleFlags = undefined;
  var RoleFlags;
  (function(RoleFlags2) {
    RoleFlags2[RoleFlags2["InPrompt"] = 1] = "InPrompt";
  })(RoleFlags || (exports.RoleFlags = RoleFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/poll.js
var require_poll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollLayoutType = undefined;
  var PollLayoutType;
  (function(PollLayoutType2) {
    PollLayoutType2[PollLayoutType2["Default"] = 1] = "Default";
  })(PollLayoutType || (exports.PollLayoutType = PollLayoutType = {}));
});

// node_modules/discord-api-types/payloads/v10/soundboard.js
var require_soundboard = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/stageInstance.js
var require_stageInstance = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StageInstancePrivacyLevel = undefined;
  var StageInstancePrivacyLevel;
  (function(StageInstancePrivacyLevel2) {
    StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["Public"] = 1] = "Public";
    StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
  })(StageInstancePrivacyLevel || (exports.StageInstancePrivacyLevel = StageInstancePrivacyLevel = {}));
});

// node_modules/discord-api-types/payloads/v10/sticker.js
var require_sticker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StickerFormatType = exports.StickerType = undefined;
  var StickerType;
  (function(StickerType2) {
    StickerType2[StickerType2["Standard"] = 1] = "Standard";
    StickerType2[StickerType2["Guild"] = 2] = "Guild";
  })(StickerType || (exports.StickerType = StickerType = {}));
  var StickerFormatType;
  (function(StickerFormatType2) {
    StickerFormatType2[StickerFormatType2["PNG"] = 1] = "PNG";
    StickerFormatType2[StickerFormatType2["APNG"] = 2] = "APNG";
    StickerFormatType2[StickerFormatType2["Lottie"] = 3] = "Lottie";
    StickerFormatType2[StickerFormatType2["GIF"] = 4] = "GIF";
  })(StickerFormatType || (exports.StickerFormatType = StickerFormatType = {}));
});

// node_modules/discord-api-types/payloads/v10/teams.js
var require_teams = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TeamMemberRole = exports.TeamMemberMembershipState = undefined;
  var TeamMemberMembershipState;
  (function(TeamMemberMembershipState2) {
    TeamMemberMembershipState2[TeamMemberMembershipState2["Invited"] = 1] = "Invited";
    TeamMemberMembershipState2[TeamMemberMembershipState2["Accepted"] = 2] = "Accepted";
  })(TeamMemberMembershipState || (exports.TeamMemberMembershipState = TeamMemberMembershipState = {}));
  var TeamMemberRole;
  (function(TeamMemberRole2) {
    TeamMemberRole2["Admin"] = "admin";
    TeamMemberRole2["Developer"] = "developer";
    TeamMemberRole2["ReadOnly"] = "read_only";
  })(TeamMemberRole || (exports.TeamMemberRole = TeamMemberRole = {}));
});

// node_modules/discord-api-types/payloads/v10/template.js
var require_template = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/user.js
var require_user2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionVisibility = exports.ConnectionService = exports.UserPremiumType = exports.UserFlags = undefined;
  var UserFlags;
  (function(UserFlags2) {
    UserFlags2[UserFlags2["Staff"] = 1] = "Staff";
    UserFlags2[UserFlags2["Partner"] = 2] = "Partner";
    UserFlags2[UserFlags2["Hypesquad"] = 4] = "Hypesquad";
    UserFlags2[UserFlags2["BugHunterLevel1"] = 8] = "BugHunterLevel1";
    UserFlags2[UserFlags2["MFASMS"] = 16] = "MFASMS";
    UserFlags2[UserFlags2["PremiumPromoDismissed"] = 32] = "PremiumPromoDismissed";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse1"] = 64] = "HypeSquadOnlineHouse1";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse2"] = 128] = "HypeSquadOnlineHouse2";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse3"] = 256] = "HypeSquadOnlineHouse3";
    UserFlags2[UserFlags2["PremiumEarlySupporter"] = 512] = "PremiumEarlySupporter";
    UserFlags2[UserFlags2["TeamPseudoUser"] = 1024] = "TeamPseudoUser";
    UserFlags2[UserFlags2["HasUnreadUrgentMessages"] = 8192] = "HasUnreadUrgentMessages";
    UserFlags2[UserFlags2["BugHunterLevel2"] = 16384] = "BugHunterLevel2";
    UserFlags2[UserFlags2["VerifiedBot"] = 65536] = "VerifiedBot";
    UserFlags2[UserFlags2["VerifiedDeveloper"] = 131072] = "VerifiedDeveloper";
    UserFlags2[UserFlags2["CertifiedModerator"] = 262144] = "CertifiedModerator";
    UserFlags2[UserFlags2["BotHTTPInteractions"] = 524288] = "BotHTTPInteractions";
    UserFlags2[UserFlags2["Spammer"] = 1048576] = "Spammer";
    UserFlags2[UserFlags2["DisablePremium"] = 2097152] = "DisablePremium";
    UserFlags2[UserFlags2["ActiveDeveloper"] = 4194304] = "ActiveDeveloper";
    UserFlags2[UserFlags2["Quarantined"] = 17592186044416] = "Quarantined";
    UserFlags2[UserFlags2["Collaborator"] = 1125899906842624] = "Collaborator";
    UserFlags2[UserFlags2["RestrictedCollaborator"] = 2251799813685248] = "RestrictedCollaborator";
  })(UserFlags || (exports.UserFlags = UserFlags = {}));
  var UserPremiumType;
  (function(UserPremiumType2) {
    UserPremiumType2[UserPremiumType2["None"] = 0] = "None";
    UserPremiumType2[UserPremiumType2["NitroClassic"] = 1] = "NitroClassic";
    UserPremiumType2[UserPremiumType2["Nitro"] = 2] = "Nitro";
    UserPremiumType2[UserPremiumType2["NitroBasic"] = 3] = "NitroBasic";
  })(UserPremiumType || (exports.UserPremiumType = UserPremiumType = {}));
  var ConnectionService;
  (function(ConnectionService2) {
    ConnectionService2["AmazonMusic"] = "amazon-music";
    ConnectionService2["BattleNet"] = "battlenet";
    ConnectionService2["Bluesky"] = "bluesky";
    ConnectionService2["BungieNet"] = "bungie";
    ConnectionService2["Crunchyroll"] = "crunchyroll";
    ConnectionService2["Domain"] = "domain";
    ConnectionService2["eBay"] = "ebay";
    ConnectionService2["EpicGames"] = "epicgames";
    ConnectionService2["Facebook"] = "facebook";
    ConnectionService2["GitHub"] = "github";
    ConnectionService2["Instagram"] = "instagram";
    ConnectionService2["LeagueOfLegends"] = "leagueoflegends";
    ConnectionService2["Mastodon"] = "mastodon";
    ConnectionService2["PayPal"] = "paypal";
    ConnectionService2["PlayStationNetwork"] = "playstation";
    ConnectionService2["Reddit"] = "reddit";
    ConnectionService2["RiotGames"] = "riotgames";
    ConnectionService2["Roblox"] = "roblox";
    ConnectionService2["Spotify"] = "spotify";
    ConnectionService2["Skype"] = "skype";
    ConnectionService2["Steam"] = "steam";
    ConnectionService2["TikTok"] = "tiktok";
    ConnectionService2["Twitch"] = "twitch";
    ConnectionService2["X"] = "twitter";
    ConnectionService2["Twitter"] = "twitter";
    ConnectionService2["Xbox"] = "xbox";
    ConnectionService2["YouTube"] = "youtube";
  })(ConnectionService || (exports.ConnectionService = ConnectionService = {}));
  var ConnectionVisibility;
  (function(ConnectionVisibility2) {
    ConnectionVisibility2[ConnectionVisibility2["None"] = 0] = "None";
    ConnectionVisibility2[ConnectionVisibility2["Everyone"] = 1] = "Everyone";
  })(ConnectionVisibility || (exports.ConnectionVisibility = ConnectionVisibility = {}));
});

// node_modules/discord-api-types/payloads/v10/voice.js
var require_voice = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/webhook.js
var require_webhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebhookType = exports.ApplicationWebhookEventType = exports.ApplicationWebhookType = undefined;
  var ApplicationWebhookType;
  (function(ApplicationWebhookType2) {
    ApplicationWebhookType2[ApplicationWebhookType2["Ping"] = 0] = "Ping";
    ApplicationWebhookType2[ApplicationWebhookType2["Event"] = 1] = "Event";
  })(ApplicationWebhookType || (exports.ApplicationWebhookType = ApplicationWebhookType = {}));
  var ApplicationWebhookEventType;
  (function(ApplicationWebhookEventType2) {
    ApplicationWebhookEventType2["ApplicationAuthorized"] = "APPLICATION_AUTHORIZED";
    ApplicationWebhookEventType2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
    ApplicationWebhookEventType2["QuestUserEnrollment"] = "QUEST_USER_ENROLLMENT";
  })(ApplicationWebhookEventType || (exports.ApplicationWebhookEventType = ApplicationWebhookEventType = {}));
  var WebhookType;
  (function(WebhookType2) {
    WebhookType2[WebhookType2["Incoming"] = 1] = "Incoming";
    WebhookType2[WebhookType2["ChannelFollower"] = 2] = "ChannelFollower";
    WebhookType2[WebhookType2["Application"] = 3] = "Application";
  })(WebhookType || (exports.WebhookType = WebhookType = {}));
});

// node_modules/discord-api-types/payloads/v10/index.js
var require_v102 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_common2(), exports);
  __exportStar(require_application(), exports);
  __exportStar(require_auditLog(), exports);
  __exportStar(require_autoModeration(), exports);
  __exportStar(require_channel(), exports);
  __exportStar(require_emoji(), exports);
  __exportStar(require_gateway(), exports);
  __exportStar(require_guild(), exports);
  __exportStar(require_guildScheduledEvent(), exports);
  __exportStar(require_interactions(), exports);
  __exportStar(require_invite(), exports);
  __exportStar(require_monetization(), exports);
  __exportStar(require_oauth2(), exports);
  __exportStar(require_permissions2(), exports);
  __exportStar(require_poll(), exports);
  __exportStar(require_soundboard(), exports);
  __exportStar(require_stageInstance(), exports);
  __exportStar(require_sticker(), exports);
  __exportStar(require_teams(), exports);
  __exportStar(require_template(), exports);
  __exportStar(require_user2(), exports);
  __exportStar(require_voice(), exports);
  __exportStar(require_webhook(), exports);
});

// node_modules/discord-api-types/utils/internals.js
var require_internals2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.urlSafeCharacters = undefined;
  var pattern = /^[\d%A-Za-z-_]+$/g;
  exports.urlSafeCharacters = {
    test(input) {
      const result = pattern.test(input);
      pattern.lastIndex = 0;
      return result;
    }
  };
});

// node_modules/discord-api-types/rest/common.js
var require_common3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Locale = exports.RESTJSONErrorCodes = undefined;
  var RESTJSONErrorCodes;
  (function(RESTJSONErrorCodes2) {
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GeneralError"] = 0] = "GeneralError";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAccount"] = 10001] = "UnknownAccount";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplication"] = 10002] = "UnknownApplication";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownChannel"] = 10003] = "UnknownChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuild"] = 10004] = "UnknownGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownIntegration"] = 10005] = "UnknownIntegration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInvite"] = 10006] = "UnknownInvite";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMember"] = 10007] = "UnknownMember";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMessage"] = 10008] = "UnknownMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPermissionOverwrite"] = 10009] = "UnknownPermissionOverwrite";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownProvider"] = 10010] = "UnknownProvider";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRole"] = 10011] = "UnknownRole";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownToken"] = 10012] = "UnknownToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownUser"] = 10013] = "UnknownUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEmoji"] = 10014] = "UnknownEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhook"] = 10015] = "UnknownWebhook";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhookService"] = 10016] = "UnknownWebhookService";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSession"] = 10020] = "UnknownSession";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAsset"] = 10021] = "UnknownAsset";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBan"] = 10026] = "UnknownBan";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSKU"] = 10027] = "UnknownSKU";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreListing"] = 10028] = "UnknownStoreListing";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEntitlement"] = 10029] = "UnknownEntitlement";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBuild"] = 10030] = "UnknownBuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownLobby"] = 10031] = "UnknownLobby";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBranch"] = 10032] = "UnknownBranch";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreDirectoryLayout"] = 10033] = "UnknownStoreDirectoryLayout";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRedistributable"] = 10036] = "UnknownRedistributable";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGiftCode"] = 10038] = "UnknownGiftCode";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStream"] = 10049] = "UnknownStream";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPremiumServerSubscribeCooldown"] = 10050] = "UnknownPremiumServerSubscribeCooldown";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildTemplate"] = 10057] = "UnknownGuildTemplate";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownDiscoverableServerCategory"] = 10059] = "UnknownDiscoverableServerCategory";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSticker"] = 10060] = "UnknownSticker";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStickerPack"] = 10061] = "UnknownStickerPack";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInteraction"] = 10062] = "UnknownInteraction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommand"] = 10063] = "UnknownApplicationCommand";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownVoiceState"] = 10065] = "UnknownVoiceState";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommandPermissions"] = 10066] = "UnknownApplicationCommandPermissions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStageInstance"] = 10067] = "UnknownStageInstance";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildMemberVerificationForm"] = 10068] = "UnknownGuildMemberVerificationForm";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildWelcomeScreen"] = 10069] = "UnknownGuildWelcomeScreen";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEvent"] = 10070] = "UnknownGuildScheduledEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEventUser"] = 10071] = "UnknownGuildScheduledEventUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownTag"] = 10087] = "UnknownTag";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSound"] = 10097] = "UnknownSound";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["BotsCannotUseThisEndpoint"] = 20001] = "BotsCannotUseThisEndpoint";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyBotsCanUseThisEndpoint"] = 20002] = "OnlyBotsCanUseThisEndpoint";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ExplicitContentCannotBeSentToTheDesiredRecipient"] = 20009] = "ExplicitContentCannotBeSentToTheDesiredRecipient";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NotAuthorizedToPerformThisActionOnThisApplication"] = 20012] = "NotAuthorizedToPerformThisActionOnThisApplication";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ActionCannotBePerformedDueToSlowmodeRateLimit"] = 20016] = "ActionCannotBePerformedDueToSlowmodeRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheMazeIsntMeantForYou"] = 20017] = "TheMazeIsntMeantForYou";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyTheOwnerOfThisAccountCanPerformThisAction"] = 20018] = "OnlyTheOwnerOfThisAccountCanPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnnouncementEditLimitExceeded"] = 20022] = "AnnouncementEditLimitExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnderMinimumAge"] = 20024] = "UnderMinimumAge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelSendRateLimit"] = 20028] = "ChannelSendRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerSendRateLimit"] = 20029] = "ServerSendRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords"] = 20031] = "StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildPremiumSubscriptionLevelTooLow"] = 20035] = "GuildPremiumSubscriptionLevelTooLow";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildsReached"] = 30001] = "MaximumNumberOfGuildsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfFriendsReached"] = 30002] = "MaximumNumberOfFriendsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinsReachedForTheChannel"] = 30003] = "MaximumNumberOfPinsReachedForTheChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfRecipientsReached"] = 30004] = "MaximumNumberOfRecipientsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildRolesReached"] = 30005] = "MaximumNumberOfGuildRolesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksReached"] = 30007] = "MaximumNumberOfWebhooksReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEmojisReached"] = 30008] = "MaximumNumberOfEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfReactionsReached"] = 30010] = "MaximumNumberOfReactionsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGroupDMsReached"] = 30011] = "MaximumNumberOfGroupDMsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildChannelsReached"] = 30013] = "MaximumNumberOfGuildChannelsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAttachmentsInAMessageReached"] = 30015] = "MaximumNumberOfAttachmentsInAMessageReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfInvitesReached"] = 30016] = "MaximumNumberOfInvitesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAnimatedEmojisReached"] = 30018] = "MaximumNumberOfAnimatedEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerMembersReached"] = 30019] = "MaximumNumberOfServerMembersReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerCategoriesReached"] = 30030] = "MaximumNumberOfServerCategoriesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildAlreadyHasTemplate"] = 30031] = "GuildAlreadyHasTemplate";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfApplicationCommandsReached"] = 30032] = "MaximumNumberOfApplicationCommandsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumThreadParticipantsReached"] = 30033] = "MaximumThreadParticipantsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumDailyApplicationCommandCreatesReached"] = 30034] = "MaximumDailyApplicationCommandCreatesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfNonGuildMemberBansHasBeenExceeded"] = 30035] = "MaximumNumberOfNonGuildMemberBansHasBeenExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfBanFetchesHasBeenReached"] = 30037] = "MaximumNumberOfBanFetchesHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfUncompletedGuildScheduledEventsReached"] = 30038] = "MaximumNumberOfUncompletedGuildScheduledEventsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfStickersReached"] = 30039] = "MaximumNumberOfStickersReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPruneRequestsHasBeenReached"] = 30040] = "MaximumNumberOfPruneRequestsHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached"] = 30042] = "MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfSoundboardSoundsReached"] = 30045] = "MaximumNumberOfSoundboardSoundsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEditsToMessagesOlderThanOneHourReached"] = 30046] = "MaximumNumberOfEditsToMessagesOlderThanOneHourReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinnedThreadsInForumHasBeenReached"] = 30047] = "MaximumNumberOfPinnedThreadsInForumHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfTagsInForumHasBeenReached"] = 30048] = "MaximumNumberOfTagsInForumHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["BitrateIsTooHighForChannelOfThisType"] = 30052] = "BitrateIsTooHighForChannelOfThisType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPremiumEmojisReached"] = 30056] = "MaximumNumberOfPremiumEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksPerGuildReached"] = 30058] = "MaximumNumberOfWebhooksPerGuildReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfChannelPermissionOverwritesReached"] = 30060] = "MaximumNumberOfChannelPermissionOverwritesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheChannelsForThisGuildAreTooLarge"] = 30061] = "TheChannelsForThisGuildAreTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["Unauthorized"] = 40001] = "Unauthorized";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VerifyYourAccount"] = 40002] = "VerifyYourAccount";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OpeningDirectMessagesTooFast"] = 40003] = "OpeningDirectMessagesTooFast";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["SendMessagesHasBeenTemporarilyDisabled"] = 40004] = "SendMessagesHasBeenTemporarilyDisabled";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestEntityTooLarge"] = 40005] = "RequestEntityTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FeatureTemporarilyDisabledServerSide"] = 40006] = "FeatureTemporarilyDisabledServerSide";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserBannedFromThisGuild"] = 40007] = "UserBannedFromThisGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ConnectionHasBeenRevoked"] = 40012] = "ConnectionHasBeenRevoked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyConsumableSKUsCanBeConsumed"] = 40018] = "OnlyConsumableSKUsCanBeConsumed";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCanOnlyDeleteSandboxEntitlements"] = 40019] = "YouCanOnlyDeleteSandboxEntitlements";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TargetUserIsNotConnectedToVoice"] = 40032] = "TargetUserIsNotConnectedToVoice";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisMessageWasAlreadyCrossposted"] = 40033] = "ThisMessageWasAlreadyCrossposted";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationCommandWithThatNameAlreadyExists"] = 40041] = "ApplicationCommandWithThatNameAlreadyExists";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationInteractionFailedToSend"] = 40043] = "ApplicationInteractionFailedToSend";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAMessageInAForumChannel"] = 40058] = "CannotSendAMessageInAForumChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InteractionHasAlreadyBeenAcknowledged"] = 40060] = "InteractionHasAlreadyBeenAcknowledged";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagNamesMustBeUnique"] = 40061] = "TagNamesMustBeUnique";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServiceResourceIsBeingRateLimited"] = 40062] = "ServiceResourceIsBeingRateLimited";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThereAreNoTagsAvailableThatCanBeSetByNonModerators"] = 40066] = "ThereAreNoTagsAvailableThatCanBeSetByNonModerators";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagRequiredToCreateAForumPostInThisChannel"] = 40067] = "TagRequiredToCreateAForumPostInThisChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnEntitlementHasAlreadyBeenGrantedForThisResource"] = 40074] = "AnEntitlementHasAlreadyBeenGrantedForThisResource";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisInteractionHasHitTheMaximumNumberOfFollowUpMessages"] = 40094] = "ThisInteractionHasHitTheMaximumNumberOfFollowUpMessages";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CloudflareIsBlockingYourRequest"] = 40333] = "CloudflareIsBlockingYourRequest";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingAccess"] = 50001] = "MissingAccess";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAccountType"] = 50002] = "InvalidAccountType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnDMChannel"] = 50003] = "CannotExecuteActionOnDMChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildWidgetDisabled"] = 50004] = "GuildWidgetDisabled";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditMessageAuthoredByAnotherUser"] = 50005] = "CannotEditMessageAuthoredByAnotherUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAnEmptyMessage"] = 50006] = "CannotSendAnEmptyMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesToThisUser"] = 50007] = "CannotSendMessagesToThisUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesInNonTextChannel"] = 50008] = "CannotSendMessagesInNonTextChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelVerificationLevelTooHighForYouToGainAccess"] = 50009] = "ChannelVerificationLevelTooHighForYouToGainAccess";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationDoesNotHaveBot"] = 50010] = "OAuth2ApplicationDoesNotHaveBot";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationLimitReached"] = 50011] = "OAuth2ApplicationLimitReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2State"] = 50012] = "InvalidOAuth2State";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingPermissions"] = 50013] = "MissingPermissions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidToken"] = 50014] = "InvalidToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoteWasTooLong"] = 50015] = "NoteWasTooLong";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedTooFewOrTooManyMessagesToDelete"] = 50016] = "ProvidedTooFewOrTooManyMessagesToDelete";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMFALevel"] = 50017] = "InvalidMFALevel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageCanOnlyBePinnedInTheChannelItWasSentIn"] = 50019] = "MessageCanOnlyBePinnedInTheChannelItWasSentIn";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteCodeInvalidOrTaken"] = 50020] = "InviteCodeInvalidOrTaken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnSystemMessage"] = 50021] = "CannotExecuteActionOnSystemMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnThisChannelType"] = 50024] = "CannotExecuteActionOnThisChannelType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2AccessToken"] = 50025] = "InvalidOAuth2AccessToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingRequiredOAuth2Scope"] = 50026] = "MissingRequiredOAuth2Scope";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidWebhookToken"] = 50027] = "InvalidWebhookToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRole"] = 50028] = "InvalidRole";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRecipients"] = 50033] = "InvalidRecipients";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OneOfTheMessagesProvidedWasTooOldForBulkDelete"] = 50034] = "OneOfTheMessagesProvidedWasTooOldForBulkDelete";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFormBodyOrContentType"] = 50035] = "InvalidFormBodyOrContentType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteAcceptedToGuildWithoutTheBotBeingIn"] = 50036] = "InviteAcceptedToGuildWithoutTheBotBeingIn";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActivityAction"] = 50039] = "InvalidActivityAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAPIVersion"] = 50041] = "InvalidAPIVersion";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FileUploadedExceedsMaximumSize"] = 50045] = "FileUploadedExceedsMaximumSize";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFileUploaded"] = 50046] = "InvalidFileUploaded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSelfRedeemThisGift"] = 50054] = "CannotSelfRedeemThisGift";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidGuild"] = 50055] = "InvalidGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidSKU"] = 50057] = "InvalidSKU";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRequestOrigin"] = 50067] = "InvalidRequestOrigin";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMessageType"] = 50068] = "InvalidMessageType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PaymentSourceRequiredToRedeemGift"] = 50070] = "PaymentSourceRequiredToRedeemGift";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotModifyASystemWebhook"] = 50073] = "CannotModifyASystemWebhook";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteChannelRequiredForCommunityGuilds"] = 50074] = "CannotDeleteChannelRequiredForCommunityGuilds";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditStickersWithinMessage"] = 50080] = "CannotEditStickersWithinMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidStickerSent"] = 50081] = "InvalidStickerSent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActionOnArchivedThread"] = 50083] = "InvalidActionOnArchivedThread";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidThreadNotificationSettings"] = 50084] = "InvalidThreadNotificationSettings";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ParameterEarlierThanCreation"] = 50085] = "ParameterEarlierThanCreation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CommunityServerChannelsMustBeTextChannels"] = 50086] = "CommunityServerChannelsMustBeTextChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor"] = 50091] = "TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNotAvailableInYourLocation"] = 50095] = "ServerNotAvailableInYourLocation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMonetizationEnabledToPerformThisAction"] = 50097] = "ServerNeedsMonetizationEnabledToPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMoreBoostsToPerformThisAction"] = 50101] = "ServerNeedsMoreBoostsToPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestBodyContainsInvalidJSON"] = 50109] = "RequestBodyContainsInvalidJSON";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileIsInvalid"] = 50110] = "ProvidedFileIsInvalid";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileTypeIsInvalid"] = 50123] = "ProvidedFileTypeIsInvalid";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileDurationExceedsMaximumLength"] = 50124] = "ProvidedFileDurationExceedsMaximumLength";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnerCannotBePendingMember"] = 50131] = "OwnerCannotBePendingMember";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnershipCannotBeMovedToABotUser"] = 50132] = "OwnershipCannotBeMovedToABotUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToResizeAssetBelowTheMinimumSize"] = 50138] = "FailedToResizeAssetBelowTheMinimumSize";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji"] = 50144] = "CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotConvertBetweenPremiumEmojiAndNormalEmoji"] = 50145] = "CannotConvertBetweenPremiumEmojiAndNormalEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedFileNotFound"] = 50146] = "UploadedFileNotFound";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["SpecifiedEmojiIsInvalid"] = 50151] = "SpecifiedEmojiIsInvalid";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesDoNotSupportAdditionalContent"] = 50159] = "VoiceMessagesDoNotSupportAdditionalContent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveASingleAudioAttachment"] = 50160] = "VoiceMessagesMustHaveASingleAudioAttachment";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveSupportingMetadata"] = 50161] = "VoiceMessagesMustHaveSupportingMetadata";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesCannotBeEdited"] = 50162] = "VoiceMessagesCannotBeEdited";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteGuildSubscriptionIntegration"] = 50163] = "CannotDeleteGuildSubscriptionIntegration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCannotSendVoiceMessagesInThisChannel"] = 50173] = "YouCannotSendVoiceMessagesInThisChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheUserAccountMustFirstBeVerified"] = 50178] = "TheUserAccountMustFirstBeVerified";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileDoesNotHaveAValidDuration"] = 50192] = "ProvidedFileDoesNotHaveAValidDuration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouDoNotHavePermissionToSendThisSticker"] = 50600] = "YouDoNotHavePermissionToSendThisSticker";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TwoFactorAuthenticationIsRequired"] = 60003] = "TwoFactorAuthenticationIsRequired";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoUsersWithDiscordTagExist"] = 80004] = "NoUsersWithDiscordTagExist";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ReactionWasBlocked"] = 90001] = "ReactionWasBlocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserCannotUseBurstReactions"] = 90002] = "UserCannotUseBurstReactions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationNotYetAvailable"] = 110001] = "ApplicationNotYetAvailable";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["APIResourceOverloaded"] = 130000] = "APIResourceOverloaded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheStageIsAlreadyOpen"] = 150006] = "TheStageIsAlreadyOpen";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotReplyWithoutPermissionToReadMessageHistory"] = 160002] = "CannotReplyWithoutPermissionToReadMessageHistory";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadAlreadyCreatedForMessage"] = 160004] = "ThreadAlreadyCreatedForMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadLocked"] = 160005] = "ThreadLocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveThreads"] = 160006] = "MaximumActiveThreads";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveAnnouncementThreads"] = 160007] = "MaximumActiveAnnouncementThreads";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidJSONForUploadedLottieFile"] = 170001] = "InvalidJSONForUploadedLottieFile";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedLottiesCannotContainRasterizedImages"] = 170002] = "UploadedLottiesCannotContainRasterizedImages";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerMaximumFramerateExceeded"] = 170003] = "StickerMaximumFramerateExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFrameCountExceedsMaximumOf1000Frames"] = 170004] = "StickerFrameCountExceedsMaximumOf1000Frames";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["LottieAnimationMaximumDimensionsExceeded"] = 170005] = "LottieAnimationMaximumDimensionsExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFramerateIsTooSmallOrTooLarge"] = 170006] = "StickerFramerateIsTooSmallOrTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerAnimationDurationExceedsMaximumOf5Seconds"] = 170007] = "StickerAnimationDurationExceedsMaximumOf5Seconds";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateAFinishedEvent"] = 180000] = "CannotUpdateAFinishedEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToCreateStageNeededForStageEvent"] = 180002] = "FailedToCreateStageNeededForStageEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageWasBlockedByAutomaticModeration"] = 200000] = "MessageWasBlockedByAutomaticModeration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TitleWasBlockedByAutomaticModeration"] = 200001] = "TitleWasBlockedByAutomaticModeration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId"] = 220001] = "WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId"] = 220002] = "WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksCanOnlyCreateThreadsInForumChannels"] = 220003] = "WebhooksCanOnlyCreateThreadsInForumChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhookServicesCannotBeUsedInForumChannels"] = 220004] = "WebhookServicesCannotBeUsedInForumChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageBlockedByHarmfulLinksFilter"] = 240000] = "MessageBlockedByHarmfulLinksFilter";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEnableOnboardingRequirementsAreNotMet"] = 350000] = "CannotEnableOnboardingRequirementsAreNotMet";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateOnboardingWhileBelowRequirements"] = 350001] = "CannotUpdateOnboardingWhileBelowRequirements";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToBanUsers"] = 500000] = "FailedToBanUsers";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PollVotingBlocked"] = 520000] = "PollVotingBlocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PollExpired"] = 520001] = "PollExpired";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidChannelTypeForPollCreation"] = 520002] = "InvalidChannelTypeForPollCreation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditAPollMessage"] = 520003] = "CannotEditAPollMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUseAnEmojiIncludedWithThePoll"] = 520004] = "CannotUseAnEmojiIncludedWithThePoll";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExpireANonPollMessage"] = 520006] = "CannotExpireANonPollMessage";
  })(RESTJSONErrorCodes || (exports.RESTJSONErrorCodes = RESTJSONErrorCodes = {}));
  var Locale;
  (function(Locale2) {
    Locale2["Indonesian"] = "id";
    Locale2["EnglishUS"] = "en-US";
    Locale2["EnglishGB"] = "en-GB";
    Locale2["Bulgarian"] = "bg";
    Locale2["ChineseCN"] = "zh-CN";
    Locale2["ChineseTW"] = "zh-TW";
    Locale2["Croatian"] = "hr";
    Locale2["Czech"] = "cs";
    Locale2["Danish"] = "da";
    Locale2["Dutch"] = "nl";
    Locale2["Finnish"] = "fi";
    Locale2["French"] = "fr";
    Locale2["German"] = "de";
    Locale2["Greek"] = "el";
    Locale2["Hindi"] = "hi";
    Locale2["Hungarian"] = "hu";
    Locale2["Italian"] = "it";
    Locale2["Japanese"] = "ja";
    Locale2["Korean"] = "ko";
    Locale2["Lithuanian"] = "lt";
    Locale2["Norwegian"] = "no";
    Locale2["Polish"] = "pl";
    Locale2["PortugueseBR"] = "pt-BR";
    Locale2["Romanian"] = "ro";
    Locale2["Russian"] = "ru";
    Locale2["SpanishES"] = "es-ES";
    Locale2["SpanishLATAM"] = "es-419";
    Locale2["Swedish"] = "sv-SE";
    Locale2["Thai"] = "th";
    Locale2["Turkish"] = "tr";
    Locale2["Ukrainian"] = "uk";
    Locale2["Vietnamese"] = "vi";
  })(Locale || (exports.Locale = Locale = {}));
});

// node_modules/discord-api-types/rest/v10/application.js
var require_application2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/auditLog.js
var require_auditLog2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/autoModeration.js
var require_autoModeration2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/channel.js
var require_channel3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReactionType = undefined;
  var ReactionType;
  (function(ReactionType2) {
    ReactionType2[ReactionType2["Normal"] = 0] = "Normal";
    ReactionType2[ReactionType2["Super"] = 1] = "Super";
  })(ReactionType || (exports.ReactionType = ReactionType = {}));
});

// node_modules/discord-api-types/rest/v10/emoji.js
var require_emoji2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/gateway.js
var require_gateway2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/guild.js
var require_guild2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/guildScheduledEvent.js
var require_guildScheduledEvent2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/interactions.js
var require_interactions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/invite.js
var require_invite2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/monetization.js
var require_monetization2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntitlementOwnerType = undefined;
  var EntitlementOwnerType;
  (function(EntitlementOwnerType2) {
    EntitlementOwnerType2[EntitlementOwnerType2["Guild"] = 1] = "Guild";
    EntitlementOwnerType2[EntitlementOwnerType2["User"] = 2] = "User";
  })(EntitlementOwnerType || (exports.EntitlementOwnerType = EntitlementOwnerType = {}));
});

// node_modules/discord-api-types/rest/v10/oauth2.js
var require_oauth22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/poll.js
var require_poll2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/soundboard.js
var require_soundboard2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/stageInstance.js
var require_stageInstance2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/sticker.js
var require_sticker2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/template.js
var require_template2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/user.js
var require_user3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/voice.js
var require_voice2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/webhook.js
var require_webhook2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/index.js
var require_v103 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Routes = exports.RouteBases = exports.CDNRoutes = exports.ImageFormat = exports.StickerPackApplicationId = exports.Routes = exports.APIVersion = undefined;
  var internals_1 = require_internals2();
  __exportStar(require_common3(), exports);
  __exportStar(require_application2(), exports);
  __exportStar(require_auditLog2(), exports);
  __exportStar(require_autoModeration2(), exports);
  __exportStar(require_channel3(), exports);
  __exportStar(require_emoji2(), exports);
  __exportStar(require_gateway2(), exports);
  __exportStar(require_guild2(), exports);
  __exportStar(require_guildScheduledEvent2(), exports);
  __exportStar(require_interactions2(), exports);
  __exportStar(require_invite2(), exports);
  __exportStar(require_monetization2(), exports);
  __exportStar(require_oauth22(), exports);
  __exportStar(require_poll2(), exports);
  __exportStar(require_soundboard2(), exports);
  __exportStar(require_stageInstance2(), exports);
  __exportStar(require_sticker2(), exports);
  __exportStar(require_template2(), exports);
  __exportStar(require_user3(), exports);
  __exportStar(require_voice2(), exports);
  __exportStar(require_webhook2(), exports);
  exports.APIVersion = "10";
  exports.Routes = {
    applicationRoleConnectionMetadata(applicationId) {
      return `/applications/${applicationId}/role-connections/metadata`;
    },
    guildAutoModerationRules(guildId) {
      return `/guilds/${guildId}/auto-moderation/rules`;
    },
    guildAutoModerationRule(guildId, ruleId) {
      return `/guilds/${guildId}/auto-moderation/rules/${ruleId}`;
    },
    guildAuditLog(guildId) {
      return `/guilds/${guildId}/audit-logs`;
    },
    channel(channelId) {
      return `/channels/${channelId}`;
    },
    channelMessages(channelId) {
      return `/channels/${channelId}/messages`;
    },
    channelMessage(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}`;
    },
    channelMessageCrosspost(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}/crosspost`;
    },
    channelMessageOwnReaction(channelId, messageId, emoji) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/@me`;
    },
    channelMessageUserReaction(channelId, messageId, emoji, userId) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/${userId}`;
    },
    channelMessageReaction(channelId, messageId, emoji) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}`;
    },
    channelMessageAllReactions(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}/reactions`;
    },
    channelBulkDelete(channelId) {
      return `/channels/${channelId}/messages/bulk-delete`;
    },
    channelPermission(channelId, overwriteId) {
      return `/channels/${channelId}/permissions/${overwriteId}`;
    },
    channelInvites(channelId) {
      return `/channels/${channelId}/invites`;
    },
    channelFollowers(channelId) {
      return `/channels/${channelId}/followers`;
    },
    channelTyping(channelId) {
      return `/channels/${channelId}/typing`;
    },
    channelPins(channelId) {
      return `/channels/${channelId}/pins`;
    },
    channelPin(channelId, messageId) {
      return `/channels/${channelId}/pins/${messageId}`;
    },
    channelRecipient(channelId, userId) {
      return `/channels/${channelId}/recipients/${userId}`;
    },
    guildEmojis(guildId) {
      return `/guilds/${guildId}/emojis`;
    },
    guildEmoji(guildId, emojiId) {
      return `/guilds/${guildId}/emojis/${emojiId}`;
    },
    guilds() {
      return "/guilds";
    },
    guild(guildId) {
      return `/guilds/${guildId}`;
    },
    guildPreview(guildId) {
      return `/guilds/${guildId}/preview`;
    },
    guildChannels(guildId) {
      return `/guilds/${guildId}/channels`;
    },
    guildMember(guildId, userId = "@me") {
      return `/guilds/${guildId}/members/${userId}`;
    },
    guildMembers(guildId) {
      return `/guilds/${guildId}/members`;
    },
    guildMembersSearch(guildId) {
      return `/guilds/${guildId}/members/search`;
    },
    guildCurrentMemberNickname(guildId) {
      return `/guilds/${guildId}/members/@me/nick`;
    },
    guildMemberRole(guildId, memberId, roleId) {
      return `/guilds/${guildId}/members/${memberId}/roles/${roleId}`;
    },
    guildMFA(guildId) {
      return `/guilds/${guildId}/mfa`;
    },
    guildBans(guildId) {
      return `/guilds/${guildId}/bans`;
    },
    guildBan(guildId, userId) {
      return `/guilds/${guildId}/bans/${userId}`;
    },
    guildRoles(guildId) {
      return `/guilds/${guildId}/roles`;
    },
    guildRole(guildId, roleId) {
      return `/guilds/${guildId}/roles/${roleId}`;
    },
    guildPrune(guildId) {
      return `/guilds/${guildId}/prune`;
    },
    guildVoiceRegions(guildId) {
      return `/guilds/${guildId}/regions`;
    },
    guildInvites(guildId) {
      return `/guilds/${guildId}/invites`;
    },
    guildIntegrations(guildId) {
      return `/guilds/${guildId}/integrations`;
    },
    guildIntegration(guildId, integrationId) {
      return `/guilds/${guildId}/integrations/${integrationId}`;
    },
    guildWidgetSettings(guildId) {
      return `/guilds/${guildId}/widget`;
    },
    guildWidgetJSON(guildId) {
      return `/guilds/${guildId}/widget.json`;
    },
    guildVanityUrl(guildId) {
      return `/guilds/${guildId}/vanity-url`;
    },
    guildWidgetImage(guildId) {
      return `/guilds/${guildId}/widget.png`;
    },
    invite(code) {
      return `/invites/${code}`;
    },
    template(code) {
      return `/guilds/templates/${code}`;
    },
    guildTemplates(guildId) {
      return `/guilds/${guildId}/templates`;
    },
    guildTemplate(guildId, code) {
      return `/guilds/${guildId}/templates/${code}`;
    },
    pollAnswerVoters(channelId, messageId, answerId) {
      return `/channels/${channelId}/polls/${messageId}/answers/${answerId}`;
    },
    expirePoll(channelId, messageId) {
      return `/channels/${channelId}/polls/${messageId}/expire`;
    },
    threads(parentId, messageId) {
      const parts = ["", "channels", parentId];
      if (messageId)
        parts.push("messages", messageId);
      parts.push("threads");
      return parts.join("/");
    },
    guildActiveThreads(guildId) {
      return `/guilds/${guildId}/threads/active`;
    },
    channelThreads(channelId, archivedStatus) {
      return `/channels/${channelId}/threads/archived/${archivedStatus}`;
    },
    channelJoinedArchivedThreads(channelId) {
      return `/channels/${channelId}/users/@me/threads/archived/private`;
    },
    threadMembers(threadId, userId) {
      const parts = ["", "channels", threadId, "thread-members"];
      if (userId)
        parts.push(userId);
      return parts.join("/");
    },
    user(userId = "@me") {
      return `/users/${userId}`;
    },
    userApplicationRoleConnection(applicationId) {
      return `/users/@me/applications/${applicationId}/role-connection`;
    },
    userGuilds() {
      return `/users/@me/guilds`;
    },
    userGuildMember(guildId) {
      return `/users/@me/guilds/${guildId}/member`;
    },
    userGuild(guildId) {
      return `/users/@me/guilds/${guildId}`;
    },
    userChannels() {
      return `/users/@me/channels`;
    },
    userConnections() {
      return `/users/@me/connections`;
    },
    voiceRegions() {
      return `/voice/regions`;
    },
    channelWebhooks(channelId) {
      return `/channels/${channelId}/webhooks`;
    },
    guildWebhooks(guildId) {
      return `/guilds/${guildId}/webhooks`;
    },
    webhook(webhookId, webhookToken) {
      const parts = ["", "webhooks", webhookId];
      if (webhookToken)
        parts.push(webhookToken);
      return parts.join("/");
    },
    webhookMessage(webhookId, webhookToken, messageId = "@original") {
      return `/webhooks/${webhookId}/${webhookToken}/messages/${messageId}`;
    },
    webhookPlatform(webhookId, webhookToken, platform) {
      return `/webhooks/${webhookId}/${webhookToken}/${platform}`;
    },
    gateway() {
      return `/gateway`;
    },
    gatewayBot() {
      return `/gateway/bot`;
    },
    oauth2CurrentApplication() {
      return `/oauth2/applications/@me`;
    },
    oauth2CurrentAuthorization() {
      return `/oauth2/@me`;
    },
    oauth2Authorization() {
      return `/oauth2/authorize`;
    },
    oauth2TokenExchange() {
      return `/oauth2/token`;
    },
    oauth2TokenRevocation() {
      return `/oauth2/token/revoke`;
    },
    applicationCommands(applicationId) {
      return `/applications/${applicationId}/commands`;
    },
    applicationCommand(applicationId, commandId) {
      return `/applications/${applicationId}/commands/${commandId}`;
    },
    applicationGuildCommands(applicationId, guildId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands`;
    },
    applicationGuildCommand(applicationId, guildId, commandId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}`;
    },
    interactionCallback(interactionId, interactionToken) {
      return `/interactions/${interactionId}/${interactionToken}/callback`;
    },
    guildMemberVerification(guildId) {
      return `/guilds/${guildId}/member-verification`;
    },
    guildVoiceState(guildId, userId = "@me") {
      return `/guilds/${guildId}/voice-states/${userId}`;
    },
    guildApplicationCommandsPermissions(applicationId, guildId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/permissions`;
    },
    applicationCommandPermissions(applicationId, guildId, commandId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}/permissions`;
    },
    guildWelcomeScreen(guildId) {
      return `/guilds/${guildId}/welcome-screen`;
    },
    stageInstances() {
      return `/stage-instances`;
    },
    stageInstance(channelId) {
      return `/stage-instances/${channelId}`;
    },
    sticker(stickerId) {
      return `/stickers/${stickerId}`;
    },
    stickerPacks() {
      return "/sticker-packs";
    },
    stickerPack(packId) {
      return `/sticker-packs/${packId}`;
    },
    nitroStickerPacks() {
      return "/sticker-packs";
    },
    guildStickers(guildId) {
      return `/guilds/${guildId}/stickers`;
    },
    guildSticker(guildId, stickerId) {
      return `/guilds/${guildId}/stickers/${stickerId}`;
    },
    guildScheduledEvents(guildId) {
      return `/guilds/${guildId}/scheduled-events`;
    },
    guildScheduledEvent(guildId, guildScheduledEventId) {
      return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}`;
    },
    guildScheduledEventUsers(guildId, guildScheduledEventId) {
      return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}/users`;
    },
    guildOnboarding(guildId) {
      return `/guilds/${guildId}/onboarding`;
    },
    guildIncidentActions(guildId) {
      return `/guilds/${guildId}/incident-actions`;
    },
    currentApplication() {
      return "/applications/@me";
    },
    entitlements(applicationId) {
      return `/applications/${applicationId}/entitlements`;
    },
    entitlement(applicationId, entitlementId) {
      return `/applications/${applicationId}/entitlements/${entitlementId}`;
    },
    skus(applicationId) {
      return `/applications/${applicationId}/skus`;
    },
    guildBulkBan(guildId) {
      return `/guilds/${guildId}/bulk-ban`;
    },
    consumeEntitlement(applicationId, entitlementId) {
      return `/applications/${applicationId}/entitlements/${entitlementId}/consume`;
    },
    applicationEmojis(applicationId) {
      return `/applications/${applicationId}/emojis`;
    },
    applicationEmoji(applicationId, emojiId) {
      return `/applications/${applicationId}/emojis/${emojiId}`;
    },
    skuSubscriptions(skuId) {
      return `/skus/${skuId}/subscriptions`;
    },
    skuSubscription(skuId, subscriptionId) {
      return `/skus/${skuId}/subscriptions/${subscriptionId}`;
    },
    sendSoundboardSound(channelId) {
      return `/channels/${channelId}/send-soundboard-sound`;
    },
    soundboardDefaultSounds() {
      return "/soundboard-default-sounds";
    },
    guildSoundboardSounds(guildId) {
      return `/guilds/${guildId}/soundboard-sounds`;
    },
    guildSoundboardSound(guildId, soundId) {
      return `/guilds/${guildId}/soundboard-sounds/${soundId}`;
    }
  };
  for (const [key, fn] of Object.entries(exports.Routes)) {
    exports.Routes[key] = (...args) => {
      const escaped = args.map((arg) => {
        if (arg) {
          if (internals_1.urlSafeCharacters.test(String(arg))) {
            return arg;
          }
          return encodeURIComponent(arg);
        }
        return arg;
      });
      return fn.call(null, ...escaped);
    };
  }
  Object.freeze(exports.Routes);
  exports.StickerPackApplicationId = "710982414301790216";
  var ImageFormat;
  (function(ImageFormat2) {
    ImageFormat2["JPEG"] = "jpeg";
    ImageFormat2["PNG"] = "png";
    ImageFormat2["WebP"] = "webp";
    ImageFormat2["GIF"] = "gif";
    ImageFormat2["Lottie"] = "json";
  })(ImageFormat || (exports.ImageFormat = ImageFormat = {}));
  exports.CDNRoutes = {
    emoji(emojiId, format) {
      return `/emojis/${emojiId}.${format}`;
    },
    guildIcon(guildId, guildIcon, format) {
      return `/icons/${guildId}/${guildIcon}.${format}`;
    },
    guildSplash(guildId, guildSplash, format) {
      return `/splashes/${guildId}/${guildSplash}.${format}`;
    },
    guildDiscoverySplash(guildId, guildDiscoverySplash, format) {
      return `/discovery-splashes/${guildId}/${guildDiscoverySplash}.${format}`;
    },
    guildBanner(guildId, guildBanner, format) {
      return `/banners/${guildId}/${guildBanner}.${format}`;
    },
    userBanner(userId, userBanner, format) {
      return `/banners/${userId}/${userBanner}.${format}`;
    },
    defaultUserAvatar(index) {
      return `/embed/avatars/${index}.png`;
    },
    userAvatar(userId, userAvatar, format) {
      return `/avatars/${userId}/${userAvatar}.${format}`;
    },
    guildMemberAvatar(guildId, userId, memberAvatar, format) {
      return `/guilds/${guildId}/users/${userId}/avatars/${memberAvatar}.${format}`;
    },
    userAvatarDecoration(userId, userAvatarDecoration) {
      return `/avatar-decorations/${userId}/${userAvatarDecoration}.png`;
    },
    avatarDecoration(avatarDecorationDataAsset) {
      return `/avatar-decoration-presets/${avatarDecorationDataAsset}.png`;
    },
    applicationIcon(applicationId, applicationIcon, format) {
      return `/app-icons/${applicationId}/${applicationIcon}.${format}`;
    },
    applicationCover(applicationId, applicationCoverImage, format) {
      return `/app-icons/${applicationId}/${applicationCoverImage}.${format}`;
    },
    applicationAsset(applicationId, applicationAssetId, format) {
      return `/app-assets/${applicationId}/${applicationAssetId}.${format}`;
    },
    achievementIcon(applicationId, achievementId, achievementIconHash, format) {
      return `/app-assets/${applicationId}/achievements/${achievementId}/icons/${achievementIconHash}.${format}`;
    },
    stickerPackBanner(stickerPackBannerAssetId, format) {
      return `/app-assets/${exports.StickerPackApplicationId}/store/${stickerPackBannerAssetId}.${format}`;
    },
    storePageAsset(applicationId, assetId, format = ImageFormat.PNG) {
      return `/app-assets/${applicationId}/store/${assetId}.${format}`;
    },
    teamIcon(teamId, teamIcon, format) {
      return `/team-icons/${teamId}/${teamIcon}.${format}`;
    },
    sticker(stickerId, format) {
      return `/stickers/${stickerId}.${format}`;
    },
    roleIcon(roleId, roleIcon, format) {
      return `/role-icons/${roleId}/${roleIcon}.${format}`;
    },
    guildScheduledEventCover(guildScheduledEventId, guildScheduledEventCoverImage, format) {
      return `/guild-events/${guildScheduledEventId}/${guildScheduledEventCoverImage}.${format}`;
    },
    guildMemberBanner(guildId, userId, guildMemberBanner, format) {
      return `/guilds/${guildId}/users/${userId}/banners/${guildMemberBanner}.${format}`;
    },
    soundboardSound(soundId) {
      return `/soundboard-sounds/${soundId}`;
    }
  };
  for (const [key, fn] of Object.entries(exports.CDNRoutes)) {
    exports.CDNRoutes[key] = (...args) => {
      const escaped = args.map((arg) => {
        if (arg) {
          if (internals_1.urlSafeCharacters.test(String(arg))) {
            return arg;
          }
          return encodeURIComponent(arg);
        }
        return arg;
      });
      return fn.call(null, ...escaped);
    };
  }
  Object.freeze(exports.CDNRoutes);
  exports.RouteBases = {
    api: `https://discord.com/api/v${exports.APIVersion}`,
    cdn: "https://cdn.discordapp.com",
    media: "https://media.discordapp.net",
    invite: "https://discord.gg",
    template: "https://discord.new",
    gift: "https://discord.gift",
    scheduledEvent: "https://discord.com/events"
  };
  Object.freeze(exports.RouteBases);
  exports.OAuth2Routes = {
    authorizationURL: `${exports.RouteBases.api}${exports.Routes.oauth2Authorization()}`,
    tokenURL: `${exports.RouteBases.api}${exports.Routes.oauth2TokenExchange()}`,
    tokenRevocationURL: `${exports.RouteBases.api}${exports.Routes.oauth2TokenRevocation()}`
  };
  Object.freeze(exports.OAuth2Routes);
});

// node_modules/discord-api-types/rpc/common.js
var require_common4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RPCCloseEventCodes = exports.RPCErrorCodes = exports.RelationshipType = exports.VoiceConnectionStates = exports.RPCVoiceShortcutKeyComboKeyType = exports.RPCVoiceSettingsModeType = exports.RPCDeviceType = undefined;
  var RPCDeviceType;
  (function(RPCDeviceType2) {
    RPCDeviceType2["AudioInput"] = "audioinput";
    RPCDeviceType2["AudioOutput"] = "audiooutput";
    RPCDeviceType2["VideoInput"] = "videoinput";
  })(RPCDeviceType || (exports.RPCDeviceType = RPCDeviceType = {}));
  var RPCVoiceSettingsModeType;
  (function(RPCVoiceSettingsModeType2) {
    RPCVoiceSettingsModeType2["PushToTalk"] = "PUSH_TO_TALK";
    RPCVoiceSettingsModeType2["VoiceActivity"] = "VOICE_ACTIVITY";
  })(RPCVoiceSettingsModeType || (exports.RPCVoiceSettingsModeType = RPCVoiceSettingsModeType = {}));
  var RPCVoiceShortcutKeyComboKeyType;
  (function(RPCVoiceShortcutKeyComboKeyType2) {
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["KeyboardKey"] = 0] = "KeyboardKey";
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["MouseButton"] = 1] = "MouseButton";
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["KeyboardModifierKey"] = 2] = "KeyboardModifierKey";
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["GamepadButton"] = 3] = "GamepadButton";
  })(RPCVoiceShortcutKeyComboKeyType || (exports.RPCVoiceShortcutKeyComboKeyType = RPCVoiceShortcutKeyComboKeyType = {}));
  var VoiceConnectionStates;
  (function(VoiceConnectionStates2) {
    VoiceConnectionStates2["Disconnected"] = "DISCONNECTED";
    VoiceConnectionStates2["AwaitingEndpoint"] = "AWAITING_ENDPOINT";
    VoiceConnectionStates2["Authenticating"] = "AUTHENTICATING";
    VoiceConnectionStates2["Connecting"] = "CONNECTING";
    VoiceConnectionStates2["Connected"] = "CONNECTED";
    VoiceConnectionStates2["VoiceDisconnected"] = "VOICE_DISCONNECTED";
    VoiceConnectionStates2["VoiceConnecting"] = "VOICE_CONNECTING";
    VoiceConnectionStates2["VoiceConnected"] = "VOICE_CONNECTED";
    VoiceConnectionStates2["NoRoute"] = "NO_ROUTE";
    VoiceConnectionStates2["IceChecking"] = "ICE_CHECKING";
  })(VoiceConnectionStates || (exports.VoiceConnectionStates = VoiceConnectionStates = {}));
  var RelationshipType;
  (function(RelationshipType2) {
    RelationshipType2[RelationshipType2["None"] = 0] = "None";
    RelationshipType2[RelationshipType2["Friend"] = 1] = "Friend";
    RelationshipType2[RelationshipType2["Blocked"] = 2] = "Blocked";
    RelationshipType2[RelationshipType2["PendingIncoming"] = 3] = "PendingIncoming";
    RelationshipType2[RelationshipType2["PendingOutgoing"] = 4] = "PendingOutgoing";
    RelationshipType2[RelationshipType2["Implicit"] = 5] = "Implicit";
  })(RelationshipType || (exports.RelationshipType = RelationshipType = {}));
  var RPCErrorCodes;
  (function(RPCErrorCodes2) {
    RPCErrorCodes2[RPCErrorCodes2["UnknownError"] = 1000] = "UnknownError";
    RPCErrorCodes2[RPCErrorCodes2["ServiceUnavailable"] = 1001] = "ServiceUnavailable";
    RPCErrorCodes2[RPCErrorCodes2["TransactionAborted"] = 1002] = "TransactionAborted";
    RPCErrorCodes2[RPCErrorCodes2["InvalidPayload"] = 4000] = "InvalidPayload";
    RPCErrorCodes2[RPCErrorCodes2["InvalidCommand"] = 4002] = "InvalidCommand";
    RPCErrorCodes2[RPCErrorCodes2["InvalidGuild"] = 4003] = "InvalidGuild";
    RPCErrorCodes2[RPCErrorCodes2["InvalidEvent"] = 4004] = "InvalidEvent";
    RPCErrorCodes2[RPCErrorCodes2["InvalidChannel"] = 4005] = "InvalidChannel";
    RPCErrorCodes2[RPCErrorCodes2["InvalidPermissions"] = 4006] = "InvalidPermissions";
    RPCErrorCodes2[RPCErrorCodes2["InvalidClientId"] = 4007] = "InvalidClientId";
    RPCErrorCodes2[RPCErrorCodes2["InvalidOrigin"] = 4008] = "InvalidOrigin";
    RPCErrorCodes2[RPCErrorCodes2["InvalidToken"] = 4009] = "InvalidToken";
    RPCErrorCodes2[RPCErrorCodes2["InvalidUser"] = 4010] = "InvalidUser";
    RPCErrorCodes2[RPCErrorCodes2["InvalidInvite"] = 4011] = "InvalidInvite";
    RPCErrorCodes2[RPCErrorCodes2["InvalidActivityJoinRequest"] = 4012] = "InvalidActivityJoinRequest";
    RPCErrorCodes2[RPCErrorCodes2["InvalidEntitlement"] = 4013] = "InvalidEntitlement";
    RPCErrorCodes2[RPCErrorCodes2["InvalidGiftCode"] = 4014] = "InvalidGiftCode";
    RPCErrorCodes2[RPCErrorCodes2["OAuth2Error"] = 5000] = "OAuth2Error";
    RPCErrorCodes2[RPCErrorCodes2["SelectChannelTimedOut"] = 5001] = "SelectChannelTimedOut";
    RPCErrorCodes2[RPCErrorCodes2["GetGuildTimedOut"] = 5002] = "GetGuildTimedOut";
    RPCErrorCodes2[RPCErrorCodes2["SelectVoiceForceRequired"] = 5003] = "SelectVoiceForceRequired";
    RPCErrorCodes2[RPCErrorCodes2["CaptureShortcutAlreadyListening"] = 5004] = "CaptureShortcutAlreadyListening";
    RPCErrorCodes2[RPCErrorCodes2["InvalidActivitySecret"] = 5005] = "InvalidActivitySecret";
    RPCErrorCodes2[RPCErrorCodes2["NoEligibleActivity"] = 5006] = "NoEligibleActivity";
    RPCErrorCodes2[RPCErrorCodes2["PurchaseCanceled"] = 5007] = "PurchaseCanceled";
    RPCErrorCodes2[RPCErrorCodes2["PurchaseError"] = 5008] = "PurchaseError";
    RPCErrorCodes2[RPCErrorCodes2["UnauthorizedForAchievement"] = 5009] = "UnauthorizedForAchievement";
    RPCErrorCodes2[RPCErrorCodes2["RateLimited"] = 5010] = "RateLimited";
  })(RPCErrorCodes || (exports.RPCErrorCodes = RPCErrorCodes = {}));
  var RPCCloseEventCodes;
  (function(RPCCloseEventCodes2) {
    RPCCloseEventCodes2[RPCCloseEventCodes2["CloseNormal"] = 1000] = "CloseNormal";
    RPCCloseEventCodes2[RPCCloseEventCodes2["CloseUnsupported"] = 1003] = "CloseUnsupported";
    RPCCloseEventCodes2[RPCCloseEventCodes2["CloseAbnormal"] = 1006] = "CloseAbnormal";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidClientId"] = 4000] = "InvalidClientId";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidOrigin"] = 4001] = "InvalidOrigin";
    RPCCloseEventCodes2[RPCCloseEventCodes2["RateLimited"] = 4002] = "RateLimited";
    RPCCloseEventCodes2[RPCCloseEventCodes2["TokenRevoked"] = 4003] = "TokenRevoked";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidVersion"] = 4004] = "InvalidVersion";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidEncoding"] = 4005] = "InvalidEncoding";
  })(RPCCloseEventCodes || (exports.RPCCloseEventCodes = RPCCloseEventCodes = {}));
});

// node_modules/discord-api-types/rpc/v10.js
var require_v104 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RPCEvents = exports.RPCCommands = exports.RPCVersion = undefined;
  __exportStar(require_common4(), exports);
  exports.RPCVersion = "1";
  var RPCCommands;
  (function(RPCCommands2) {
    RPCCommands2["AcceptActivityInvite"] = "ACCEPT_ACTIVITY_INVITE";
    RPCCommands2["ActivityInviteUser"] = "ACTIVITY_INVITE_USER";
    RPCCommands2["Authenticate"] = "AUTHENTICATE";
    RPCCommands2["Authorize"] = "AUTHORIZE";
    RPCCommands2["BraintreePopupBridgeCallback"] = "BRAINTREE_POPUP_BRIDGE_CALLBACK";
    RPCCommands2["BrowserHandoff"] = "BROWSER_HANDOFF";
    RPCCommands2["CloseActivityJoinRequest"] = "CLOSE_ACTIVITY_JOIN_REQUEST";
    RPCCommands2["ConnectionsCallback"] = "CONNECTIONS_CALLBACK";
    RPCCommands2["CreateChannelInvite"] = "CREATE_CHANNEL_INVITE";
    RPCCommands2["DeepLink"] = "DEEP_LINK";
    RPCCommands2["Dispatch"] = "DISPATCH";
    RPCCommands2["GetApplicationTicket"] = "GET_APPLICATION_TICKET";
    RPCCommands2["GetChannel"] = "GET_CHANNEL";
    RPCCommands2["GetChannels"] = "GET_CHANNELS";
    RPCCommands2["GetEntitlementTicket"] = "GET_ENTITLEMENT_TICKET";
    RPCCommands2["GetEntitlements"] = "GET_ENTITLEMENTS";
    RPCCommands2["GetGuild"] = "GET_GUILD";
    RPCCommands2["GetGuilds"] = "GET_GUILDS";
    RPCCommands2["GetImage"] = "GET_IMAGE";
    RPCCommands2["GetNetworkingConfig"] = "GET_NETWORKING_CONFIG";
    RPCCommands2["GetRelationships"] = "GET_RELATIONSHIPS";
    RPCCommands2["GetSelectedVoiceChannel"] = "GET_SELECTED_VOICE_CHANNEL";
    RPCCommands2["GetSkus"] = "GET_SKUS";
    RPCCommands2["GetUser"] = "GET_USER";
    RPCCommands2["GetVoiceSettings"] = "GET_VOICE_SETTINGS";
    RPCCommands2["GiftCodeBrowser"] = "GIFT_CODE_BROWSER";
    RPCCommands2["GuildTemplateBrowser"] = "GUILD_TEMPLATE_BROWSER";
    RPCCommands2["InviteBrowser"] = "INVITE_BROWSER";
    RPCCommands2["NetworkingCreateToken"] = "NETWORKING_CREATE_TOKEN";
    RPCCommands2["NetworkingPeerMetrics"] = "NETWORKING_PEER_METRICS";
    RPCCommands2["NetworkingSystemMetrics"] = "NETWORKING_SYSTEM_METRICS";
    RPCCommands2["OpenOverlayActivityInvite"] = "OPEN_OVERLAY_ACTIVITY_INVITE";
    RPCCommands2["OpenOverlayGuildInvite"] = "OPEN_OVERLAY_GUILD_INVITE";
    RPCCommands2["OpenOverlayVoiceSettings"] = "OPEN_OVERLAY_VOICE_SETTINGS";
    RPCCommands2["Overlay"] = "OVERLAY";
    RPCCommands2["SelectTextChannel"] = "SELECT_TEXT_CHANNEL";
    RPCCommands2["SelectVoiceChannel"] = "SELECT_VOICE_CHANNEL";
    RPCCommands2["SendActivityJoinInvite"] = "SEND_ACTIVITY_JOIN_INVITE";
    RPCCommands2["SetActivity"] = "SET_ACTIVITY";
    RPCCommands2["SetCertifiedDevices"] = "SET_CERTIFIED_DEVICES";
    RPCCommands2["SetOverlayLocked"] = "SET_OVERLAY_LOCKED";
    RPCCommands2["SetUserVoiceSettings"] = "SET_USER_VOICE_SETTINGS";
    RPCCommands2["SetUserVoiceSettings2"] = "SET_USER_VOICE_SETTINGS_2";
    RPCCommands2["SetVoiceSettings"] = "SET_VOICE_SETTINGS";
    RPCCommands2["SetVoiceSettings2"] = "SET_VOICE_SETTINGS_2";
    RPCCommands2["StartPurchase"] = "START_PURCHASE";
    RPCCommands2["Subscribe"] = "SUBSCRIBE";
    RPCCommands2["Unsubscribe"] = "UNSUBSCRIBE";
    RPCCommands2["ValidateApplication"] = "VALIDATE_APPLICATION";
  })(RPCCommands || (exports.RPCCommands = RPCCommands = {}));
  var RPCEvents;
  (function(RPCEvents2) {
    RPCEvents2["ActivityInvite"] = "ACTIVITY_INVITE";
    RPCEvents2["ActivityJoin"] = "ACTIVITY_JOIN";
    RPCEvents2["ActivityJoinRequest"] = "ACTIVITY_JOIN_REQUEST";
    RPCEvents2["ActivitySpectate"] = "ACTIVITY_SPECTATE";
    RPCEvents2["ChannelCreate"] = "CHANNEL_CREATE";
    RPCEvents2["CurrentUserUpdate"] = "CURRENT_USER_UPDATE";
    RPCEvents2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
    RPCEvents2["EntitlementDelete"] = "ENTITLEMENT_DELETE";
    RPCEvents2["Error"] = "ERROR";
    RPCEvents2["GameJoin"] = "GAME_JOIN";
    RPCEvents2["GameSpectate"] = "GAME_SPECTATE";
    RPCEvents2["GuildCreate"] = "GUILD_CREATE";
    RPCEvents2["GuildStatus"] = "GUILD_STATUS";
    RPCEvents2["MessageCreate"] = "MESSAGE_CREATE";
    RPCEvents2["MessageDelete"] = "MESSAGE_DELETE";
    RPCEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
    RPCEvents2["NotificationCreate"] = "NOTIFICATION_CREATE";
    RPCEvents2["Overlay"] = "OVERLAY";
    RPCEvents2["OverlayUpdate"] = "OVERLAY_UPDATE";
    RPCEvents2["Ready"] = "READY";
    RPCEvents2["RelationshipUpdate"] = "RELATIONSHIP_UPDATE";
    RPCEvents2["SpeakingStart"] = "SPEAKING_START";
    RPCEvents2["SpeakingStop"] = "SPEAKING_STOP";
    RPCEvents2["VoiceChannelSelect"] = "VOICE_CHANNEL_SELECT";
    RPCEvents2["VoiceConnectionStatus"] = "VOICE_CONNECTION_STATUS";
    RPCEvents2["VoiceSettingsUpdate"] = "VOICE_SETTINGS_UPDATE";
    RPCEvents2["VoiceSettingsUpdate2"] = "VOICE_SETTINGS_UPDATE_2";
    RPCEvents2["VoiceStateCreate"] = "VOICE_STATE_CREATE";
    RPCEvents2["VoiceStateDelete"] = "VOICE_STATE_DELETE";
    RPCEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
  })(RPCEvents || (exports.RPCEvents = RPCEvents = {}));
});

// node_modules/discord-api-types/utils/v10.js
var require_v105 = __commonJS((exports) => {
  var isDMInteraction = function(interaction) {
    return Reflect.has(interaction, "user");
  };
  var isGuildInteraction = function(interaction) {
    return Reflect.has(interaction, "guild_id");
  };
  var isApplicationCommandDMInteraction = function(interaction) {
    return isDMInteraction(interaction);
  };
  var isApplicationCommandGuildInteraction = function(interaction) {
    return isGuildInteraction(interaction);
  };
  var isMessageComponentDMInteraction = function(interaction) {
    return isDMInteraction(interaction);
  };
  var isMessageComponentGuildInteraction = function(interaction) {
    return isGuildInteraction(interaction);
  };
  var isLinkButton = function(component) {
    return component.style === index_1.ButtonStyle.Link;
  };
  var isInteractionButton = function(component) {
    return ![index_1.ButtonStyle.Link, index_1.ButtonStyle.Premium].includes(component.style);
  };
  var isMessageComponentInteraction = function(interaction) {
    return interaction.type === index_1.InteractionType.MessageComponent;
  };
  var isMessageComponentButtonInteraction = function(interaction) {
    return interaction.data.component_type === index_1.ComponentType.Button;
  };
  var isMessageComponentSelectMenuInteraction = function(interaction) {
    return [
      index_1.ComponentType.StringSelect,
      index_1.ComponentType.UserSelect,
      index_1.ComponentType.RoleSelect,
      index_1.ComponentType.MentionableSelect,
      index_1.ComponentType.ChannelSelect
    ].includes(interaction.data.component_type);
  };
  var isChatInputApplicationCommandInteraction = function(interaction) {
    return interaction.data.type === index_1.ApplicationCommandType.ChatInput;
  };
  var isContextMenuApplicationCommandInteraction = function(interaction) {
    return interaction.data.type === index_1.ApplicationCommandType.Message || interaction.data.type === index_1.ApplicationCommandType.User;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDMInteraction = isDMInteraction;
  exports.isGuildInteraction = isGuildInteraction;
  exports.isApplicationCommandDMInteraction = isApplicationCommandDMInteraction;
  exports.isApplicationCommandGuildInteraction = isApplicationCommandGuildInteraction;
  exports.isMessageComponentDMInteraction = isMessageComponentDMInteraction;
  exports.isMessageComponentGuildInteraction = isMessageComponentGuildInteraction;
  exports.isLinkButton = isLinkButton;
  exports.isInteractionButton = isInteractionButton;
  exports.isMessageComponentInteraction = isMessageComponentInteraction;
  exports.isMessageComponentButtonInteraction = isMessageComponentButtonInteraction;
  exports.isMessageComponentSelectMenuInteraction = isMessageComponentSelectMenuInteraction;
  exports.isChatInputApplicationCommandInteraction = isChatInputApplicationCommandInteraction;
  exports.isContextMenuApplicationCommandInteraction = isContextMenuApplicationCommandInteraction;
  var index_1 = require_v102();
});

// node_modules/discord-api-types/v10.js
var require_v106 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Utils = undefined;
  __exportStar(require_v10(), exports);
  __exportStar(require_globals(), exports);
  __exportStar(require_v102(), exports);
  __exportStar(require_v103(), exports);
  __exportStar(require_v104(), exports);
  __exportStar(require_internals2(), exports);
  exports.Utils = require_v105();
});

// node_modules/@discordjs/rest/node_modules/@discordjs/collection/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    findLast(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const val = entries[index][1];
        const key = entries[index][0];
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findLastKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const key = entries[index][0];
        const val = entries[index][1];
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    reduceRight(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      const entries = [...this.entries()];
      let accumulator;
      let index;
      if (initialValue === undefined) {
        if (entries.length === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = entries[entries.length - 1][1];
        index = entries.length - 1;
      } else {
        accumulator = initialValue;
        index = entries.length;
      }
      while (--index >= 0) {
        const key = entries[index][0];
        const val = entries[index][1];
        accumulator = fn(accumulator, val, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersection(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    union(other) {
      const coll = new this.constructor[Symbol.species](this);
      for (const [key, value] of other) {
        if (!coll.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    symmetricDifference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    toReversed() {
      return new this.constructor[Symbol.species](this).reverse();
    }
    toSorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.entries()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "2.1.1";
});

// node_modules/@sapphire/snowflake/dist/cjs/index.cjs
var require_cjs = __commonJS((exports) => {
  var cmpBigInt = function(a, b) {
    return a === b ? 0 : a < b ? -1 : 1;
  };
  var cmpString = function(a, b) {
    return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;
  };
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var IncrementSymbol = Symbol("@sapphire/snowflake.increment");
  var EpochSymbol = Symbol("@sapphire/snowflake.epoch");
  var ProcessIdSymbol = Symbol("@sapphire/snowflake.processId");
  var WorkerIdSymbol = Symbol("@sapphire/snowflake.workerId");
  var MaximumWorkerId = 0b11111n;
  var MaximumProcessId = 0b11111n;
  var MaximumIncrement = 0b111111111111n;
  var _a;
  var _b;
  var _c;
  var _d;
  var _Snowflake = class _Snowflake2 {
    constructor(epoch) {
      __publicField(this, "decode", this.deconstruct);
      __publicField(this, _a);
      __publicField(this, _b, 0n);
      __publicField(this, _c, 1n);
      __publicField(this, _d, 0n);
      this[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);
    }
    get epoch() {
      return this[EpochSymbol];
    }
    get processId() {
      return this[ProcessIdSymbol];
    }
    set processId(value) {
      this[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;
    }
    get workerId() {
      return this[WorkerIdSymbol];
    }
    set workerId(value) {
      this[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;
    }
    generate({
      increment,
      timestamp = Date.now(),
      workerId = this[WorkerIdSymbol],
      processId = this[ProcessIdSymbol]
    } = {}) {
      if (timestamp instanceof Date)
        timestamp = BigInt(timestamp.getTime());
      else if (typeof timestamp === "number")
        timestamp = BigInt(timestamp);
      else if (typeof timestamp !== "bigint") {
        throw new TypeError(`"timestamp" argument must be a number, bigint, or Date (received ${typeof timestamp})`);
      }
      if (typeof increment !== "bigint") {
        increment = this[IncrementSymbol];
        this[IncrementSymbol] = increment + 1n & MaximumIncrement;
      }
      return timestamp - this[EpochSymbol] << 22n | (workerId & MaximumWorkerId) << 17n | (processId & MaximumProcessId) << 12n | increment & MaximumIncrement;
    }
    deconstruct(id) {
      const bigIntId = BigInt(id);
      const epoch = this[EpochSymbol];
      return {
        id: bigIntId,
        timestamp: (bigIntId >> 22n) + epoch,
        workerId: bigIntId >> 17n & MaximumWorkerId,
        processId: bigIntId >> 12n & MaximumProcessId,
        increment: bigIntId & MaximumIncrement,
        epoch
      };
    }
    timestampFrom(id) {
      return Number((BigInt(id) >> 22n) + this[EpochSymbol]);
    }
    static compare(a, b) {
      const typeA = typeof a;
      return typeA === typeof b ? typeA === "string" ? cmpString(a, b) : cmpBigInt(a, b) : cmpBigInt(BigInt(a), BigInt(b));
    }
  };
  _a = EpochSymbol, _b = IncrementSymbol, _c = ProcessIdSymbol, _d = WorkerIdSymbol;
  __name(_Snowflake, "Snowflake");
  var Snowflake = _Snowflake;
  __name(cmpBigInt, "cmpBigInt");
  __name(cmpString, "cmpString");
  var DiscordSnowflake = new Snowflake(1420070400000n);
  var TwitterSnowflake = new Snowflake(1288834974657n);
  exports.DiscordSnowflake = DiscordSnowflake;
  exports.MaximumIncrement = MaximumIncrement;
  exports.MaximumProcessId = MaximumProcessId;
  exports.MaximumWorkerId = MaximumWorkerId;
  exports.Snowflake = Snowflake;
  exports.TwitterSnowflake = TwitterSnowflake;
});

// node_modules/@vladfrangu/async_event_emitter/dist/index.cjs
var require_dist3 = __commonJS((exports, module) => {
  var validateListener = function(input) {
    if (typeof input !== "function") {
      throw new TypeError(`The listener argument must be a function. Received ${typeof input}`);
    }
  };
  var validateAbortSignal = function(input) {
    if (input && !(input instanceof AbortSignal)) {
      throw new TypeError(`The signal option must be an AbortSignal. Received ${input}`);
    }
  };
  var spliceOne = function(list, index) {
    for (;index + 1 < list.length; index++) {
      list[index] = list[index + 1];
    }
    list.pop();
  };
  var arrayClone = function(arr) {
    switch (arr.length) {
      case 2:
        return [arr[0], arr[1]];
      case 3:
        return [arr[0], arr[1], arr[2]];
      case 4:
        return [arr[0], arr[1], arr[2], arr[3]];
      case 5:
        return [arr[0], arr[1], arr[2], arr[3], arr[4]];
      case 6:
        return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];
    }
    return arr.slice();
  };
  var identicalSequenceRange = function(a, b) {
    for (let i = 0;i < a.length - 3; i++) {
      const pos = b.indexOf(a[i]);
      if (pos !== -1) {
        const rest = b.length - pos;
        if (rest > 3) {
          let len = 1;
          const maxLen = Math.min(a.length - i, rest);
          while (maxLen > len && a[i + len] === b[pos + len]) {
            len++;
          }
          if (len > 3) {
            return [len, i];
          }
        }
      }
    }
    return [0, 0];
  };
  var enhanceStackTrace = function(err, own) {
    let ctorInfo = "";
    try {
      const { name } = this.constructor;
      if (name !== "AsyncEventEmitter")
        ctorInfo = ` on ${name} instance`;
    } catch {
    }
    const sep = `
Emitted 'error' event${ctorInfo} at:
`;
    const errStack = err.stack.split("\n").slice(1);
    const ownStack = own.stack.split("\n").slice(1);
    const { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);
    if (len > 0) {
      ownStack.splice(off + 1, len - 2, "    [... lines matching original stack trace ...]");
    }
    return err.stack + sep + ownStack.join("\n");
  };
  var onceWrapper = function() {
    if (!this.fired) {
      this.eventEmitter.removeListener(this.eventName, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0) {
        return this.listener.call(this.eventEmitter);
      }
      return this.listener.apply(this.eventEmitter, arguments);
    }
  };
  var getReason = function(signal) {
    return signal?.reason;
  };
  var eventTargetAgnosticRemoveListener = function(emitter, name, listener, flags) {
    if (typeof emitter.off === "function") {
      emitter.off(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
      emitter.removeEventListener(name, listener, flags);
    }
  };
  var eventTargetAgnosticAddListener = function(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags?.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, listener, flags);
    }
  };
  var createIterResult = function(value, done) {
    return { value, done };
  };
  var handleMaybeAsync = function(emitter, result) {
    try {
      const the = result.then;
      const fin = result.finally;
      if (typeof the === "function") {
        the.call(result, undefined, (error) => {
          setTimeout(() => {
            emitter.emit("error", error);
          }, 0);
        });
      }
      if (typeof fin === "function") {
        const promiseId = String(++emitter["_wrapperId"]);
        emitter["_internalPromiseMap"].set(promiseId, result);
        fin.call(result, __name(function final() {
          emitter["_internalPromiseMap"].delete(promiseId);
        }, "final"));
      }
    } catch (err) {
      emitter.emit("error", err);
    }
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    AbortError: () => AbortError,
    AsyncEventEmitter: () => AsyncEventEmitter
  });
  module.exports = __toCommonJS(src_exports);
  __name(validateListener, "validateListener");
  __name(validateAbortSignal, "validateAbortSignal");
  __name(spliceOne, "spliceOne");
  __name(arrayClone, "arrayClone");
  __name(identicalSequenceRange, "identicalSequenceRange");
  __name(enhanceStackTrace, "enhanceStackTrace");
  var brandSymbol = Symbol.for("async-event-emitter.ts-brand");
  var _AsyncEventEmitter = class _AsyncEventEmitter2 {
    constructor() {
      this._events = {
        __proto__: null
      };
      this._eventCount = 0;
      this._maxListeners = 10;
      this._internalPromiseMap = new Map;
      this._wrapperId = 0n;
    }
    addListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, false);
      this._addListener(eventName, wrapped, false);
      return this;
    }
    on(eventName, listener) {
      return this.addListener(eventName, listener);
    }
    once(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, true);
      this._addListener(eventName, wrapped, false);
      return this;
    }
    removeListener(eventName, listener) {
      validateListener(listener);
      const events = this._events;
      const eventList = events[eventName];
      if (eventList === undefined) {
        return this;
      }
      if (eventList === listener || eventList.listener === listener) {
        if (--this._eventCount === 0) {
          this._events = { __proto__: null };
        } else {
          delete events[eventName];
          if (events.removeListener) {
            this.emit("removeListener", eventName, eventList.listener ?? eventList);
          }
        }
      } else if (typeof eventList !== "function") {
        let position = -1;
        for (let i = eventList.length - 1;i >= 0; i--) {
          if (eventList[i] === listener || eventList[i].listener === listener) {
            position = i;
            break;
          }
        }
        if (position < 0) {
          return this;
        }
        if (position === 0) {
          eventList.shift();
        } else {
          spliceOne(eventList, position);
        }
        if (eventList.length === 0) {
          delete events[eventName];
          --this._eventCount;
        }
        if (events.removeListener !== undefined) {
          this.emit("removeListener", eventName, listener);
        }
      }
      return this;
    }
    off(eventName, listener) {
      return this.removeListener(eventName, listener);
    }
    removeAllListeners(event) {
      const events = this._events;
      if (events.removeListener === undefined) {
        if (!event) {
          this._events = { __proto__: null };
          this._eventCount = 0;
        } else if (events[event] !== undefined) {
          if (--this._eventCount === 0) {
            this._events = { __proto__: null };
          } else {
            delete events[event];
          }
        }
        return this;
      }
      if (!event) {
        for (const key of Reflect.ownKeys(events)) {
          if (key === "removeListener") {
            continue;
          }
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = { __proto__: null };
        this._eventCount = 0;
        return this;
      }
      const listeners = events[event];
      if (typeof listeners === "function") {
        this.removeListener(event, listeners);
      } else if (listeners !== undefined) {
        for (let i = listeners.length - 1;i >= 0; i--) {
          this.removeListener(event, listeners[i]);
        }
      }
      return this;
    }
    setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new RangeError(`Expected to get a non-negative number for "setMaxListeners", got ${n} instead`);
      }
      this._maxListeners = n;
      return this;
    }
    getMaxListeners() {
      return this._maxListeners;
    }
    listeners(eventName) {
      const eventList = this._events[eventName];
      if (eventList === undefined) {
        return [];
      }
      if (typeof eventList === "function") {
        return [eventList.listener ?? eventList];
      }
      const ret = arrayClone(eventList);
      for (let i = 0;i < ret.length; ++i) {
        const orig = ret[i].listener;
        if (typeof orig === "function") {
          ret[i] = orig;
        }
      }
      return ret;
    }
    rawListeners(eventName) {
      const eventList = this._events[eventName];
      if (eventList === undefined) {
        return [];
      }
      if (typeof eventList === "function") {
        return [eventList];
      }
      return arrayClone(eventList);
    }
    emit(eventName, ...args) {
      let doError = eventName === "error";
      const events = this._events;
      if (events !== undefined) {
        doError = doError && events.error === undefined;
      } else if (!doError) {
        return false;
      }
      if (doError) {
        let er;
        if (args.length > 0) {
          er = args[0];
        }
        if (er instanceof Error) {
          try {
            const capture = {};
            Error.captureStackTrace(capture, _AsyncEventEmitter2.prototype.emit);
            Object.defineProperty(er, "stack", {
              value: enhanceStackTrace.call(this, er, capture),
              configurable: true
            });
          } catch {
          }
          throw er;
        }
        const stringifiedError = String(er);
        const err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);
        err.context = er;
        throw err;
      }
      const handlers = events[eventName];
      if (handlers === undefined) {
        return false;
      }
      if (typeof handlers === "function") {
        const result = handlers.apply(this, args);
        if (result !== undefined && result !== null) {
          handleMaybeAsync(this, result);
        }
      } else {
        const len = handlers.length;
        const listeners = arrayClone(handlers);
        for (let i = 0;i < len; ++i) {
          const result = listeners[i].apply(this, args);
          if (result !== undefined && result !== null) {
            handleMaybeAsync(this, result);
          }
        }
      }
      return true;
    }
    listenerCount(eventName) {
      const events = this._events;
      if (events === undefined) {
        return 0;
      }
      const eventListeners = events[eventName];
      if (typeof eventListeners === "function") {
        return 1;
      }
      return eventListeners?.length ?? 0;
    }
    prependListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, false);
      this._addListener(eventName, wrapped, true);
      return this;
    }
    prependOnceListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, true);
      this._addListener(eventName, wrapped, true);
      return this;
    }
    eventNames() {
      return this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];
    }
    async waitForAllListenersToComplete() {
      const promises = [...this._internalPromiseMap.values()];
      if (promises.length === 0) {
        return false;
      }
      await Promise.all(promises);
      return true;
    }
    _addListener(eventName, wrappedListener, prepend) {
      if (this._events.newListener !== undefined) {
        this.emit("newListener", eventName, wrappedListener.listener ?? wrappedListener);
      }
      let existing = this._events[eventName];
      if (existing === undefined) {
        existing = this._events[eventName] = wrappedListener;
        ++this._eventCount;
      } else if (typeof existing === "function") {
        existing = this._events[eventName] = prepend ? [wrappedListener, existing] : [existing, wrappedListener];
      } else if (prepend) {
        existing.unshift(wrappedListener);
      } else {
        existing.push(wrappedListener);
      }
      const existingWarnedAboutMaxListeners = Reflect.get(existing, "_hasWarnedAboutMaxListeners");
      if (this._maxListeners > 0 && existing.length > this._maxListeners && !existingWarnedAboutMaxListeners) {
        Reflect.set(existing, "_hasWarnedAboutMaxListeners", true);
        const warningMessage = [
          `Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${this.constructor.name}.`,
          `Use emitter.setMaxListeners() to increase the limit.`
        ].join(" ");
        console.warn(warningMessage);
      }
    }
    _wrapListener(eventName, listener, once) {
      if (!once) {
        return listener;
      }
      const state = {
        fired: false,
        wrapFn: undefined,
        eventEmitter: this,
        eventName,
        listener
      };
      const aliased = onceWrapper;
      const wrapped = aliased.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    static listenerCount(emitter, eventName) {
      return emitter.listenerCount(eventName);
    }
    static async once(emitter, eventName, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal);
      if (signal?.aborted) {
        throw new AbortError(undefined, { cause: getReason(signal) });
      }
      return new Promise((resolve, reject) => {
        const errorListener = __name((err) => {
          emitter.removeListener(eventName, resolver);
          if (signal) {
            eventTargetAgnosticRemoveListener(emitter, eventName, abortListener);
          }
          reject(err);
        }, "errorListener");
        const resolver = __name((...args) => {
          emitter.removeListener("error", errorListener);
          if (signal) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          resolve(args);
        }, "resolver");
        emitter.once(eventName, resolver);
        if (eventName !== "error") {
          emitter.once("error", errorListener);
        }
        const abortListener = __name(() => {
          eventTargetAgnosticRemoveListener(emitter, eventName, resolver);
          eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
          reject(new AbortError(undefined, { cause: getReason(signal) }));
        }, "abortListener");
        if (signal) {
          eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
        }
      });
    }
    static on(emitter, eventName, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal);
      if (signal?.aborted) {
        throw new AbortError(undefined, { cause: getReason(signal) });
      }
      const unconsumedEvents = [];
      const unconsumedPromises = [];
      let error = null;
      let finished = false;
      const abortListener = __name(() => {
        errorHandler(new AbortError(undefined, { cause: getReason(signal) }));
      }, "abortListener");
      const eventHandler = __name((...args) => {
        const promise = unconsumedPromises.shift();
        if (promise) {
          promise.resolve(createIterResult(args, false));
        } else {
          unconsumedEvents.push(args);
        }
      }, "eventHandler");
      const errorHandler = __name((err) => {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
          toError.reject(err);
        } else {
          error = err;
        }
        iterator.return();
      }, "errorHandler");
      const iterator = Object.setPrototypeOf({
        next() {
          const value = unconsumedEvents.shift();
          if (value) {
            return Promise.resolve(createIterResult(value, false));
          }
          if (error) {
            const p = Promise.reject(error);
            error = null;
            return p;
          }
          if (finished) {
            return Promise.resolve(createIterResult(undefined, true));
          }
          return new Promise((resolve, reject) => {
            unconsumedPromises.push({ resolve, reject });
          });
        },
        return() {
          emitter.off(eventName, eventHandler);
          emitter.off("error", errorHandler);
          if (signal) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          finished = true;
          const doneResult = createIterResult(undefined, true);
          for (const promise of unconsumedPromises) {
            promise.resolve(doneResult);
          }
          return Promise.resolve(doneResult);
        },
        throw(err) {
          if (!err || !(err instanceof Error)) {
            throw new TypeError(`Expected Error instance to be thrown in AsyncEventEmitter.AsyncIterator. Got ${err}`);
          }
          error = err;
          emitter.off(eventName, eventHandler);
          emitter.off("error", errorHandler);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      }, AsyncIteratorPrototype);
      emitter.on(eventName, eventHandler);
      if (eventName !== "error") {
        emitter.on("error", errorHandler);
      }
      if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener);
      }
      return iterator;
    }
  };
  __name(_AsyncEventEmitter, "AsyncEventEmitter");
  var AsyncEventEmitter = _AsyncEventEmitter;
  __name(onceWrapper, "onceWrapper");
  __name(getReason, "getReason");
  __name(eventTargetAgnosticRemoveListener, "eventTargetAgnosticRemoveListener");
  __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
  var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
  }).prototype);
  __name(createIterResult, "createIterResult");
  var _AbortError = class _AbortError2 extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object") {
        throw new TypeError(`Failed to create AbortError: options is not an object or undefined`);
      }
      super(message, options);
      this.code = "ABORT_ERR";
      this.name = "AbortError";
    }
  };
  __name(_AbortError, "AbortError");
  var AbortError = _AbortError;
  __name(handleMaybeAsync, "handleMaybeAsync");
});

// node_modules/magic-bytes.js/dist/model/toHex.js
var require_toHex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromHex = exports.toHex = undefined;
  var hex = (num) => new Number(num).toString(16).toLowerCase();
  var toHex = (num) => `0x${hex(num).length === 1 ? "0" + hex(num) : hex(num)}`;
  exports.toHex = toHex;
  var fromHex = (hex2) => new Number(hex2);
  exports.fromHex = fromHex;
});

// node_modules/magic-bytes.js/dist/model/tree.js
var require_tree = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createComplexNode = exports.createNode = exports.merge = undefined;
  var createMatch = (leaf) => ({
    typename: leaf.typename,
    mime: leaf.info.mime,
    extension: leaf.info.extension
  });
  var isLeafNode = (tree, path) => tree && path.length === 0;
  var merge = (node, tree) => {
    if (node.bytes.length === 0)
      return tree;
    const [currentByte, ...path] = node.bytes;
    const currentTree = tree.bytes[currentByte];
    if (isLeafNode(currentTree, path)) {
      const matchingNode = tree.bytes[currentByte];
      tree.bytes[currentByte] = {
        ...matchingNode,
        matches: [
          ...matchingNode.matches ?? [],
          createMatch(node)
        ]
      };
      return tree;
    }
    if (tree.bytes[currentByte]) {
      tree.bytes[currentByte] = exports.merge(exports.createNode(node.typename, path, node.info), tree.bytes[currentByte]);
    } else {
      tree.bytes[currentByte] = exports.createComplexNode(node.typename, path, node.info);
    }
    return tree;
  };
  exports.merge = merge;
  var createNode = (typename, bytes, info) => {
    return { typename, bytes, info: info ? info : {} };
  };
  exports.createNode = createNode;
  var createComplexNode = (typename, bytes, info) => {
    let obj = {
      bytes: {},
      matches: undefined
    };
    const [currentKey, ...path] = bytes;
    if (bytes.length === 0) {
      return {
        matches: [
          createMatch({
            typename,
            info: info ? { extension: info.extension, mime: info.mime } : {}
          })
        ],
        bytes: {}
      };
    }
    obj.bytes[currentKey] = exports.createComplexNode(typename, path, info);
    return obj;
  };
  exports.createComplexNode = createComplexNode;
});

// node_modules/magic-bytes.js/dist/model/pattern-tree.js
var require_pattern_tree = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTree = exports.add = undefined;
  var toHex_1 = require_toHex();
  var tree_1 = require_tree();
  var tree = {
    noOffset: null,
    offset: {}
  };
  var add = (typename, signature, additionalInfo, offset) => {
    if (offset) {
      const existing = tree.offset[toHex_1.toHex(offset)];
      if (!existing) {
        tree.offset[toHex_1.toHex(offset)] = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
      } else {
        const merged = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), { ...existing });
        tree.offset[toHex_1.toHex(offset)] = merged;
      }
    } else {
      if (tree.noOffset === null) {
        tree.noOffset = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
      } else {
        tree.noOffset = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), tree.noOffset);
      }
    }
  };
  exports.add = add;
  exports.add("gif", ["0x47", "0x49", "0x46", "0x38", "0x37", "0x61"], {
    mime: "image/gif",
    extension: "gif"
  });
  exports.add("gif", ["0x47", "0x49", "0x46", "0x38", "0x39", "0x61"], {
    mime: "image/gif",
    extension: "gif"
  });
  exports.add("jpg", ["0xFF", "0xD8", "0xFF"], {
    mime: "image/jpeg",
    extension: "jpeg"
  });
  exports.add("webp", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x45",
    "0x42",
    "0x50"
  ], { mime: "image/webp", extension: "webp" });
  exports.add("heif", ["0x66", "0x74", "0x79", "0x70", "0x6D", "0x69", "0x66", "0x31"], { mime: "image/heif", extension: "heif" }, 4);
  exports.add("heif", ["0x66", "0x74", "0x79", "0x70", "0x68", "0x65", "0x69", "0x63"], { mime: "image/heif", extension: "heic" }, 4);
  exports.add("rpm", ["0xed", "0xab", "0xee", "0xdb"]);
  exports.add("bin", ["0x53", "0x50", "0x30", "0x31"], {
    mime: "application/octet-stream",
    extension: "bin"
  });
  exports.add("pic", ["0x00"]);
  exports.add("pif", ["0x00"]);
  exports.add("sea", ["0x00"]);
  exports.add("ytr", ["0x00"]);
  exports.add("mp4", ["0x66", "0x74", "0x79", "0x70"], { mime: "video/mp4", extension: "mp4" }, 4);
  exports.add("ttf", ["0x00", "0x01", "0x00", "0x00", "0x00"], {
    mime: "font/ttf",
    extension: "ttf"
  });
  exports.add("otf", ["0x4F", "0x54", "0x54", "0x4F"], {
    mime: "font/otf",
    extension: "otf"
  });
  exports.add("eot", ["0x50", "0x4C"], {
    mime: "application/vnd.ms-fontobject",
    extension: "eot"
  });
  exports.add("woff", ["0x77", "0x4F", "0x46", "0x46"], {
    mime: "font/woff",
    extension: "woff"
  });
  exports.add("woff2", ["0x77", "0x4F", "0x46", "0x32"], {
    mime: "font/woff2",
    extension: "woff2"
  });
  exports.add("pdb", [
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ]);
  exports.add("dba", ["0xBE", "0xBA", "0xFE", "0xCA"]);
  exports.add("dba2", ["0x00", "0x01", "0x42", "0x44"]);
  exports.add("tda", ["0x00", "0x01", "0x44", "0x54"]);
  exports.add("tda2", ["0x00", "0x01", "0x00", "0x00"]);
  exports.add("ico", ["0x00", "0x00", "0x01", "0x00"], {
    mime: "image/x-icon",
    extension: "ico"
  });
  exports.add("3gp", ["0x66", "0x74", "0x79", "0x70", "0x33", "0x67"]);
  exports.add("z", ["0x1F", "0x9D"]);
  exports.add("tar.z", ["0x1F", "0xA0"]);
  exports.add("bac", [
    "0x42",
    "0x41",
    "0x43",
    "0x4B",
    "0x4D",
    "0x49",
    "0x4B",
    "0x45",
    "0x44",
    "0x49",
    "0x53",
    "0x4B"
  ]);
  exports.add("bz2", ["0x42", "0x5A", "0x68"], {
    mime: "application/x-bzip2",
    extension: "bz2"
  });
  exports.add("tif", ["0x49", "0x49", "0x2A", "0x00"], {
    mime: "image/tiff",
    extension: "tif"
  });
  exports.add("tiff", ["0x4D", "0x4D", "0x00", "0x2A"], {
    mime: "image/tiff",
    extension: "tiff"
  });
  exports.add("cr2", [
    "0x49",
    "0x49",
    "0x2A",
    "0x00",
    "0x10",
    "0x00",
    "0x00",
    "0x00",
    "0x43",
    "0x52"
  ]);
  exports.add("cin", ["0x80", "0x2A", "0x5F", "0xD7"]);
  exports.add("cin1", ["0x52", "0x4E", "0x43", "0x01"]);
  exports.add("cin2", ["0x52", "0x4E", "0x43", "0x02"]);
  exports.add("dpx", ["0x53", "0x44", "0x50", "0x58"]);
  exports.add("dpx2", ["0x58", "0x50", "0x44", "0x53"]);
  exports.add("exr", ["0x76", "0x2F", "0x31", "0x01"]);
  exports.add("bpg", ["0x42", "0x50", "0x47", "0xFB"]);
  exports.add("ilbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x49",
    "0x4C",
    "0x42",
    "0x4D"
  ]);
  exports.add("8svx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x38",
    "0x53",
    "0x56",
    "0x58"
  ]);
  exports.add("acbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x43",
    "0x42",
    "0x4D"
  ]);
  exports.add("anbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x42",
    "0x4D"
  ]);
  exports.add("anim", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x49",
    "0x4D"
  ]);
  exports.add("faxx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x58",
    "0x58"
  ]);
  exports.add("ftxt", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x54",
    "0x58",
    "0x54"
  ]);
  exports.add("smus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x4D",
    "0x55",
    "0x53"
  ]);
  exports.add("cmus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x43",
    "0x4D",
    "0x55",
    "0x53"
  ]);
  exports.add("yuvn", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x59",
    "0x55",
    "0x56",
    "0x4E"
  ]);
  exports.add("iff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x4E",
    "0x54"
  ]);
  exports.add("aiff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x49",
    "0x46",
    "0x46"
  ], { mime: "audio/x-aiff", extension: "aiff" });
  exports.add("idx", ["0x49", "0x4E", "0x44", "0x58"]);
  exports.add("lz", ["0x4C", "0x5A", "0x49", "0x50"]);
  exports.add("exe", ["0x4D", "0x5A"]);
  exports.add("zip", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/zip",
    extension: "zip"
  });
  exports.add("zip", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/zip",
    extension: "zip"
  });
  exports.add("zip", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/zip",
    extension: "zip"
  });
  exports.add("jar", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  exports.add("jar", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  exports.add("jar", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  exports.add("odt", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  exports.add("odt", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  exports.add("odt", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  exports.add("ods", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  exports.add("ods", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  exports.add("ods", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  exports.add("odp", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  exports.add("odp", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  exports.add("odp", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  exports.add("docx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  exports.add("docx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  exports.add("docx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  exports.add("xlsx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  exports.add("xlsx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  exports.add("xlsx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  exports.add("pptx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  exports.add("pptx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  exports.add("pptx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  exports.add("vsdx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  exports.add("vsdx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  exports.add("vsdx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  exports.add("apk", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  exports.add("apk", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  exports.add("apk", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  exports.add("aar", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  exports.add("aar", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  exports.add("aar", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  exports.add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x00"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  exports.add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x01", "0x00"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  exports.add("rar", ["0x7F", "0x45", "0x4C", "0x46"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  exports.add("png", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
    mime: "image/png",
    extension: "png"
  });
  exports.add("apng", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
    mime: "image/apng",
    extension: "apng"
  });
  exports.add("class", ["0xCA", "0xFE", "0xBA", "0xBE"]);
  exports.add("class", ["0xEF", "0xBB", "0xBF"]);
  exports.add("class", ["0xFE", "0xed", "0xFA", "0xCE"], undefined, 4096);
  exports.add("class", ["0xFE", "0xed", "0xFA", "0xCF"], undefined, 4096);
  exports.add("class", ["0xCE", "0xFA", "0xed", "0xFE"]);
  exports.add("class", ["0xCF", "0xFA", "0xed", "0xFE"]);
  exports.add("class", ["0xFF", "0xFE"]);
  exports.add("class", ["0xFF", "0xFE"]);
  exports.add("class", ["0xFF", "0xFE", "0x00", "0x00"]);
  exports.add("ps", ["0x25", "0x21", "0x50", "0x53"], {
    mime: "application/postscript",
    extension: ".ps"
  });
  exports.add("pdf", ["0x25", "0x50", "0x44", "0x46"], {
    mime: "application/pdf",
    extension: "pdf"
  });
  exports.add("asf", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  exports.add("wma", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  exports.add("wmv", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  exports.add("deploymentimage", [
    "0x24",
    "0x53",
    "0x44",
    "0x49",
    "0x30",
    "0x30",
    "0x30",
    "0x31"
  ]);
  exports.add("ogv", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x80",
    "0x74",
    "0x68",
    "0x65",
    "0x6F",
    "0x72",
    "0x61"
  ], {
    mime: "video/ogg",
    extension: "ogv"
  });
  exports.add("ogm", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x01",
    "0x76",
    "0x69",
    "0x64",
    "0x65",
    "0x6F",
    "0x00"
  ], {
    mime: "video/ogg",
    extension: "ogm"
  });
  exports.add("oga", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x7F",
    "0x46",
    "0x4C",
    "0x41",
    "0x43"
  ], {
    mime: "audio/ogg",
    extension: "oga"
  });
  exports.add("spx", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x70",
    "0x65",
    "0x65",
    "0x78",
    "0x20",
    "0x20"
  ], {
    mime: "audio/ogg",
    extension: "spx"
  });
  exports.add("ogg", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x01",
    "0x76",
    "0x6F",
    "0x72",
    "0x62",
    "0x69",
    "0x73"
  ], {
    mime: "audio/ogg",
    extension: "ogg"
  });
  exports.add("ogx", ["0x4F", "0x67", "0x67", "0x53"], {
    mime: "application/ogg",
    extension: "ogx"
  });
  exports.add("psd", ["0x38", "0x42", "0x50", "0x53"], {
    mime: "application/x-photoshop",
    extension: "psd"
  });
  exports.add("clip", ["0x43", "0x53", "0x46", "0x43", "0x48", "0x55", "0x4e", "0x4b"]);
  exports.add("wav", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x41",
    "0x56",
    "0x45"
  ], { mime: "audio/x-wav", extension: "wav" });
  exports.add("avi", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x56",
    "0x49",
    "0x20"
  ], { mime: "video/x-msvideo", extension: "avi" });
  exports.add("mp3", ["0xFF", "0xFB"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("mp3", ["0xFF", "0xF3"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("mp3", ["0xFF", "0xF2"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("mp3", ["0x49", "0x44", "0x33"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("bmp", ["0x42", "0x4D"], { mime: "image/bmp", extension: "bmp" });
  exports.add("iso", ["0x43", "0x44", "0x30", "0x30", "0x31"]);
  exports.add("flac", ["0x66", "0x4C", "0x61", "0x43"]);
  exports.add("mid", ["0x4D", "0x54", "0x68", "0x64"], {
    mime: "audio/midi",
    extension: "mid"
  });
  exports.add("midi", ["0x4D", "0x54", "0x68", "0x64"], {
    mime: "audio/midi",
    extension: "midi"
  });
  exports.add("doc", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/msword",
    extension: "doc"
  });
  exports.add("xls", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/vnd.ms-excel",
    extension: "xls"
  });
  exports.add("ppt", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/vnd.ms-powerpoint",
    extension: "ppt"
  });
  exports.add("msg", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"]);
  exports.add("dex", ["0x64", "0x65", "0x78", "0x0A", "0x30", "0x33", "0x35", "0x00"]);
  exports.add("vmdk", ["0x4B", "0x44", "0x4D"]);
  exports.add("crx", ["0x43", "0x72", "0x32", "0x34"]);
  exports.add("fh8", ["0x41", "0x47", "0x44", "0x33"]);
  exports.add("cwk", [
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
  ]);
  exports.add("cwk", [
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
  ]);
  exports.add("toast", ["0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
  exports.add("toast", ["0x8B", "0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
  exports.add("dmg", ["0x78", "0x01", "0x73", "0x0D", "0x62", "0x62", "0x60"]);
  exports.add("xar", ["0x78", "0x61", "0x72", "0x21"]);
  exports.add("dat", ["0x50", "0x4D", "0x4F", "0x43", "0x43", "0x4D", "0x4F", "0x43"]);
  exports.add("nes", ["0x4E", "0x45", "0x53", "0x1A"]);
  exports.add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x00", "0x30", "0x30"], {
    mime: "application/x-tar",
    extension: "tar"
  }, 257);
  exports.add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x20", "0x20", "0x00"], {
    mime: "application/x-tar",
    extension: "tar"
  }, 257);
  exports.add("tox", ["0x74", "0x6F", "0x78", "0x33"]);
  exports.add("mlv", ["0x4D", "0x4C", "0x56", "0x49"]);
  exports.add("windowsupdate", [
    "0x44",
    "0x43",
    "0x4D",
    "0x01",
    "0x50",
    "0x41",
    "0x33",
    "0x30"
  ]);
  exports.add("7z", ["0x37", "0x7A", "0xBC", "0xAF", "0x27", "0x1C"], {
    mime: "application/x-7z-compressed",
    extension: "7z"
  });
  exports.add("gz", ["0x1F", "0x8B"], { mime: "application/gzip", extension: "gz" });
  exports.add("tar.gz", ["0x1F", "0x8B"], {
    mime: "application/gzip",
    extension: "tar.gz"
  });
  exports.add("xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
    mime: "application/gzip",
    extension: "xz"
  });
  exports.add("tar.xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
    mime: "application/gzip",
    extension: "tar.xz"
  });
  exports.add("lz2", ["0x04", "0x22", "0x4D", "0x18"]);
  exports.add("cab", ["0x4D", "0x53", "0x43", "0x46"]);
  exports.add("mkv", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "video/x-matroska",
    extension: "mkv"
  });
  exports.add("mka", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "audio/x-matroska",
    extension: "mka"
  });
  exports.add("mks", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "video/x-matroska",
    extension: "mks"
  });
  exports.add("mk3d", ["0x1A", "0x45", "0xDF", "0xA3"]);
  exports.add("webm", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "audio/webm",
    extension: "webm"
  });
  exports.add("dcm", ["0x44", "0x49", "0x43", "0x4D"], undefined, 128);
  exports.add("xml", ["0x3C", "0x3f", "0x78", "0x6d", "0x6C", "0x20"], {
    mime: "application/xml",
    extension: "xml"
  });
  exports.add("wasm", ["0x00", "0x61", "0x73", "0x6d"], {
    mime: "application/wasm",
    extension: "wasm"
  });
  exports.add("lep", ["0xCF", "0x84", "0x01"]);
  exports.add("swf", ["0x43", "0x57", "0x53"], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
  });
  exports.add("swf", ["0x46", "0x57", "0x53"], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
  });
  exports.add("deb", ["0x21", "0x3C", "0x61", "0x72", "0x63", "0x68", "0x3E"]);
  exports.add("rtf", ["0x7B", "0x5C", "0x72", "0x74", "0x66", "0x31"], {
    mime: "application/rtf",
    extension: "rtf"
  });
  exports.add("m2p", ["0x00", "0x00", "0x01", "0xBA"]);
  exports.add("vob", ["0x00", "0x00", "0x01", "0xBA"]);
  exports.add("mpg", ["0x00", "0x00", "0x01", "0xBA"], {
    mime: "video/mpeg",
    extension: "mpg"
  });
  exports.add("mpeg", ["0x00", "0x00", "0x01", "0xBA"], {
    mime: "video/mpeg",
    extension: "mpeg"
  });
  exports.add("mpeg", ["0x47"], { mime: "video/mpeg", extension: "mpeg" });
  exports.add("mpeg", ["0x00", "0x00", "0x01", "0xB3"], {
    mime: "video/mpeg",
    extension: "mpeg"
  });
  exports.add("mov", ["0x66", "0x72", "0x65", "0x65"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x6D", "0x64", "0x61", "0x74"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x6D", "0x6F", "0x6F", "0x76"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x77", "0x69", "0x64", "0x65"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x66", "0x74", "0x79", "0x70", "0x71", "0x74"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("hl2demo", ["0x48", "0x4C", "0x32", "0x44", "0x45", "0x4D", "0x4F"]);
  exports.add("txt", ["0xEF", "0xBB", "0xBF"], {
    mime: "text/plain; charset=UTF-8",
    extension: "txt"
  });
  exports.add("txt", ["0xFF", "0xFE"], {
    mime: "text/plain; charset=UTF-16LE",
    extension: "txt"
  });
  exports.add("txt", ["0xFE", "0xFF"], {
    mime: "text/plain; charset=UTF-16BE",
    extension: "txt"
  });
  exports.add("txt", ["0xFF", "0xFE", "0x00", "0x00"], {
    mime: "text/plain; charset=UTF-32LE",
    extension: "txt"
  });
  exports.add("txt", ["0x00", "0x00", "0xFE", "0xFF"], {
    mime: "text/plain; charset=UTF-32BE",
    extension: "txt"
  });
  exports.add("SubRip", ["0x31", "0x0D", "0x0A", "0x30", "0x30", "0x3A"], {
    mime: "application/x-subrip",
    extension: "srt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0A"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0D"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x20"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x09"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x0A"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x0D"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x20"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x09"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("Json", ["0x7B"], {
    mime: "application/json",
    extension: ".json"
  });
  exports.add("Json", ["0x5B"], {
    mime: "application/json",
    extension: ".json"
  });
  exports.add("ELF", ["0x7F", "0x45", "0x4C", "0x46"], {
    mime: "application/x-executable",
    extension: ".elf"
  });
  exports.add("Mach-O", ["0xFE", "0xED", "0xFA", "0xC"], {
    mime: "application/x-mach-binary",
    extension: ".o"
  });
  exports.add("Mach-O", ["0xFE", "0xED", "0xFA", "0xCF"], {
    mime: "application/x-executable",
    extension: "elf"
  });
  exports.add("EML", ["0x52", "0x65", "0x63", "0x65", "0x69", "0x76", "0x65", "0x64", "0x3A"], {
    mime: "message/rfc822",
    extension: ".eml"
  });
  exports.add("SVG", ["0x3c", "0x73", "0x76", "0x67"], {
    mime: "image/svg+xml",
    extension: "svg"
  });
  exports.add("avif", ["0x66", "0x74", "0x79", "0x70", "0x61", "0x76", "0x69", "0x66"], {
    mime: "image/avif",
    extension: "avif"
  }, 4);
  var createTree = () => tree;
  exports.createTree = createTree;
  exports.default = () => tree;
});

// node_modules/magic-bytes.js/dist/index.js
var require_dist4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.register = exports.filetypeextension = exports.filetypemime = exports.filetypename = exports.filetypeinfo = undefined;
  var pattern_tree_1 = require_pattern_tree();
  var toHex_1 = require_toHex();
  var patternTree = pattern_tree_1.createTree();
  var filetypeinfo = (bytes) => {
    let tree = patternTree;
    for (const k of Object.keys(tree.offset)) {
      const offset = toHex_1.fromHex(k);
      const offsetExceedsFile = offset >= bytes.length;
      if (offsetExceedsFile) {
        continue;
      }
      const node = patternTree.offset[k];
      const guessed = walkTree(offset, bytes, node);
      if (guessed.length > 0) {
        return guessed;
      }
    }
    if (tree.noOffset === null) {
      return [];
    }
    return walkTree(0, bytes, tree.noOffset);
  };
  exports.filetypeinfo = filetypeinfo;
  var walkTree = (index, bytes, node) => {
    let step = node;
    let guessFile = [];
    while (true) {
      const currentByte = toHex_1.toHex(bytes[index]);
      if (step.bytes["?"] && !step.bytes[currentByte]) {
        step = step.bytes["?"];
      } else {
        step = step.bytes[currentByte];
      }
      if (!step) {
        return guessFile;
      }
      if (step && step.matches) {
        guessFile = step.matches.slice(0);
      }
      index += 1;
    }
  };
  exports.default = exports.filetypeinfo;
  var filetypename = (bytes) => exports.filetypeinfo(bytes).map((e) => e.typename);
  exports.filetypename = filetypename;
  var filetypemime = (bytes) => exports.filetypeinfo(bytes).map((e) => e.mime ? e.mime : null).filter((x) => x !== null);
  exports.filetypemime = filetypemime;
  var filetypeextension = (bytes) => exports.filetypeinfo(bytes).map((e) => e.extension ? e.extension : null).filter((x) => x !== null);
  exports.filetypeextension = filetypeextension;
  var register = (typename, signature, additionalInfo, offset) => {
    pattern_tree_1.add(typename, signature, additionalInfo, offset);
  };
  exports.register = register;
});

// node_modules/@sapphire/async-queue/dist/cjs/index.cjs
var require_cjs2 = __commonJS((exports) => {
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var _AsyncQueueEntry = class _AsyncQueueEntry2 {
    constructor(queue) {
      __publicField(this, "promise");
      __publicField(this, "resolve");
      __publicField(this, "reject");
      __publicField(this, "queue");
      __publicField(this, "signal", null);
      __publicField(this, "signalListener", null);
      this.queue = queue;
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
    }
    setSignal(signal) {
      if (signal.aborted)
        return this;
      this.signal = signal;
      this.signalListener = () => {
        const index = this.queue["promises"].indexOf(this);
        if (index !== -1)
          this.queue["promises"].splice(index, 1);
        this.reject(new Error("Request aborted manually"));
      };
      this.signal.addEventListener("abort", this.signalListener);
      return this;
    }
    use() {
      this.dispose();
      this.resolve();
      return this;
    }
    abort() {
      this.dispose();
      this.reject(new Error("Request aborted manually"));
      return this;
    }
    dispose() {
      if (this.signal) {
        this.signal.removeEventListener("abort", this.signalListener);
        this.signal = null;
        this.signalListener = null;
      }
    }
  };
  __name(_AsyncQueueEntry, "AsyncQueueEntry");
  var AsyncQueueEntry = _AsyncQueueEntry;
  var _AsyncQueue = class _AsyncQueue2 {
    constructor() {
      __publicField(this, "promises", []);
    }
    get remaining() {
      return this.promises.length;
    }
    get queued() {
      return this.remaining === 0 ? 0 : this.remaining - 1;
    }
    wait(options) {
      const entry = new AsyncQueueEntry(this);
      if (this.promises.length === 0) {
        this.promises.push(entry);
        return Promise.resolve();
      }
      this.promises.push(entry);
      if (options?.signal)
        entry.setSignal(options.signal);
      return entry.promise;
    }
    shift() {
      if (this.promises.length === 0)
        return;
      if (this.promises.length === 1) {
        this.promises.shift();
        return;
      }
      this.promises.shift();
      this.promises[0].use();
    }
    abortAll() {
      if (this.queued === 0)
        return;
      for (let i = 1;i < this.promises.length; ++i) {
        this.promises[i].abort();
      }
      this.promises.length = 1;
    }
  };
  __name(_AsyncQueue, "AsyncQueue");
  var AsyncQueue = _AsyncQueue;
  exports.AsyncQueue = AsyncQueue;
});

// node_modules/@discordjs/rest/dist/index.js
var require_dist5 = __commonJS((exports, module) => {
  var setDefaultStrategy = function(newStrategy) {
    defaultStrategy = newStrategy;
  };
  var getDefaultStrategy = function() {
    return defaultStrategy;
  };
  async function makeRequest(url, init) {
    const options = {
      ...init,
      body: await resolveBody(init.body)
    };
    const res = await (0, import_undici.request)(url, options);
    return {
      body: res.body,
      async arrayBuffer() {
        return res.body.arrayBuffer();
      },
      async json() {
        return res.body.json();
      },
      async text() {
        return res.body.text();
      },
      get bodyUsed() {
        return res.body.bodyUsed;
      },
      headers: new import_undici.Headers(res.headers),
      status: res.statusCode,
      statusText: import_node_http.STATUS_CODES[res.statusCode],
      ok: res.statusCode >= 200 && res.statusCode < 300
    };
  }
  async function resolveBody(body) {
    if (body == null) {
      return null;
    } else if (typeof body === "string") {
      return body;
    } else if (import_node_util.types.isUint8Array(body)) {
      return body;
    } else if (import_node_util.types.isArrayBuffer(body)) {
      return new Uint8Array(body);
    } else if (body instanceof import_node_url.URLSearchParams) {
      return body.toString();
    } else if (body instanceof DataView) {
      return new Uint8Array(body.buffer);
    } else if (body instanceof Blob) {
      return new Uint8Array(await body.arrayBuffer());
    } else if (body instanceof FormData) {
      return body;
    } else if (body[Symbol.iterator]) {
      const chunks = [...body];
      return Buffer.concat(chunks);
    } else if (body[Symbol.asyncIterator]) {
      const chunks = [];
      for await (const chunk of body) {
        chunks.push(chunk);
      }
      return Buffer.concat(chunks);
    }
    throw new TypeError(`Unable to resolve body.`);
  }
  var serializeSearchParam = function(value) {
    switch (typeof value) {
      case "string":
        return value;
      case "number":
      case "bigint":
      case "boolean":
        return value.toString();
      case "object":
        if (value === null)
          return null;
        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }
        if (typeof value.toString === "function" && value.toString !== Object.prototype.toString)
          return value.toString();
        return null;
      default:
        return null;
    }
  };
  var makeURLSearchParams = function(options) {
    const params = new URLSearchParams;
    if (!options)
      return params;
    for (const [key, value] of Object.entries(options)) {
      const serialized = serializeSearchParam(value);
      if (serialized !== null)
        params.append(key, serialized);
    }
    return params;
  };
  async function parseResponse(res) {
    if (res.headers.get("Content-Type")?.startsWith("application/json")) {
      return res.json();
    }
    return res.arrayBuffer();
  }
  var hasSublimit = function(bucketRoute, body, method) {
    if (bucketRoute === "/channels/:id") {
      if (typeof body !== "object" || body === null)
        return false;
      if (method !== "PATCH")
        return false;
      const castedBody = body;
      return ["name", "topic"].some((key) => Reflect.has(castedBody, key));
    }
    return true;
  };
  var shouldRetry = function(error) {
    if (error.name === "AbortError")
      return true;
    return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
  };
  async function onRateLimit(manager, rateLimitData) {
    const { options } = manager;
    if (!options.rejectOnRateLimit)
      return;
    const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
    if (shouldThrow) {
      throw new RateLimitError(rateLimitData);
    }
  }
  var calculateUserDefaultAvatarIndex = function(userId) {
    return Number(BigInt(userId) >> 22n) % 6;
  };
  async function sleep(ms) {
    return new Promise((resolve) => {
      setTimeout(() => resolve(), ms);
    });
  }
  var isBufferLike = function(value) {
    return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
  };
  var deprecationWarning = function(message) {
    if (typeof globalThis.process === "undefined") {
      console.warn(`${DEPRECATION_WARNING_PREFIX}: ${message}`);
    } else {
      process.emitWarning(message, DEPRECATION_WARNING_PREFIX);
    }
  };
  var normalizeRateLimitOffset = function(offset, route) {
    if (typeof offset === "number") {
      return Math.max(0, offset);
    }
    const result = offset(route);
    return Math.max(0, result);
  };
  var isErrorGroupWrapper = function(error) {
    return Reflect.has(error, "_errors");
  };
  var isErrorResponse = function(error) {
    return typeof Reflect.get(error, "message") === "string";
  };
  var incrementInvalidCount = function(manager) {
    if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
      invalidCountResetTime = Date.now() + 1000 * 60 * 10;
      invalidCount = 0;
    }
    invalidCount++;
    const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
    if (emitInvalid) {
      manager.emit("invalidRequestWarning", {
        count: invalidCount,
        remainingTime: invalidCountResetTime - Date.now()
      });
    }
  };
  async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
    const controller = new AbortController;
    const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
    if (requestData.signal) {
      if (requestData.signal.aborted)
        controller.abort();
      else
        requestData.signal.addEventListener("abort", () => controller.abort());
    }
    let res;
    try {
      res = await manager.options.makeRequest(url, { ...options, signal: controller.signal });
    } catch (error) {
      if (!(error instanceof Error))
        throw error;
      if (shouldRetry(error) && retries !== manager.options.retries) {
        return null;
      }
      throw error;
    } finally {
      clearTimeout(timeout);
    }
    if (manager.listenerCount("response")) {
      manager.emit("response", {
        method: options.method ?? "get",
        path: routeId.original,
        route: routeId.bucketRoute,
        options,
        data: requestData,
        retries
      }, res instanceof Response ? res.clone() : { ...res });
    }
    return res;
  }
  async function handleErrors(manager, res, method, url, requestData, retries) {
    const status = res.status;
    if (status >= 500 && status < 600) {
      if (retries !== manager.options.retries) {
        return null;
      }
      throw new HTTPError(status, res.statusText, method, url, requestData);
    } else {
      if (status >= 400 && status < 500) {
        if (status === 401 && requestData.auth) {
          manager.setToken(null);
        }
        const data = await parseResponse(res);
        throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
      }
      return res;
    }
  }
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
    ALLOWED_SIZES: () => ALLOWED_SIZES,
    ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
    BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
    CDN: () => CDN,
    DEPRECATION_WARNING_PREFIX: () => DEPRECATION_WARNING_PREFIX,
    DefaultRestOptions: () => DefaultRestOptions,
    DefaultUserAgent: () => DefaultUserAgent,
    DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,
    DiscordAPIError: () => DiscordAPIError,
    HTTPError: () => HTTPError,
    OverwrittenMimeTypes: () => OverwrittenMimeTypes,
    REST: () => REST,
    RESTEvents: () => RESTEvents,
    RateLimitError: () => RateLimitError,
    RequestMethod: () => RequestMethod,
    calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,
    makeURLSearchParams: () => makeURLSearchParams,
    parseResponse: () => parseResponse,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var import_node_buffer = import.meta.require("buffer");
  var import_util2 = require_dist();
  var import_undici2 = import.meta.require("undici");
  var defaultStrategy;
  __name(setDefaultStrategy, "setDefaultStrategy");
  __name(getDefaultStrategy, "getDefaultStrategy");
  var import_node_http = import.meta.require("http");
  var import_node_url = import.meta.require("url");
  var import_node_util = import.meta.require("util");
  var import_undici = import.meta.require("undici");
  __name(makeRequest, "makeRequest");
  __name(resolveBody, "resolveBody");
  var import_v102 = require_v106();
  var import_util = require_dist();
  var import_v10 = require_v106();
  var DefaultUserAgent = `DiscordBot (https://discord.js.org, 2.5.0)`;
  var DefaultUserAgentAppendix = (0, import_util.getUserAgentAppendix)();
  var DefaultRestOptions = {
    agent: null,
    api: "https://discord.com/api",
    authPrefix: "Bot",
    cdn: "https://cdn.discordapp.com",
    headers: {},
    invalidRequestWarningInterval: 0,
    globalRequestsPerSecond: 50,
    offset: 50,
    rejectOnRateLimit: null,
    retries: 3,
    timeout: 15000,
    userAgentAppendix: DefaultUserAgentAppendix,
    version: import_v10.APIVersion,
    hashSweepInterval: 14400000,
    hashLifetime: 86400000,
    handlerSweepInterval: 3600000,
    async makeRequest(...args) {
      return getDefaultStrategy()(...args);
    },
    mediaProxy: "https://media.discordapp.net"
  };
  var RESTEvents = ((RESTEvents2) => {
    RESTEvents2["Debug"] = "restDebug";
    RESTEvents2["HandlerSweep"] = "handlerSweep";
    RESTEvents2["HashSweep"] = "hashSweep";
    RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
    RESTEvents2["RateLimited"] = "rateLimited";
    RESTEvents2["Response"] = "response";
    return RESTEvents2;
  })(RESTEvents || {});
  var ALLOWED_EXTENSIONS = ["webp", "png", "jpg", "jpeg", "gif"];
  var ALLOWED_STICKER_EXTENSIONS = ["png", "json", "gif"];
  var ALLOWED_SIZES = [
    16,
    32,
    64,
    128,
    256,
    512,
    1024,
    2048,
    4096
  ];
  var OverwrittenMimeTypes = {
    "image/apng": "image/png"
  };
  var BurstHandlerMajorIdKey = "burst";
  var DEPRECATION_WARNING_PREFIX = "DeprecationWarning";
  var RateLimitError = class _RateLimitError extends Error {
    static {
      __name(this, "RateLimitError");
    }
    timeToReset;
    limit;
    method;
    hash;
    url;
    route;
    majorParameter;
    global;
    retryAfter;
    sublimitTimeout;
    scope;
    constructor({
      timeToReset,
      limit,
      method,
      hash,
      url,
      route,
      majorParameter,
      global: global2,
      retryAfter,
      sublimitTimeout,
      scope
    }) {
      super();
      this.timeToReset = timeToReset;
      this.limit = limit;
      this.method = method;
      this.hash = hash;
      this.url = url;
      this.route = route;
      this.majorParameter = majorParameter;
      this.global = global2;
      this.retryAfter = retryAfter;
      this.sublimitTimeout = sublimitTimeout;
      this.scope = scope;
    }
    get name() {
      return `${_RateLimitError.name}[${this.route}]`;
    }
  };
  var RequestMethod = ((RequestMethod2) => {
    RequestMethod2["Delete"] = "DELETE";
    RequestMethod2["Get"] = "GET";
    RequestMethod2["Patch"] = "PATCH";
    RequestMethod2["Post"] = "POST";
    RequestMethod2["Put"] = "PUT";
    return RequestMethod2;
  })(RequestMethod || {});
  __name(serializeSearchParam, "serializeSearchParam");
  __name(makeURLSearchParams, "makeURLSearchParams");
  __name(parseResponse, "parseResponse");
  __name(hasSublimit, "hasSublimit");
  __name(shouldRetry, "shouldRetry");
  __name(onRateLimit, "onRateLimit");
  __name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
  __name(sleep, "sleep");
  __name(isBufferLike, "isBufferLike");
  __name(deprecationWarning, "deprecationWarning");
  __name(normalizeRateLimitOffset, "normalizeRateLimitOffset");
  var deprecationEmittedForEmoji = false;
  var CDN = class {
    constructor(cdn = DefaultRestOptions.cdn, mediaProxy = DefaultRestOptions.mediaProxy) {
      this.cdn = cdn;
      this.mediaProxy = mediaProxy;
    }
    static {
      __name(this, "CDN");
    }
    appAsset(clientId, assetHash, options) {
      return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
    }
    appIcon(clientId, iconHash, options) {
      return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
    }
    avatar(id, avatarHash, options) {
      return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
    }
    avatarDecoration(userIdOrAsset, userAvatarDecoration, options) {
      if (userAvatarDecoration) {
        return this.makeURL(`/avatar-decorations/${userIdOrAsset}/${userAvatarDecoration}`, options);
      }
      return this.makeURL(`/avatar-decoration-presets/${userIdOrAsset}`, { extension: "png" });
    }
    banner(id, bannerHash, options) {
      return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
    }
    channelIcon(channelId, iconHash, options) {
      return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
    }
    defaultAvatar(index) {
      return this.makeURL(`/embed/avatars/${index}`, { extension: "png" });
    }
    discoverySplash(guildId, splashHash, options) {
      return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
    }
    emoji(emojiId, options) {
      let resolvedOptions;
      if (typeof options === "string") {
        if (!deprecationEmittedForEmoji) {
          deprecationWarning("Passing a string for the second parameter of CDN#emoji() is deprecated. Use an object instead.");
          deprecationEmittedForEmoji = true;
        }
        resolvedOptions = { extension: options };
      } else {
        resolvedOptions = options;
      }
      return this.makeURL(`/emojis/${emojiId}`, resolvedOptions);
    }
    guildMemberAvatar(guildId, userId, avatarHash, options) {
      return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
    }
    guildMemberBanner(guildId, userId, bannerHash, options) {
      return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banners/${bannerHash}`, bannerHash, options);
    }
    icon(id, iconHash, options) {
      return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
    }
    roleIcon(roleId, roleIconHash, options) {
      return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
    }
    splash(guildId, splashHash, options) {
      return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
    }
    sticker(stickerId, extension = "png") {
      return this.makeURL(`/stickers/${stickerId}`, {
        allowedExtensions: ALLOWED_STICKER_EXTENSIONS,
        base: extension === "gif" ? this.mediaProxy : this.cdn,
        extension
      });
    }
    stickerPackBanner(bannerId, options) {
      return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
    }
    teamIcon(teamId, iconHash, options) {
      return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
    }
    guildScheduledEventCover(scheduledEventId, coverHash, options) {
      return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
    }
    soundboardSound(soundId) {
      return `${this.cdn}${import_v102.CDNRoutes.soundboardSound(soundId)}`;
    }
    dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
      return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? { ...options, extension: "gif" } : options);
    }
    makeURL(route, {
      allowedExtensions = ALLOWED_EXTENSIONS,
      base = this.cdn,
      extension = "webp",
      size
    } = {}) {
      extension = String(extension).toLowerCase();
      if (!allowedExtensions.includes(extension)) {
        throw new RangeError(`Invalid extension provided: ${extension}
Must be one of: ${allowedExtensions.join(", ")}`);
      }
      if (size && !ALLOWED_SIZES.includes(size)) {
        throw new RangeError(`Invalid size provided: ${size}
Must be one of: ${ALLOWED_SIZES.join(", ")}`);
      }
      const url = new URL(`${base}${route}.${extension}`);
      if (size) {
        url.searchParams.set("size", String(size));
      }
      return url.toString();
    }
  };
  __name(isErrorGroupWrapper, "isErrorGroupWrapper");
  __name(isErrorResponse, "isErrorResponse");
  var DiscordAPIError = class _DiscordAPIError extends Error {
    constructor(rawError, code, status, method, url, bodyData) {
      super(_DiscordAPIError.getMessage(rawError));
      this.rawError = rawError;
      this.code = code;
      this.status = status;
      this.method = method;
      this.url = url;
      this.requestBody = { files: bodyData.files, json: bodyData.body };
    }
    static {
      __name(this, "DiscordAPIError");
    }
    requestBody;
    get name() {
      return `${_DiscordAPIError.name}[${this.code}]`;
    }
    static getMessage(error) {
      let flattened = "";
      if ("code" in error) {
        if (error.errors) {
          flattened = [...this.flattenDiscordError(error.errors)].join("\n");
        }
        return error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened || "Unknown Error";
      }
      return error.error_description ?? "No Description";
    }
    static *flattenDiscordError(obj, key = "") {
      if (isErrorResponse(obj)) {
        return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
      }
      for (const [otherKey, val] of Object.entries(obj)) {
        const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
        if (typeof val === "string") {
          yield val;
        } else if (isErrorGroupWrapper(val)) {
          for (const error of val._errors) {
            yield* this.flattenDiscordError(error, nextKey);
          }
        } else {
          yield* this.flattenDiscordError(val, nextKey);
        }
      }
    }
  };
  var HTTPError = class _HTTPError extends Error {
    constructor(status, statusText, method, url, bodyData) {
      super(statusText);
      this.status = status;
      this.method = method;
      this.url = url;
      this.requestBody = { files: bodyData.files, json: bodyData.body };
    }
    static {
      __name(this, "HTTPError");
    }
    requestBody;
    name = _HTTPError.name;
  };
  var import_collection = require_dist2();
  var import_snowflake = require_cjs();
  var import_async_event_emitter = require_dist3();
  var import_magic_bytes = require_dist4();
  var invalidCount = 0;
  var invalidCountResetTime = null;
  __name(incrementInvalidCount, "incrementInvalidCount");
  __name(makeNetworkRequest, "makeNetworkRequest");
  __name(handleErrors, "handleErrors");
  var BurstHandler = class {
    constructor(manager, hash, majorParameter) {
      this.manager = manager;
      this.hash = hash;
      this.majorParameter = majorParameter;
      this.id = `${hash}:${majorParameter}`;
    }
    static {
      __name(this, "BurstHandler");
    }
    id;
    inactive = false;
    debug(message) {
      this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
    }
    async queueRequest(routeId, url, options, requestData) {
      return this.runRequest(routeId, url, options, requestData);
    }
    async runRequest(routeId, url, options, requestData, retries = 0) {
      const method = options.method ?? "get";
      const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
      if (res === null) {
        return this.runRequest(routeId, url, options, requestData, ++retries);
      }
      const status = res.status;
      let retryAfter = 0;
      const retry = res.headers.get("Retry-After");
      const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
      if (retry)
        retryAfter = Number(retry) * 1000 + offset;
      if (status === 401 || status === 403 || status === 429) {
        incrementInvalidCount(this.manager);
      }
      if (status >= 200 && status < 300) {
        return res;
      } else if (status === 429) {
        const isGlobal = res.headers.has("X-RateLimit-Global");
        const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
        await onRateLimit(this.manager, {
          global: isGlobal,
          method,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: Number.POSITIVE_INFINITY,
          timeToReset: retryAfter,
          retryAfter,
          sublimitTimeout: 0,
          scope
        });
        this.debug([
          "Encountered unexpected 429 rate limit",
          `  Global         : ${isGlobal}`,
          `  Method         : ${method}`,
          `  URL            : ${url}`,
          `  Bucket         : ${routeId.bucketRoute}`,
          `  Major parameter: ${routeId.majorParameter}`,
          `  Hash           : ${this.hash}`,
          `  Limit          : ${Number.POSITIVE_INFINITY}`,
          `  Retry After    : ${retryAfter}ms`,
          `  Sublimit       : None`,
          `  Scope          : ${scope}`
        ].join("\n"));
        await sleep(retryAfter);
        return this.runRequest(routeId, url, options, requestData, retries);
      } else {
        const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
        if (handled === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        return handled;
      }
    }
  };
  var import_async_queue = require_cjs2();
  var SequentialHandler = class {
    constructor(manager, hash, majorParameter) {
      this.manager = manager;
      this.hash = hash;
      this.majorParameter = majorParameter;
      this.id = `${hash}:${majorParameter}`;
    }
    static {
      __name(this, "SequentialHandler");
    }
    id;
    reset = -1;
    remaining = 1;
    limit = Number.POSITIVE_INFINITY;
    #asyncQueue = new import_async_queue.AsyncQueue;
    #sublimitedQueue = null;
    #sublimitPromise = null;
    #shiftSublimit = false;
    get inactive() {
      return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;
    }
    get globalLimited() {
      return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
    }
    get localLimited() {
      return this.remaining <= 0 && Date.now() < this.reset;
    }
    get limited() {
      return this.globalLimited || this.localLimited;
    }
    getTimeToReset(routeId) {
      const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
      return this.reset + offset - Date.now();
    }
    debug(message) {
      this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
    }
    async globalDelayFor(time) {
      await sleep(time);
      this.manager.globalDelay = null;
    }
    async queueRequest(routeId, url, options, requestData) {
      let queue = this.#asyncQueue;
      let queueType = 0;
      if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
        queue = this.#sublimitedQueue;
        queueType = 1;
      }
      await queue.wait({ signal: requestData.signal });
      if (queueType === 0) {
        if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
          queue = this.#sublimitedQueue;
          const wait = queue.wait();
          this.#asyncQueue.shift();
          await wait;
        } else if (this.#sublimitPromise) {
          await this.#sublimitPromise.promise;
        }
      }
      try {
        return await this.runRequest(routeId, url, options, requestData);
      } finally {
        queue.shift();
        if (this.#shiftSublimit) {
          this.#shiftSublimit = false;
          this.#sublimitedQueue?.shift();
        }
        if (this.#sublimitedQueue?.remaining === 0) {
          this.#sublimitPromise?.resolve();
          this.#sublimitedQueue = null;
        }
      }
    }
    async runRequest(routeId, url, options, requestData, retries = 0) {
      while (this.limited) {
        const isGlobal = this.globalLimited;
        let limit2;
        let timeout;
        let delay;
        if (isGlobal) {
          const offset2 = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
          limit2 = this.manager.options.globalRequestsPerSecond;
          timeout = this.manager.globalReset + offset2 - Date.now();
          if (!this.manager.globalDelay) {
            this.manager.globalDelay = this.globalDelayFor(timeout);
          }
          delay = this.manager.globalDelay;
        } else {
          limit2 = this.limit;
          timeout = this.getTimeToReset(routeId);
          delay = sleep(timeout);
        }
        const rateLimitData = {
          global: isGlobal,
          method: options.method ?? "get",
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: limit2,
          timeToReset: timeout,
          retryAfter: timeout,
          sublimitTimeout: 0,
          scope: "user"
        };
        this.manager.emit("rateLimited", rateLimitData);
        await onRateLimit(this.manager, rateLimitData);
        if (isGlobal) {
          this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
        } else {
          this.debug(`Waiting ${timeout}ms for rate limit to pass`);
        }
        await delay;
      }
      if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
        this.manager.globalReset = Date.now() + 1000;
        this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
      }
      this.manager.globalRemaining--;
      const method = options.method ?? "get";
      const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
      if (res === null) {
        return this.runRequest(routeId, url, options, requestData, ++retries);
      }
      const status = res.status;
      let retryAfter = 0;
      const limit = res.headers.get("X-RateLimit-Limit");
      const remaining = res.headers.get("X-RateLimit-Remaining");
      const reset = res.headers.get("X-RateLimit-Reset-After");
      const hash = res.headers.get("X-RateLimit-Bucket");
      const retry = res.headers.get("Retry-After");
      const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
      const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
      this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
      this.remaining = remaining ? Number(remaining) : 1;
      this.reset = reset ? Number(reset) * 1000 + Date.now() + offset : Date.now();
      if (retry)
        retryAfter = Number(retry) * 1000 + offset;
      if (hash && hash !== this.hash) {
        this.debug(["Received bucket hash update", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join("\n"));
        this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });
      } else if (hash) {
        const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
        if (hashData) {
          hashData.lastAccess = Date.now();
        }
      }
      let sublimitTimeout = null;
      if (retryAfter > 0) {
        if (res.headers.has("X-RateLimit-Global")) {
          this.manager.globalRemaining = 0;
          this.manager.globalReset = Date.now() + retryAfter;
        } else if (!this.localLimited) {
          sublimitTimeout = retryAfter;
        }
      }
      if (status === 401 || status === 403 || status === 429) {
        incrementInvalidCount(this.manager);
      }
      if (res.ok) {
        return res;
      } else if (status === 429) {
        const isGlobal = this.globalLimited;
        let limit2;
        let timeout;
        if (isGlobal) {
          const offset2 = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
          limit2 = this.manager.options.globalRequestsPerSecond;
          timeout = this.manager.globalReset + offset2 - Date.now();
        } else {
          limit2 = this.limit;
          timeout = this.getTimeToReset(routeId);
        }
        await onRateLimit(this.manager, {
          global: isGlobal,
          method,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: limit2,
          timeToReset: timeout,
          retryAfter,
          sublimitTimeout: sublimitTimeout ?? 0,
          scope
        });
        this.debug([
          "Encountered unexpected 429 rate limit",
          `  Global         : ${isGlobal.toString()}`,
          `  Method         : ${method}`,
          `  URL            : ${url}`,
          `  Bucket         : ${routeId.bucketRoute}`,
          `  Major parameter: ${routeId.majorParameter}`,
          `  Hash           : ${this.hash}`,
          `  Limit          : ${limit2}`,
          `  Retry After    : ${retryAfter}ms`,
          `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`,
          `  Scope          : ${scope}`
        ].join("\n"));
        if (sublimitTimeout) {
          const firstSublimit = !this.#sublimitedQueue;
          if (firstSublimit) {
            this.#sublimitedQueue = new import_async_queue.AsyncQueue;
            this.#sublimitedQueue.wait();
            this.#asyncQueue.shift();
          }
          this.#sublimitPromise?.resolve();
          this.#sublimitPromise = null;
          await sleep(sublimitTimeout);
          let resolve;
          const promise = new Promise((res2) => resolve = res2);
          this.#sublimitPromise = { promise, resolve };
          if (firstSublimit) {
            await this.#asyncQueue.wait();
            this.#shiftSublimit = true;
          }
        }
        return this.runRequest(routeId, url, options, requestData, retries);
      } else {
        const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
        if (handled === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        return handled;
      }
    }
  };
  var REST = class _REST extends import_async_event_emitter.AsyncEventEmitter {
    static {
      __name(this, "REST");
    }
    agent = null;
    cdn;
    globalRemaining;
    globalDelay = null;
    globalReset = -1;
    hashes = new import_collection.Collection;
    handlers = new import_collection.Collection;
    #token = null;
    hashTimer;
    handlerTimer;
    options;
    constructor(options = {}) {
      super();
      this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn, options.mediaProxy ?? DefaultRestOptions.mediaProxy);
      this.options = { ...DefaultRestOptions, ...options };
      this.globalRemaining = Math.max(1, this.options.globalRequestsPerSecond);
      this.agent = options.agent ?? null;
      this.setupSweepers();
    }
    setupSweepers() {
      const validateMaxInterval = __name((interval) => {
        if (interval > 14400000) {
          throw new Error("Cannot set an interval greater than 4 hours");
        }
      }, "validateMaxInterval");
      if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
        validateMaxInterval(this.options.hashSweepInterval);
        this.hashTimer = setInterval(() => {
          const sweptHashes = new import_collection.Collection;
          const currentDate = Date.now();
          this.hashes.sweep((val, key) => {
            if (val.lastAccess === -1)
              return false;
            const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
            if (shouldSweep) {
              sweptHashes.set(key, val);
              this.emit("restDebug", `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
            }
            return shouldSweep;
          });
          this.emit("hashSweep", sweptHashes);
        }, this.options.hashSweepInterval);
        this.hashTimer.unref?.();
      }
      if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
        validateMaxInterval(this.options.handlerSweepInterval);
        this.handlerTimer = setInterval(() => {
          const sweptHandlers = new import_collection.Collection;
          this.handlers.sweep((val, key) => {
            const { inactive } = val;
            if (inactive) {
              sweptHandlers.set(key, val);
              this.emit("restDebug", `Handler ${val.id} for ${key} swept due to being inactive`);
            }
            return inactive;
          });
          this.emit("handlerSweep", sweptHandlers);
        }, this.options.handlerSweepInterval);
        this.handlerTimer.unref?.();
      }
    }
    async get(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "GET" });
    }
    async delete(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "DELETE" });
    }
    async post(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "POST" });
    }
    async put(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "PUT" });
    }
    async patch(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "PATCH" });
    }
    async request(options) {
      const response = await this.queueRequest(options);
      return parseResponse(response);
    }
    setAgent(agent) {
      this.agent = agent;
      return this;
    }
    setToken(token) {
      this.#token = token;
      return this;
    }
    async queueRequest(request2) {
      const routeId = _REST.generateRouteData(request2.fullRoute, request2.method);
      const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
        value: `Global(${request2.method}:${routeId.bucketRoute})`,
        lastAccess: -1
      };
      const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
      const { url, fetchOptions } = await this.resolveRequest(request2);
      return handler.queueRequest(routeId, url, fetchOptions, {
        body: request2.body,
        files: request2.files,
        auth: request2.auth !== false,
        signal: request2.signal
      });
    }
    createHandler(hash, majorParameter) {
      const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
      this.handlers.set(queue.id, queue);
      return queue;
    }
    async resolveRequest(request2) {
      const { options } = this;
      let query = "";
      if (request2.query) {
        const resolvedQuery = request2.query.toString();
        if (resolvedQuery !== "") {
          query = `?${resolvedQuery}`;
        }
      }
      const headers = {
        ...this.options.headers,
        "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
      };
      if (request2.auth !== false) {
        if (!this.#token) {
          throw new Error("Expected token to be set for this request, but none was present");
        }
        headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;
      }
      if (request2.reason?.length) {
        headers["X-Audit-Log-Reason"] = encodeURIComponent(request2.reason);
      }
      const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
      let finalBody;
      let additionalHeaders = {};
      if (request2.files?.length) {
        const formData = new FormData;
        for (const [index, file] of request2.files.entries()) {
          const fileKey = file.key ?? `files[${index}]`;
          if (isBufferLike(file.data)) {
            let contentType = file.contentType;
            if (!contentType) {
              const [parsedType] = (0, import_magic_bytes.filetypeinfo)(file.data);
              if (parsedType) {
                contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
              }
            }
            formData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);
          } else {
            formData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);
          }
        }
        if (request2.body != null) {
          if (request2.appendToFormData) {
            for (const [key, value] of Object.entries(request2.body)) {
              formData.append(key, value);
            }
          } else {
            formData.append("payload_json", JSON.stringify(request2.body));
          }
        }
        finalBody = formData;
      } else if (request2.body != null) {
        if (request2.passThroughBody) {
          finalBody = request2.body;
        } else {
          finalBody = JSON.stringify(request2.body);
          additionalHeaders = { "Content-Type": "application/json" };
        }
      }
      const method = request2.method.toUpperCase();
      const fetchOptions = {
        body: ["GET", "HEAD"].includes(method) ? null : finalBody,
        headers: { ...request2.headers, ...additionalHeaders, ...headers },
        method,
        dispatcher: request2.dispatcher ?? this.agent ?? undefined
      };
      return { url, fetchOptions };
    }
    clearHashSweeper() {
      clearInterval(this.hashTimer);
    }
    clearHandlerSweeper() {
      clearInterval(this.handlerTimer);
    }
    static generateRouteData(endpoint, method) {
      if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
        return {
          majorParameter: BurstHandlerMajorIdKey,
          bucketRoute: "/interactions/:id/:token/callback",
          original: endpoint
        };
      }
      const majorIdMatch = /(?:^\/webhooks\/(\d{17,19}\/[^/?]+))|(?:^\/(?:channels|guilds|webhooks)\/(\d{17,19}))/.exec(endpoint);
      const majorId = majorIdMatch?.[2] ?? majorIdMatch?.[1] ?? "global";
      const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction").replace(/\/webhooks\/:id\/[^/?]+/, "/webhooks/:id/:token");
      let exceptions = "";
      if (method === "DELETE" && baseRoute === "/channels/:id/messages/:id") {
        const id = /\d{17,19}$/.exec(endpoint)[0];
        const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
        if (Date.now() - timestamp > 1000 * 60 * 60 * 24 * 14) {
          exceptions += "/Delete Old Message";
        }
      }
      return {
        majorParameter: majorId,
        bucketRoute: baseRoute + exceptions,
        original: endpoint
      };
    }
  };
  var version = "2.5.0";
  globalThis.FormData ??= import_undici2.FormData;
  globalThis.Blob ??= import_node_buffer.Blob;
  setDefaultStrategy((0, import_util2.shouldUseGlobalFetchAndWebSocket)() ? fetch : makeRequest);
});

// node_modules/discord.js/src/errors/ErrorCodes.js
var require_ErrorCodes = __commonJS((exports, module) => {
  var keys = [
    "ClientInvalidOption",
    "ClientInvalidProvidedShards",
    "ClientMissingIntents",
    "ClientNotReady",
    "TokenInvalid",
    "TokenMissing",
    "ApplicationCommandPermissionsTokenMissing",
    "WSCloseRequested",
    "WSConnectionExists",
    "WSNotOpen",
    "ManagerDestroyed",
    "BitFieldInvalid",
    "ShardingInvalid",
    "ShardingRequired",
    "InvalidIntents",
    "DisallowedIntents",
    "ShardingNoShards",
    "ShardingInProcess",
    "ShardingInvalidEvalBroadcast",
    "ShardingShardNotFound",
    "ShardingAlreadySpawned",
    "ShardingProcessExists",
    "ShardingWorkerExists",
    "ShardingReadyTimeout",
    "ShardingReadyDisconnected",
    "ShardingReadyDied",
    "ShardingNoChildExists",
    "ShardingShardMiscalculation",
    "ColorRange",
    "ColorConvert",
    "InviteOptionsMissingChannel",
    "ButtonLabel",
    "ButtonURL",
    "ButtonCustomId",
    "SelectMenuCustomId",
    "SelectMenuPlaceholder",
    "SelectOptionLabel",
    "SelectOptionValue",
    "SelectOptionDescription",
    "InteractionCollectorError",
    "FileNotFound",
    "UserBannerNotFetched",
    "UserNoDMChannel",
    "VoiceNotStageChannel",
    "VoiceStateNotOwn",
    "VoiceStateInvalidType",
    "ReqResourceType",
    "ImageFormat",
    "ImageSize",
    "MessageBulkDeleteType",
    "MessageContentType",
    "MessageNonceRequired",
    "MessageNonceType",
    "SplitMaxLen",
    "BanResolveId",
    "FetchBanResolveId",
    "PruneDaysType",
    "GuildChannelResolve",
    "GuildVoiceChannelResolve",
    "GuildChannelOrphan",
    "GuildChannelUnowned",
    "GuildOwned",
    "GuildMembersTimeout",
    "GuildSoundboardSoundsTimeout",
    "GuildUncachedMe",
    "ChannelNotCached",
    "StageChannelResolve",
    "GuildScheduledEventResolve",
    "FetchOwnerId",
    "InvalidType",
    "InvalidElement",
    "MessageThreadParent",
    "MessageExistingThread",
    "ThreadInvitableType",
    "WebhookMessage",
    "WebhookTokenUnavailable",
    "WebhookURLInvalid",
    "WebhookApplication",
    "MessageReferenceMissing",
    "EmojiType",
    "EmojiManaged",
    "MissingManageGuildExpressionsPermission",
    "MissingManageEmojisAndStickersPermission",
    "NotGuildSoundboardSound",
    "NotGuildSticker",
    "ReactionResolveUser",
    "VanityURL",
    "InviteResolveCode",
    "InviteNotFound",
    "DeleteGroupDMChannel",
    "FetchGroupDMChannel",
    "MemberFetchNonceLength",
    "GlobalCommandPermissions",
    "GuildUncachedEntityResolve",
    "InteractionAlreadyReplied",
    "InteractionNotReplied",
    "InteractionEphemeralReplied",
    "CommandInteractionOptionNotFound",
    "CommandInteractionOptionType",
    "CommandInteractionOptionEmpty",
    "CommandInteractionOptionNoSubcommand",
    "CommandInteractionOptionNoSubcommandGroup",
    "CommandInteractionOptionInvalidChannelType",
    "AutocompleteInteractionOptionNoFocusedOption",
    "ModalSubmitInteractionFieldNotFound",
    "ModalSubmitInteractionFieldType",
    "InvalidMissingScopes",
    "InvalidScopesWithPermissions",
    "NotImplemented",
    "SweepFilterReturn",
    "GuildForumMessageRequired",
    "EntitlementCreateInvalidOwner",
    "BulkBanUsersOptionEmpty",
    "PollAlreadyExpired"
  ];
  module.exports = Object.fromEntries(keys.map((key) => [key, key]));
});

// node_modules/discord.js/src/errors/Messages.js
var require_Messages = __commonJS((exports, module) => {
  var DjsErrorCodes = require_ErrorCodes();
  var Messages = {
    [DjsErrorCodes.ClientInvalidOption]: (prop, must) => `The ${prop} option must be ${must}`,
    [DjsErrorCodes.ClientInvalidProvidedShards]: "None of the provided shards were valid.",
    [DjsErrorCodes.ClientMissingIntents]: "Valid intents must be provided for the Client.",
    [DjsErrorCodes.ClientNotReady]: (action) => `The client needs to be logged in to ${action}.`,
    [DjsErrorCodes.TokenInvalid]: "An invalid token was provided.",
    [DjsErrorCodes.TokenMissing]: "Request to use token, but token was unavailable to the client.",
    [DjsErrorCodes.ApplicationCommandPermissionsTokenMissing]: "Editing application command permissions requires an OAuth2 bearer token, but none was provided.",
    [DjsErrorCodes.WSCloseRequested]: "WebSocket closed due to user request.",
    [DjsErrorCodes.WSConnectionExists]: "There is already an existing WebSocket connection.",
    [DjsErrorCodes.WSNotOpen]: (data = "data") => `WebSocket not open to send ${data}`,
    [DjsErrorCodes.ManagerDestroyed]: "Manager was destroyed.",
    [DjsErrorCodes.BitFieldInvalid]: (bit) => `Invalid bitfield flag or number: ${bit}.`,
    [DjsErrorCodes.ShardingInvalid]: "Invalid shard settings were provided.",
    [DjsErrorCodes.ShardingRequired]: "This session would have handled too many guilds - Sharding is required.",
    [DjsErrorCodes.InvalidIntents]: "Invalid intent provided for WebSocket intents.",
    [DjsErrorCodes.DisallowedIntents]: "Privileged intent provided is not enabled or whitelisted.",
    [DjsErrorCodes.ShardingNoShards]: "No shards have been spawned.",
    [DjsErrorCodes.ShardingInProcess]: "Shards are still being spawned.",
    [DjsErrorCodes.ShardingInvalidEvalBroadcast]: "Script to evaluate must be a function",
    [DjsErrorCodes.ShardingShardNotFound]: (id) => `Shard ${id} could not be found.`,
    [DjsErrorCodes.ShardingAlreadySpawned]: (count) => `Already spawned ${count} shards.`,
    [DjsErrorCodes.ShardingProcessExists]: (id) => `Shard ${id} already has an active process.`,
    [DjsErrorCodes.ShardingWorkerExists]: (id) => `Shard ${id} already has an active worker.`,
    [DjsErrorCodes.ShardingReadyTimeout]: (id) => `Shard ${id}'s Client took too long to become ready.`,
    [DjsErrorCodes.ShardingReadyDisconnected]: (id) => `Shard ${id}'s Client disconnected before becoming ready.`,
    [DjsErrorCodes.ShardingReadyDied]: (id) => `Shard ${id}'s process exited before its Client became ready.`,
    [DjsErrorCodes.ShardingNoChildExists]: (id) => `Shard ${id} has no active process or worker.`,
    [DjsErrorCodes.ShardingShardMiscalculation]: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,
    [DjsErrorCodes.ColorRange]: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
    [DjsErrorCodes.ColorConvert]: (color) => `Unable to convert "${color}" to a number.`,
    [DjsErrorCodes.InviteOptionsMissingChannel]: "A valid guild channel must be provided when GuildScheduledEvent is EXTERNAL.",
    [DjsErrorCodes.ButtonLabel]: "MessageButton label must be a string",
    [DjsErrorCodes.ButtonURL]: "MessageButton URL must be a string",
    [DjsErrorCodes.ButtonCustomId]: "MessageButton customId must be a string",
    [DjsErrorCodes.SelectMenuCustomId]: "MessageSelectMenu customId must be a string",
    [DjsErrorCodes.SelectMenuPlaceholder]: "MessageSelectMenu placeholder must be a string",
    [DjsErrorCodes.SelectOptionLabel]: "MessageSelectOption label must be a string",
    [DjsErrorCodes.SelectOptionValue]: "MessageSelectOption value must be a string",
    [DjsErrorCodes.SelectOptionDescription]: "MessageSelectOption description must be a string",
    [DjsErrorCodes.InteractionCollectorError]: (reason) => `Collector received no interactions before ending with reason: ${reason}`,
    [DjsErrorCodes.FileNotFound]: (file) => `File could not be found: ${file}`,
    [DjsErrorCodes.UserBannerNotFetched]: "You must fetch this user's banner before trying to generate its URL!",
    [DjsErrorCodes.UserNoDMChannel]: "No DM Channel exists!",
    [DjsErrorCodes.VoiceNotStageChannel]: "You are only allowed to do this in stage channels.",
    [DjsErrorCodes.VoiceStateNotOwn]: "You cannot self-deafen/mute/request to speak on VoiceStates that do not belong to the ClientUser.",
    [DjsErrorCodes.VoiceStateInvalidType]: (name) => `${name} must be a boolean.`,
    [DjsErrorCodes.ReqResourceType]: "The resource must be a string, Buffer or a valid file stream.",
    [DjsErrorCodes.ImageFormat]: (format) => `Invalid image format: ${format}`,
    [DjsErrorCodes.ImageSize]: (size) => `Invalid image size: ${size}`,
    [DjsErrorCodes.MessageBulkDeleteType]: "The messages must be an Array, Collection, or number.",
    [DjsErrorCodes.MessageContentType]: "Message content must be a string.",
    [DjsErrorCodes.MessageNonceRequired]: "Message nonce is required when enforceNonce is true.",
    [DjsErrorCodes.MessageNonceType]: "Message nonce must be an integer or a string.",
    [DjsErrorCodes.SplitMaxLen]: "Chunk exceeds the max length and contains no split characters.",
    [DjsErrorCodes.BanResolveId]: (ban = false) => `Couldn't resolve the user id to ${ban ? "ban" : "unban"}.`,
    [DjsErrorCodes.FetchBanResolveId]: "Couldn't resolve the user id to fetch the ban.",
    [DjsErrorCodes.PruneDaysType]: "Days must be a number",
    [DjsErrorCodes.GuildChannelResolve]: "Could not resolve channel to a guild channel.",
    [DjsErrorCodes.GuildVoiceChannelResolve]: "Could not resolve channel to a guild voice channel.",
    [DjsErrorCodes.GuildChannelOrphan]: "Could not find a parent to this guild channel.",
    [DjsErrorCodes.GuildChannelUnowned]: "The fetched channel does not belong to this manager's guild.",
    [DjsErrorCodes.GuildOwned]: "Guild is owned by the client.",
    [DjsErrorCodes.GuildMembersTimeout]: "Members didn't arrive in time.",
    [DjsErrorCodes.GuildSoundboardSoundsTimeout]: "Soundboard sounds didn't arrive in time.",
    [DjsErrorCodes.GuildUncachedMe]: "The client user as a member of this guild is uncached.",
    [DjsErrorCodes.ChannelNotCached]: "Could not find the channel where this message came from in the cache!",
    [DjsErrorCodes.StageChannelResolve]: "Could not resolve channel to a stage channel.",
    [DjsErrorCodes.GuildScheduledEventResolve]: "Could not resolve the guild scheduled event.",
    [DjsErrorCodes.FetchOwnerId]: (type) => `Couldn't resolve the ${type} ownerId to fetch the ${type} ${type === "group DM" ? "owner" : "member"}.`,
    [DjsErrorCodes.InvalidType]: (name, expected, an = false) => `Supplied ${name} is not a${an ? "n" : ""} ${expected}.`,
    [DjsErrorCodes.InvalidElement]: (type, name, elem) => `Supplied ${type} ${name} includes an invalid element: ${elem}`,
    [DjsErrorCodes.MessageThreadParent]: "The message was not sent in a guild text or news channel",
    [DjsErrorCodes.MessageExistingThread]: "The message already has a thread",
    [DjsErrorCodes.ThreadInvitableType]: (type) => `Invitable cannot be edited on ${type}`,
    [DjsErrorCodes.WebhookMessage]: "The message was not sent by a webhook.",
    [DjsErrorCodes.WebhookTokenUnavailable]: "This action requires a webhook token, but none is available.",
    [DjsErrorCodes.WebhookURLInvalid]: "The provided webhook URL is not valid.",
    [DjsErrorCodes.WebhookApplication]: "This message webhook belongs to an application and cannot be fetched.",
    [DjsErrorCodes.MessageReferenceMissing]: "The message does not reference another message",
    [DjsErrorCodes.EmojiType]: "Emoji must be a string or GuildEmoji/ReactionEmoji",
    [DjsErrorCodes.EmojiManaged]: "Emoji is managed and has no Author.",
    [DjsErrorCodes.MissingManageGuildExpressionsPermission]: (guild) => `Client must have Manage Guild Expressions permission in guild ${guild} to see emoji authors.`,
    [DjsErrorCodes.MissingManageEmojisAndStickersPermission]: (guild) => `Client must have Manage Emojis and Stickers permission in guild ${guild} to see emoji authors.`,
    [DjsErrorCodes.NotGuildSoundboardSound]: (action) => `Soundboard sound is a default (non-guild) soundboard sound and can't be ${action}.`,
    [DjsErrorCodes.NotGuildSticker]: "Sticker is a standard (non-guild) sticker and has no author.",
    [DjsErrorCodes.ReactionResolveUser]: "Couldn't resolve the user id to remove from the reaction.",
    [DjsErrorCodes.VanityURL]: "This guild does not have the vanity URL feature enabled.",
    [DjsErrorCodes.InviteResolveCode]: "Could not resolve the code to fetch the invite.",
    [DjsErrorCodes.InviteNotFound]: "Could not find the requested invite.",
    [DjsErrorCodes.DeleteGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot delete them",
    [DjsErrorCodes.FetchGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot fetch them",
    [DjsErrorCodes.MemberFetchNonceLength]: "Nonce length must not exceed 32 characters.",
    [DjsErrorCodes.GlobalCommandPermissions]: "Permissions for global commands may only be fetched or modified by providing a GuildResolvable " + "or from a guild's application command manager.",
    [DjsErrorCodes.GuildUncachedEntityResolve]: (type) => `Cannot resolve ${type} from an arbitrary guild, provide an id instead`,
    [DjsErrorCodes.InteractionAlreadyReplied]: "The reply to this interaction has already been sent or deferred.",
    [DjsErrorCodes.InteractionNotReplied]: "The reply to this interaction has not been sent or deferred.",
    [DjsErrorCodes.InteractionEphemeralReplied]: "Ephemeral responses cannot be deleted.",
    [DjsErrorCodes.CommandInteractionOptionNotFound]: (name) => `Required option "${name}" not found.`,
    [DjsErrorCodes.CommandInteractionOptionType]: (name, type, expected) => `Option "${name}" is of type: ${type}; expected ${expected}.`,
    [DjsErrorCodes.CommandInteractionOptionEmpty]: (name, type) => `Required option "${name}" is of type: ${type}; expected a non-empty value.`,
    [DjsErrorCodes.CommandInteractionOptionNoSubcommand]: "No subcommand specified for interaction.",
    [DjsErrorCodes.CommandInteractionOptionNoSubcommandGroup]: "No subcommand group specified for interaction.",
    [DjsErrorCodes.CommandInteractionOptionInvalidChannelType]: (name, type, expected) => `The type of channel of the option "${name}" is: ${type}; expected ${expected}.`,
    [DjsErrorCodes.AutocompleteInteractionOptionNoFocusedOption]: "No focused option for autocomplete interaction.",
    [DjsErrorCodes.ModalSubmitInteractionFieldNotFound]: (customId) => `Required field with custom id "${customId}" not found.`,
    [DjsErrorCodes.ModalSubmitInteractionFieldType]: (customId, type, expected) => `Field with custom id "${customId}" is of type: ${type}; expected ${expected}.`,
    [DjsErrorCodes.InvalidMissingScopes]: "At least one valid scope must be provided for the invite",
    [DjsErrorCodes.InvalidScopesWithPermissions]: "Permissions cannot be set without the bot scope.",
    [DjsErrorCodes.NotImplemented]: (what, name) => `Method ${what} not implemented on ${name}.`,
    [DjsErrorCodes.SweepFilterReturn]: "The return value of the sweepFilter function was not false or a Function",
    [DjsErrorCodes.GuildForumMessageRequired]: "You must provide a message to create a guild forum thread",
    [DjsErrorCodes.EntitlementCreateInvalidOwner]: "You must provide either a guild or a user to create an entitlement, but not both",
    [DjsErrorCodes.BulkBanUsersOptionEmpty]: 'Option "users" array or collection is empty',
    [DjsErrorCodes.PollAlreadyExpired]: "This poll has already expired."
  };
  module.exports = Messages;
});

// node_modules/discord.js/src/errors/DJSError.js
var require_DJSError = __commonJS((exports, module) => {
  var makeDiscordjsError = function(Base) {
    return class DiscordjsError extends Base {
      constructor(code, ...args) {
        super(message(code, args));
        this.code = code;
        Error.captureStackTrace?.(this, DiscordjsError);
      }
      get name() {
        return `${super.name} [${this.code}]`;
      }
    };
  };
  var message = function(code, args) {
    if (!(code in ErrorCodes))
      throw new Error("Error code must be a valid DiscordjsErrorCodes");
    const msg = Messages[code];
    if (!msg)
      throw new Error(`No message associated with error code: ${code}.`);
    if (typeof msg === "function")
      return msg(...args);
    if (!args?.length)
      return msg;
    args.unshift(msg);
    return String(...args);
  };
  var ErrorCodes = require_ErrorCodes();
  var Messages = require_Messages();
  module.exports = {
    DiscordjsError: makeDiscordjsError(Error),
    DiscordjsTypeError: makeDiscordjsError(TypeError),
    DiscordjsRangeError: makeDiscordjsError(RangeError)
  };
});

// node_modules/discord.js/src/errors/index.js
var require_errors = __commonJS((exports, module) => {
  module.exports = require_DJSError();
  module.exports.ErrorCodes = require_ErrorCodes();
  module.exports.Messages = require_Messages();
});

// node_modules/lodash.snakecase/index.js
var require_lodash = __commonJS((exports, module) => {
  var arrayReduce = function(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  };
  var asciiWords = function(string) {
    return string.match(reAsciiWord) || [];
  };
  var basePropertyOf = function(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  };
  var hasUnicodeWord = function(string) {
    return reHasUnicodeWord.test(string);
  };
  var unicodeWords = function(string) {
    return string.match(reUnicodeWord) || [];
  };
  var baseToString = function(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  };
  var createCompounder = function(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  };
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  };
  var toString = function(value) {
    return value == null ? "" : baseToString(value);
  };
  var deburr = function(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  };
  var words = function(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;
    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  };
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsDingbatRange = "\\u2700-\\u27bf";
  var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
  var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
  var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
  var rsPunctuationRange = "\\u2000-\\u206f";
  var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
  var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "['\u2019]";
  var rsBreak = "[" + rsBreakRange + "]";
  var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
  var rsDigits = "\\d+";
  var rsDingbat = "[" + rsDingbatRange + "]";
  var rsLower = "[" + rsLowerRange + "]";
  var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
  var rsNonAstral = "[^" + rsAstralRange + "]";
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsUpper = "[" + rsUpperRange + "]";
  var rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
  var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
  var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
  var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
  var reOptMod = rsModifier + "?";
  var rsOptVar = "[" + rsVarRange + "]?";
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    "\xC0": "A",
    "\xC1": "A",
    "\xC2": "A",
    "\xC3": "A",
    "\xC4": "A",
    "\xC5": "A",
    "\xE0": "a",
    "\xE1": "a",
    "\xE2": "a",
    "\xE3": "a",
    "\xE4": "a",
    "\xE5": "a",
    "\xC7": "C",
    "\xE7": "c",
    "\xD0": "D",
    "\xF0": "d",
    "\xC8": "E",
    "\xC9": "E",
    "\xCA": "E",
    "\xCB": "E",
    "\xE8": "e",
    "\xE9": "e",
    "\xEA": "e",
    "\xEB": "e",
    "\xCC": "I",
    "\xCD": "I",
    "\xCE": "I",
    "\xCF": "I",
    "\xEC": "i",
    "\xED": "i",
    "\xEE": "i",
    "\xEF": "i",
    "\xD1": "N",
    "\xF1": "n",
    "\xD2": "O",
    "\xD3": "O",
    "\xD4": "O",
    "\xD5": "O",
    "\xD6": "O",
    "\xD8": "O",
    "\xF2": "o",
    "\xF3": "o",
    "\xF4": "o",
    "\xF5": "o",
    "\xF6": "o",
    "\xF8": "o",
    "\xD9": "U",
    "\xDA": "U",
    "\xDB": "U",
    "\xDC": "U",
    "\xF9": "u",
    "\xFA": "u",
    "\xFB": "u",
    "\xFC": "u",
    "\xDD": "Y",
    "\xFD": "y",
    "\xFF": "y",
    "\xC6": "Ae",
    "\xE6": "ae",
    "\xDE": "Th",
    "\xFE": "th",
    "\xDF": "ss",
    "\u0100": "A",
    "\u0102": "A",
    "\u0104": "A",
    "\u0101": "a",
    "\u0103": "a",
    "\u0105": "a",
    "\u0106": "C",
    "\u0108": "C",
    "\u010A": "C",
    "\u010C": "C",
    "\u0107": "c",
    "\u0109": "c",
    "\u010B": "c",
    "\u010D": "c",
    "\u010E": "D",
    "\u0110": "D",
    "\u010F": "d",
    "\u0111": "d",
    "\u0112": "E",
    "\u0114": "E",
    "\u0116": "E",
    "\u0118": "E",
    "\u011A": "E",
    "\u0113": "e",
    "\u0115": "e",
    "\u0117": "e",
    "\u0119": "e",
    "\u011B": "e",
    "\u011C": "G",
    "\u011E": "G",
    "\u0120": "G",
    "\u0122": "G",
    "\u011D": "g",
    "\u011F": "g",
    "\u0121": "g",
    "\u0123": "g",
    "\u0124": "H",
    "\u0126": "H",
    "\u0125": "h",
    "\u0127": "h",
    "\u0128": "I",
    "\u012A": "I",
    "\u012C": "I",
    "\u012E": "I",
    "\u0130": "I",
    "\u0129": "i",
    "\u012B": "i",
    "\u012D": "i",
    "\u012F": "i",
    "\u0131": "i",
    "\u0134": "J",
    "\u0135": "j",
    "\u0136": "K",
    "\u0137": "k",
    "\u0138": "k",
    "\u0139": "L",
    "\u013B": "L",
    "\u013D": "L",
    "\u013F": "L",
    "\u0141": "L",
    "\u013A": "l",
    "\u013C": "l",
    "\u013E": "l",
    "\u0140": "l",
    "\u0142": "l",
    "\u0143": "N",
    "\u0145": "N",
    "\u0147": "N",
    "\u014A": "N",
    "\u0144": "n",
    "\u0146": "n",
    "\u0148": "n",
    "\u014B": "n",
    "\u014C": "O",
    "\u014E": "O",
    "\u0150": "O",
    "\u014D": "o",
    "\u014F": "o",
    "\u0151": "o",
    "\u0154": "R",
    "\u0156": "R",
    "\u0158": "R",
    "\u0155": "r",
    "\u0157": "r",
    "\u0159": "r",
    "\u015A": "S",
    "\u015C": "S",
    "\u015E": "S",
    "\u0160": "S",
    "\u015B": "s",
    "\u015D": "s",
    "\u015F": "s",
    "\u0161": "s",
    "\u0162": "T",
    "\u0164": "T",
    "\u0166": "T",
    "\u0163": "t",
    "\u0165": "t",
    "\u0167": "t",
    "\u0168": "U",
    "\u016A": "U",
    "\u016C": "U",
    "\u016E": "U",
    "\u0170": "U",
    "\u0172": "U",
    "\u0169": "u",
    "\u016B": "u",
    "\u016D": "u",
    "\u016F": "u",
    "\u0171": "u",
    "\u0173": "u",
    "\u0174": "W",
    "\u0175": "w",
    "\u0176": "Y",
    "\u0177": "y",
    "\u0178": "Y",
    "\u0179": "Z",
    "\u017B": "Z",
    "\u017D": "Z",
    "\u017A": "z",
    "\u017C": "z",
    "\u017E": "z",
    "\u0132": "IJ",
    "\u0133": "ij",
    "\u0152": "Oe",
    "\u0153": "oe",
    "\u0149": "'n",
    "\u017F": "ss"
  };
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var deburrLetter = basePropertyOf(deburredLetters);
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  var snakeCase = createCompounder(function(result, word, index) {
    return result + (index ? "_" : "") + word.toLowerCase();
  });
  module.exports = snakeCase;
});

// node_modules/discord.js/src/util/Transformers.js
var require_Transformers = __commonJS((exports, module) => {
  var toSnakeCase = function(obj) {
    if (typeof obj !== "object" || !obj)
      return obj;
    if (obj instanceof Date)
      return obj;
    if (isJSONEncodable(obj))
      return toSnakeCase(obj.toJSON());
    if (Array.isArray(obj))
      return obj.map(toSnakeCase);
    return Object.fromEntries(Object.entries(obj).map(([key, value]) => [snakeCase(key), toSnakeCase(value)]));
  };
  var _transformAPIAutoModerationAction = function(autoModerationAction) {
    return {
      type: autoModerationAction.type,
      metadata: {
        durationSeconds: autoModerationAction.metadata.duration_seconds ?? null,
        channelId: autoModerationAction.metadata.channel_id ?? null,
        customMessage: autoModerationAction.metadata.custom_message ?? null
      }
    };
  };
  var _transformAPIMessageInteractionMetadata = function(client, messageInteractionMetadata) {
    return {
      id: messageInteractionMetadata.id,
      type: messageInteractionMetadata.type,
      user: client.users._add(messageInteractionMetadata.user),
      authorizingIntegrationOwners: messageInteractionMetadata.authorizing_integration_owners,
      originalResponseMessageId: messageInteractionMetadata.original_response_message_id ?? null,
      interactedMessageId: messageInteractionMetadata.interacted_message_id ?? null,
      triggeringInteractionMetadata: messageInteractionMetadata.triggering_interaction_metadata ? _transformAPIMessageInteractionMetadata(client, messageInteractionMetadata.triggering_interaction_metadata) : null
    };
  };
  var _transformGuildScheduledEventRecurrenceRule = function(recurrenceRule) {
    return {
      start: new Date(recurrenceRule.startAt).toISOString(),
      frequency: recurrenceRule.frequency,
      interval: recurrenceRule.interval,
      by_weekday: recurrenceRule.byWeekday,
      by_n_weekday: recurrenceRule.byNWeekday,
      by_month: recurrenceRule.byMonth,
      by_month_day: recurrenceRule.byMonthDay
    };
  };
  var _transformAPIIncidentsData = function(data) {
    return {
      invitesDisabledUntil: data.invites_disabled_until ? new Date(data.invites_disabled_until) : null,
      dmsDisabledUntil: data.dms_disabled_until ? new Date(data.dms_disabled_until) : null,
      dmSpamDetectedAt: data.dm_spam_detected_at ? new Date(data.dm_spam_detected_at) : null,
      raidDetectedAt: data.raid_detected_at ? new Date(data.raid_detected_at) : null
    };
  };
  var { isJSONEncodable } = require_dist();
  var snakeCase = require_lodash();
  module.exports = {
    toSnakeCase,
    _transformAPIAutoModerationAction,
    _transformAPIMessageInteractionMetadata,
    _transformGuildScheduledEventRecurrenceRule,
    _transformAPIIncidentsData
  };
});

// node_modules/discord.js/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    $schema: "https://json.schemastore.org/package.json",
    name: "discord.js",
    version: "14.19.3",
    description: "A powerful library for interacting with the Discord API",
    main: "./src/index.js",
    types: "./typings/index.d.ts",
    exports: {
      ".": {
        import: {
          types: "./typings/index.d.mts",
          default: "./src/index.js"
        },
        require: {
          types: "./typings/index.d.ts",
          default: "./src/index.js"
        }
      }
    },
    directories: {
      lib: "src",
      test: "test"
    },
    files: [
      "src",
      "typings"
    ],
    contributors: [
      "Crawl <icrawltogo@gmail.com>",
      "Amish Shah <amishshah.2k@gmail.com>",
      "Vlad Frangu <me@vladfrangu.dev>",
      "SpaceEEC <spaceeec@yahoo.com>",
      "Aura Romn <kyradiscord@gmail.com>"
    ],
    license: "Apache-2.0",
    keywords: [
      "discord",
      "api",
      "bot",
      "client",
      "node",
      "discordapp"
    ],
    repository: {
      type: "git",
      url: "https://github.com/discordjs/discord.js.git",
      directory: "packages/discord.js"
    },
    bugs: {
      url: "https://github.com/discordjs/discord.js/issues"
    },
    homepage: "https://discord.js.org",
    funding: "https://github.com/discordjs/discord.js?sponsor",
    dependencies: {
      "@discordjs/builders": "^1.11.2",
      "@discordjs/collection": "1.5.3",
      "@discordjs/formatters": "^0.6.1",
      "@discordjs/ws": "^1.2.2",
      "@sapphire/snowflake": "3.5.3",
      "discord-api-types": "^0.38.1",
      "fast-deep-equal": "3.1.3",
      "lodash.snakecase": "4.1.1",
      "magic-bytes.js": "^1.10.0",
      tslib: "^2.6.3",
      undici: "6.21.1",
      "@discordjs/rest": "^2.5.0",
      "@discordjs/util": "^1.1.1"
    },
    devDependencies: {
      "@favware/cliff-jumper": "^4.1.0",
      "@types/node": "^16.18.105",
      "@typescript-eslint/eslint-plugin": "^8.2.0",
      "@typescript-eslint/parser": "^8.2.0",
      "cross-env": "^7.0.3",
      dtslint: "4.2.1",
      eslint: "^8.57.0",
      "eslint-formatter-pretty": "^5.0.0",
      jest: "29.7.0",
      prettier: "^3.3.3",
      tsd: "^0.31.1",
      tslint: "6.1.3",
      turbo: "^2.0.14",
      typescript: "~5.5.4",
      "@discordjs/api-extractor": "^7.38.1",
      "@discordjs/docgen": "^0.12.1",
      "@discordjs/scripts": "^0.1.0"
    },
    engines: {
      node: ">=18"
    },
    publishConfig: {
      provenance: true
    },
    scripts: {
      test: "pnpm run docs:test && pnpm run test:typescript",
      "test:typescript": "tsc --noEmit && tsd",
      lint: "prettier --check . && tslint typings/index.d.ts && cross-env ESLINT_USE_FLAT_CONFIG=false eslint --format=pretty src typings",
      format: "prettier --write . && cross-env ESLINT_USE_FLAT_CONFIG=false eslint --fix --format=pretty src",
      fmt: "pnpm run format",
      docs: "docgen -i \"./src/*.js\" \"./src/**/*.js\" -c ./docs/index.json -r ../../ -o ./docs/docs.json && pnpm run docs:new",
      "docs:test": "docgen -i \"./src/*.js\" \"./src/**/*.js\" -c ./docs/index.json -r ../../",
      "docs:new": "api-extractor run --local --minify && generate-split-documentation",
      changelog: "git cliff --prepend ./CHANGELOG.md -u -c ./cliff.toml -r ../../ --include-path 'packages/discord.js/*'",
      release: "cliff-jumper"
    }
  };
});

// node_modules/@discordjs/collection/dist/index.js
var require_dist6 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersect(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of other) {
        if (this.has(key) && Object.is(value, this.get(key))) {
          coll.set(key, value);
        }
      }
      return coll;
    }
    subtract(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key) || !Object.is(value, other.get(key))) {
          coll.set(key, value);
        }
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    sorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.values()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "1.5.3";
});

// node_modules/discord.js/src/util/LimitedCollection.js
var require_LimitedCollection = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class LimitedCollection extends Collection {
    constructor(options = {}, iterable) {
      if (typeof options !== "object" || options === null) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      }
      const { maxSize = Infinity, keepOverLimit = null } = options;
      if (typeof maxSize !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "maxSize", "number");
      }
      if (keepOverLimit !== null && typeof keepOverLimit !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "keepOverLimit", "function");
      }
      super(iterable);
      this.maxSize = maxSize;
      this.keepOverLimit = keepOverLimit;
    }
    set(key, value) {
      if (this.maxSize === 0 && !this.keepOverLimit?.(value, key, this))
        return this;
      if (this.size >= this.maxSize && !this.has(key)) {
        for (const [k, v] of this.entries()) {
          const keep = this.keepOverLimit?.(v, k, this) ?? false;
          if (!keep) {
            this.delete(k);
            break;
          }
        }
      }
      return super.set(key, value);
    }
    static get [Symbol.species]() {
      return Collection;
    }
  }
  module.exports = LimitedCollection;
});

// node_modules/discord.js/src/util/Options.js
var require_Options = __commonJS((exports, module) => {
  var { DefaultRestOptions, DefaultUserAgentAppendix } = require_dist5();
  var { toSnakeCase } = require_Transformers();
  var { version } = require_package();

  class Options extends null {
    static userAgentAppendix = `discord.js/${version} ${DefaultUserAgentAppendix}`.trimEnd();
    static createDefault() {
      return {
        closeTimeout: 5000,
        waitGuildTimeout: 15000,
        shardCount: 1,
        makeCache: this.cacheWithLimits(this.DefaultMakeCacheSettings),
        partials: [],
        failIfNotExists: true,
        enforceNonce: false,
        presence: {},
        sweepers: this.DefaultSweeperSettings,
        ws: {
          large_threshold: 50,
          version: 10
        },
        rest: {
          ...DefaultRestOptions,
          userAgentAppendix: this.userAgentAppendix
        },
        jsonTransformer: toSnakeCase
      };
    }
    static cacheWithLimits(settings = {}) {
      const { Collection } = require_dist6();
      const LimitedCollection = require_LimitedCollection();
      return (managerType, _, manager) => {
        const setting = settings[manager.name] ?? settings[managerType.name];
        if (setting == null) {
          return new Collection;
        }
        if (typeof setting === "number") {
          if (setting === Infinity) {
            return new Collection;
          }
          return new LimitedCollection({ maxSize: setting });
        }
        const noLimit = setting.maxSize == null || setting.maxSize === Infinity;
        if (noLimit) {
          return new Collection;
        }
        return new LimitedCollection(setting);
      };
    }
    static cacheEverything() {
      const { Collection } = require_dist6();
      return () => new Collection;
    }
    static get DefaultMakeCacheSettings() {
      return {
        MessageManager: 200
      };
    }
    static get DefaultSweeperSettings() {
      return {
        threads: {
          interval: 3600,
          lifetime: 14400
        }
      };
    }
  }
  module.exports = Options;
});

// node_modules/discord.js/src/util/Colors.js
var require_Colors = __commonJS((exports, module) => {
  module.exports = {
    Default: 0,
    White: 16777215,
    Aqua: 1752220,
    Green: 5763719,
    Blue: 3447003,
    Yellow: 16705372,
    Purple: 10181046,
    LuminousVividPink: 15277667,
    Fuchsia: 15418782,
    Gold: 15844367,
    Orange: 15105570,
    Red: 15548997,
    Grey: 9807270,
    Navy: 3426654,
    DarkAqua: 1146986,
    DarkGreen: 2067276,
    DarkBlue: 2123412,
    DarkPurple: 7419530,
    DarkVividPink: 11342935,
    DarkGold: 12745742,
    DarkOrange: 11027200,
    DarkRed: 10038562,
    DarkGrey: 9936031,
    DarkerGrey: 8359053,
    LightGrey: 12370112,
    DarkNavy: 2899536,
    Blurple: 5793266,
    Greyple: 10070709,
    DarkButNotBlack: 2895667,
    NotQuiteBlack: 2303786
  };
});

// node_modules/discord.js/src/util/BitField.js
var require_BitField = __commonJS((exports, module) => {
  var { DiscordjsRangeError, ErrorCodes } = require_errors();

  class BitField {
    static Flags = {};
    static DefaultBit = 0;
    constructor(bits = this.constructor.DefaultBit) {
      this.bitfield = this.constructor.resolve(bits);
    }
    any(bit) {
      return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;
    }
    equals(bit) {
      return this.bitfield === this.constructor.resolve(bit);
    }
    has(bit) {
      bit = this.constructor.resolve(bit);
      return (this.bitfield & bit) === bit;
    }
    missing(bits, ...hasParams) {
      return new this.constructor(bits).remove(this).toArray(...hasParams);
    }
    freeze() {
      return Object.freeze(this);
    }
    add(...bits) {
      let total = this.constructor.DefaultBit;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield | total);
      this.bitfield |= total;
      return this;
    }
    remove(...bits) {
      let total = this.constructor.DefaultBit;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield & ~total);
      this.bitfield &= ~total;
      return this;
    }
    serialize(...hasParams) {
      const serialized = {};
      for (const [flag, bit] of Object.entries(this.constructor.Flags)) {
        if (isNaN(flag))
          serialized[flag] = this.has(bit, ...hasParams);
      }
      return serialized;
    }
    toArray(...hasParams) {
      return [...this[Symbol.iterator](...hasParams)];
    }
    toJSON() {
      return typeof this.bitfield === "number" ? this.bitfield : this.bitfield.toString();
    }
    valueOf() {
      return this.bitfield;
    }
    *[Symbol.iterator](...hasParams) {
      for (const bitName of Object.keys(this.constructor.Flags)) {
        if (isNaN(bitName) && this.has(bitName, ...hasParams))
          yield bitName;
      }
    }
    static resolve(bit) {
      const { DefaultBit } = this;
      if (typeof DefaultBit === typeof bit && bit >= DefaultBit)
        return bit;
      if (bit instanceof BitField)
        return bit.bitfield;
      if (Array.isArray(bit)) {
        return bit.map((bit_) => this.resolve(bit_)).reduce((prev, bit_) => prev | bit_, DefaultBit);
      }
      if (typeof bit === "string") {
        if (!isNaN(bit))
          return typeof DefaultBit === "bigint" ? BigInt(bit) : Number(bit);
        if (this.Flags[bit] !== undefined)
          return this.Flags[bit];
      }
      throw new DiscordjsRangeError(ErrorCodes.BitFieldInvalid, bit);
    }
  }
  module.exports = BitField;
});

// node_modules/discord.js/src/util/AttachmentFlagsBitField.js
var require_AttachmentFlagsBitField = __commonJS((exports, module) => {
  var { AttachmentFlags } = require_v106();
  var BitField = require_BitField();

  class AttachmentFlagsBitField extends BitField {
    static Flags = AttachmentFlags;
  }
  module.exports = AttachmentFlagsBitField;
});

// node_modules/discord.js/src/structures/Attachment.js
var require_Attachment = __commonJS((exports, module) => {
  var AttachmentFlagsBitField = require_AttachmentFlagsBitField();
  var { basename, flatten } = require_Util();

  class Attachment {
    constructor(data) {
      this.attachment = data.url;
      this.name = data.filename;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("size" in data) {
        this.size = data.size;
      }
      if ("url" in data) {
        this.url = data.url;
      }
      if ("proxy_url" in data) {
        this.proxyURL = data.proxy_url;
      }
      if ("height" in data) {
        this.height = data.height;
      } else {
        this.height ??= null;
      }
      if ("width" in data) {
        this.width = data.width;
      } else {
        this.width ??= null;
      }
      if ("content_type" in data) {
        this.contentType = data.content_type;
      } else {
        this.contentType ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      this.ephemeral = data.ephemeral ?? false;
      if ("duration_secs" in data) {
        this.duration = data.duration_secs;
      } else {
        this.duration ??= null;
      }
      if ("waveform" in data) {
        this.waveform = data.waveform;
      } else {
        this.waveform ??= null;
      }
      if ("flags" in data) {
        this.flags = new AttachmentFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new AttachmentFlagsBitField().freeze();
      }
      if ("title" in data) {
        this.title = data.title;
      } else {
        this.title ??= null;
      }
    }
    get spoiler() {
      return basename(this.url ?? this.name).startsWith("SPOILER_");
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = Attachment;
});

// node_modules/@discordjs/formatters/dist/index.js
var require_dist7 = __commonJS((exports, module) => {
  var escapeMarkdown = function(text, options = {}) {
    const {
      codeBlock: codeBlock2 = true,
      inlineCode: inlineCode2 = true,
      bold: bold2 = true,
      italic: italic2 = true,
      underline: underline2 = true,
      strikethrough: strikethrough2 = true,
      spoiler: spoiler2 = true,
      codeBlockContent = true,
      inlineCodeContent = true,
      escape = true,
      heading: heading2 = false,
      bulletedList = false,
      numberedList = false,
      maskedLink = false
    } = options;
    if (!codeBlockContent) {
      return text.split("```").map((subString, index, array) => {
        if (index % 2 && index !== array.length - 1)
          return subString;
        return escapeMarkdown(subString, {
          inlineCode: inlineCode2,
          bold: bold2,
          italic: italic2,
          underline: underline2,
          strikethrough: strikethrough2,
          spoiler: spoiler2,
          inlineCodeContent,
          escape,
          heading: heading2,
          bulletedList,
          numberedList,
          maskedLink
        });
      }).join(codeBlock2 ? "\\`\\`\\`" : "```");
    }
    if (!inlineCodeContent) {
      return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {
        if (index % 2 && index !== array.length - 1)
          return subString;
        return escapeMarkdown(subString, {
          codeBlock: codeBlock2,
          bold: bold2,
          italic: italic2,
          underline: underline2,
          strikethrough: strikethrough2,
          spoiler: spoiler2,
          escape,
          heading: heading2,
          bulletedList,
          numberedList,
          maskedLink
        });
      }).join(inlineCode2 ? "\\`" : "`");
    }
    let res = text;
    if (escape)
      res = escapeEscape(res);
    if (inlineCode2)
      res = escapeInlineCode(res);
    if (codeBlock2)
      res = escapeCodeBlock(res);
    if (italic2)
      res = escapeItalic(res);
    if (bold2)
      res = escapeBold(res);
    if (underline2)
      res = escapeUnderline(res);
    if (strikethrough2)
      res = escapeStrikethrough(res);
    if (spoiler2)
      res = escapeSpoiler(res);
    if (heading2)
      res = escapeHeading(res);
    if (bulletedList)
      res = escapeBulletedList(res);
    if (numberedList)
      res = escapeNumberedList(res);
    if (maskedLink)
      res = escapeMaskedLink(res);
    return res;
  };
  var escapeCodeBlock = function(text) {
    return text.replaceAll("```", "\\`\\`\\`");
  };
  var escapeInlineCode = function(text) {
    return text.replaceAll(/(?<=^|[^`])``?(?=[^`]|$)/g, (match) => match.length === 2 ? "\\`\\`" : "\\`");
  };
  var escapeItalic = function(text) {
    let idx = 0;
    const newText = text.replaceAll(/(?<=^|[^*])\*([^*]|\*\*|$)/g, (_, match) => {
      if (match === "**")
        return ++idx % 2 ? `\\*${match}` : `${match}\\*`;
      return `\\*${match}`;
    });
    idx = 0;
    return newText.replaceAll(/(?<=^|[^_])(?<!<a?:.+|https?:\/\/\S+)_(?!:\d+>)([^_]|__|$)/g, (_, match) => {
      if (match === "__")
        return ++idx % 2 ? `\\_${match}` : `${match}\\_`;
      return `\\_${match}`;
    });
  };
  var escapeBold = function(text) {
    let idx = 0;
    return text.replaceAll(/\*\*(\*)?/g, (_, match) => {
      if (match)
        return ++idx % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
      return "\\*\\*";
    });
  };
  var escapeUnderline = function(text) {
    let idx = 0;
    return text.replaceAll(/(?<!<a?:.+|https?:\/\/\S+)__(_)?(?!:\d+>)/g, (_, match) => {
      if (match)
        return ++idx % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
      return "\\_\\_";
    });
  };
  var escapeStrikethrough = function(text) {
    return text.replaceAll("~~", "\\~\\~");
  };
  var escapeSpoiler = function(text) {
    return text.replaceAll("||", "\\|\\|");
  };
  var escapeEscape = function(text) {
    return text.replaceAll("\\", "\\\\");
  };
  var escapeHeading = function(text) {
    return text.replaceAll(/^( {0,2})([*-] )?( *)(#{1,3} )/gm, "$1$2$3\\$4");
  };
  var escapeBulletedList = function(text) {
    return text.replaceAll(/^( *)([*-])( +)/gm, "$1\\$2$3");
  };
  var escapeNumberedList = function(text) {
    return text.replaceAll(/^( *\d+)\./gm, "$1\\.");
  };
  var escapeMaskedLink = function(text) {
    return text.replaceAll(/\[.+]\(.+\)/gm, "\\$&");
  };
  var codeBlock = function(language, content) {
    return content === undefined ? `\`\`\`
${language}
\`\`\`` : `\`\`\`${language}
${content}
\`\`\``;
  };
  var inlineCode = function(content) {
    return `\`${content}\``;
  };
  var italic = function(content) {
    return `_${content}_`;
  };
  var bold = function(content) {
    return `**${content}**`;
  };
  var underscore = function(content) {
    return underline(content);
  };
  var underline = function(content) {
    return `__${content}__`;
  };
  var strikethrough = function(content) {
    return `~~${content}~~`;
  };
  var quote = function(content) {
    return `> ${content}`;
  };
  var blockQuote = function(content) {
    return `>>> ${content}`;
  };
  var hideLinkEmbed = function(url) {
    return `<${url}>`;
  };
  var hyperlink = function(content, url, title) {
    return title ? `[${content}](${url} "${title}")` : `[${content}](${url})`;
  };
  var spoiler = function(content) {
    return `||${content}||`;
  };
  var userMention = function(userId) {
    return `<@${userId}>`;
  };
  var channelMention = function(channelId) {
    return `<#${channelId}>`;
  };
  var roleMention = function(roleId) {
    return `<@&${roleId}>`;
  };
  var chatInputApplicationCommandMention = function(commandName, subcommandGroupName, subcommandName, commandId) {
    if (commandId !== undefined) {
      return `</${commandName} ${subcommandGroupName} ${subcommandName}:${commandId}>`;
    }
    if (subcommandName !== undefined) {
      return `</${commandName} ${subcommandGroupName}:${subcommandName}>`;
    }
    return `</${commandName}:${subcommandGroupName}>`;
  };
  var formatEmoji = function(emojiIdOrOptions, animated) {
    const options = typeof emojiIdOrOptions === "string" ? {
      id: emojiIdOrOptions,
      animated: animated ?? false
    } : emojiIdOrOptions;
    const { id, animated: isAnimated, name: emojiName } = options;
    return `<${isAnimated ? "a" : ""}:${emojiName ?? "_"}:${id}>`;
  };
  var channelLink = function(channelId, guildId) {
    return `https://discord.com/channels/${guildId ?? "@me"}/${channelId}`;
  };
  var messageLink = function(channelId, messageId, guildId) {
    return `${guildId === undefined ? channelLink(channelId) : channelLink(channelId, guildId)}/${messageId}`;
  };
  var heading = function(content, level) {
    switch (level) {
      case 3:
        return `### ${content}`;
      case 2:
        return `## ${content}`;
      default:
        return `# ${content}`;
    }
  };
  var listCallback = function(element, startNumber, depth = 0) {
    if (Array.isArray(element)) {
      return element.map((element2) => listCallback(element2, startNumber, depth + 1)).join("\n");
    }
    return `${"  ".repeat(depth - 1)}${startNumber ? `${startNumber}.` : "-"} ${element}`;
  };
  var orderedList = function(list, startNumber = 1) {
    return listCallback(list, Math.max(startNumber, 1));
  };
  var unorderedList = function(list) {
    return listCallback(list);
  };
  var subtext = function(content) {
    return `-# ${content}`;
  };
  var time = function(timeOrSeconds, style) {
    if (typeof timeOrSeconds !== "number") {
      timeOrSeconds = Math.floor((timeOrSeconds?.getTime() ?? Date.now()) / 1000);
    }
    return typeof style === "string" ? `<t:${timeOrSeconds}:${style}>` : `<t:${timeOrSeconds}>`;
  };
  var applicationDirectory = function(applicationId, skuId) {
    const url = `https://discord.com/application-directory/${applicationId}/store`;
    return skuId ? `${url}/${skuId}` : url;
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    Faces: () => Faces,
    GuildNavigationMentions: () => GuildNavigationMentions,
    HeadingLevel: () => HeadingLevel,
    TimestampStyles: () => TimestampStyles,
    applicationDirectory: () => applicationDirectory,
    blockQuote: () => blockQuote,
    bold: () => bold,
    channelLink: () => channelLink,
    channelMention: () => channelMention,
    chatInputApplicationCommandMention: () => chatInputApplicationCommandMention,
    codeBlock: () => codeBlock,
    escapeBold: () => escapeBold,
    escapeBulletedList: () => escapeBulletedList,
    escapeCodeBlock: () => escapeCodeBlock,
    escapeEscape: () => escapeEscape,
    escapeHeading: () => escapeHeading,
    escapeInlineCode: () => escapeInlineCode,
    escapeItalic: () => escapeItalic,
    escapeMarkdown: () => escapeMarkdown,
    escapeMaskedLink: () => escapeMaskedLink,
    escapeNumberedList: () => escapeNumberedList,
    escapeSpoiler: () => escapeSpoiler,
    escapeStrikethrough: () => escapeStrikethrough,
    escapeUnderline: () => escapeUnderline,
    formatEmoji: () => formatEmoji,
    heading: () => heading,
    hideLinkEmbed: () => hideLinkEmbed,
    hyperlink: () => hyperlink,
    inlineCode: () => inlineCode,
    italic: () => italic,
    messageLink: () => messageLink,
    orderedList: () => orderedList,
    quote: () => quote,
    roleMention: () => roleMention,
    spoiler: () => spoiler,
    strikethrough: () => strikethrough,
    subtext: () => subtext,
    time: () => time,
    underline: () => underline,
    underscore: () => underscore,
    unorderedList: () => unorderedList,
    userMention: () => userMention,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  __name(escapeMarkdown, "escapeMarkdown");
  __name(escapeCodeBlock, "escapeCodeBlock");
  __name(escapeInlineCode, "escapeInlineCode");
  __name(escapeItalic, "escapeItalic");
  __name(escapeBold, "escapeBold");
  __name(escapeUnderline, "escapeUnderline");
  __name(escapeStrikethrough, "escapeStrikethrough");
  __name(escapeSpoiler, "escapeSpoiler");
  __name(escapeEscape, "escapeEscape");
  __name(escapeHeading, "escapeHeading");
  __name(escapeBulletedList, "escapeBulletedList");
  __name(escapeNumberedList, "escapeNumberedList");
  __name(escapeMaskedLink, "escapeMaskedLink");
  __name(codeBlock, "codeBlock");
  __name(inlineCode, "inlineCode");
  __name(italic, "italic");
  __name(bold, "bold");
  __name(underscore, "underscore");
  __name(underline, "underline");
  __name(strikethrough, "strikethrough");
  __name(quote, "quote");
  __name(blockQuote, "blockQuote");
  __name(hideLinkEmbed, "hideLinkEmbed");
  __name(hyperlink, "hyperlink");
  __name(spoiler, "spoiler");
  __name(userMention, "userMention");
  __name(channelMention, "channelMention");
  __name(roleMention, "roleMention");
  __name(chatInputApplicationCommandMention, "chatInputApplicationCommandMention");
  __name(formatEmoji, "formatEmoji");
  __name(channelLink, "channelLink");
  __name(messageLink, "messageLink");
  var HeadingLevel = ((HeadingLevel2) => {
    HeadingLevel2[HeadingLevel2["One"] = 1] = "One";
    HeadingLevel2[HeadingLevel2["Two"] = 2] = "Two";
    HeadingLevel2[HeadingLevel2["Three"] = 3] = "Three";
    return HeadingLevel2;
  })(HeadingLevel || {});
  __name(heading, "heading");
  __name(listCallback, "listCallback");
  __name(orderedList, "orderedList");
  __name(unorderedList, "unorderedList");
  __name(subtext, "subtext");
  __name(time, "time");
  __name(applicationDirectory, "applicationDirectory");
  var TimestampStyles = {
    ShortTime: "t",
    LongTime: "T",
    ShortDate: "d",
    LongDate: "D",
    ShortDateTime: "f",
    LongDateTime: "F",
    RelativeTime: "R"
  };
  var Faces = ((Faces2) => {
    Faces2["Shrug"] = "\xAF\\_(\u30C4)_/\xAF";
    Faces2["Tableflip"] = "(\u256F\xB0\u25A1\xB0)\u256F\uFE35 \u253B\u2501\u253B";
    Faces2["Unflip"] = "\u252C\u2500\u252C\u30CE( \xBA _ \xBA\u30CE)";
    return Faces2;
  })(Faces || {});
  var GuildNavigationMentions = ((GuildNavigationMentions2) => {
    GuildNavigationMentions2["Browse"] = "<id:browse>";
    GuildNavigationMentions2["Customize"] = "<id:customize>";
    GuildNavigationMentions2["Guide"] = "<id:guide>";
    return GuildNavigationMentions2;
  })(GuildNavigationMentions || {});
  var version = "0.6.1";
});

// node_modules/discord.js/src/structures/Base.js
var require_Base = __commonJS((exports, module) => {
  var { flatten } = require_Util();

  class Base {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
    _patch(data) {
      return data;
    }
    _update(data) {
      const clone = this._clone();
      this._patch(data);
      return clone;
    }
    toJSON(...props) {
      return flatten(this, ...props);
    }
    valueOf() {
      return this.id;
    }
  }
  module.exports = Base;
});

// node_modules/discord.js/src/util/ChannelFlagsBitField.js
var require_ChannelFlagsBitField = __commonJS((exports, module) => {
  var { ChannelFlags } = require_v106();
  var BitField = require_BitField();

  class ChannelFlagsBitField extends BitField {
    static Flags = ChannelFlags;
  }
  module.exports = ChannelFlagsBitField;
});

// node_modules/discord.js/src/util/Constants.js
var require_Constants = __commonJS((exports) => {
  var { ChannelType, MessageType, ComponentType, ImageFormat, StickerFormatType } = require_v106();
  exports.MaxBulkDeletableMessageAge = 1209600000;
  exports.SweeperKeys = [
    "autoModerationRules",
    "applicationCommands",
    "bans",
    "emojis",
    "entitlements",
    "invites",
    "guildMembers",
    "messages",
    "presences",
    "reactions",
    "stageInstances",
    "stickers",
    "threadMembers",
    "threads",
    "users",
    "voiceStates"
  ];
  exports.NonSystemMessageTypes = [
    MessageType.Default,
    MessageType.Reply,
    MessageType.ChatInputCommand,
    MessageType.ContextMenuCommand
  ];
  exports.GuildTextBasedChannelTypes = [
    ChannelType.GuildText,
    ChannelType.GuildAnnouncement,
    ChannelType.AnnouncementThread,
    ChannelType.PublicThread,
    ChannelType.PrivateThread,
    ChannelType.GuildVoice,
    ChannelType.GuildStageVoice
  ];
  exports.TextBasedChannelTypes = [...exports.GuildTextBasedChannelTypes, ChannelType.DM, ChannelType.GroupDM];
  exports.SendableChannels = [...exports.GuildTextBasedChannelTypes, ChannelType.DM];
  exports.ThreadChannelTypes = [ChannelType.AnnouncementThread, ChannelType.PublicThread, ChannelType.PrivateThread];
  exports.VoiceBasedChannelTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  exports.SelectMenuTypes = [
    ComponentType.StringSelect,
    ComponentType.UserSelect,
    ComponentType.RoleSelect,
    ComponentType.MentionableSelect,
    ComponentType.ChannelSelect
  ];
  exports.UndeletableMessageTypes = [
    MessageType.RecipientAdd,
    MessageType.RecipientRemove,
    MessageType.Call,
    MessageType.ChannelNameChange,
    MessageType.ChannelIconChange,
    MessageType.ThreadStarterMessage
  ];
  exports.DeletableMessageTypes = [
    MessageType.AutoModerationAction,
    MessageType.ChannelFollowAdd,
    MessageType.ChannelPinnedMessage,
    MessageType.ChatInputCommand,
    MessageType.ContextMenuCommand,
    MessageType.Default,
    MessageType.GuildBoost,
    MessageType.GuildBoostTier1,
    MessageType.GuildBoostTier2,
    MessageType.GuildBoostTier3,
    MessageType.GuildInviteReminder,
    MessageType.InteractionPremiumUpsell,
    MessageType.Reply,
    MessageType.RoleSubscriptionPurchase,
    MessageType.StageEnd,
    MessageType.StageRaiseHand,
    MessageType.StageSpeaker,
    MessageType.StageStart,
    MessageType.StageTopic,
    MessageType.ThreadCreated,
    MessageType.UserJoin
  ];
  exports.StickerFormatExtensionMap = {
    [StickerFormatType.PNG]: ImageFormat.PNG,
    [StickerFormatType.APNG]: ImageFormat.PNG,
    [StickerFormatType.Lottie]: ImageFormat.Lottie,
    [StickerFormatType.GIF]: ImageFormat.GIF
  };
});

// node_modules/discord.js/src/structures/BaseChannel.js
var require_BaseChannel = __commonJS((exports) => {
  var { channelLink, channelMention } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var { ChannelType, Routes } = require_v106();
  var Base = require_Base();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();
  var { ThreadChannelTypes } = require_Constants();

  class BaseChannel extends Base {
    constructor(client, data, immediatePatch = true) {
      super(client);
      this.type = data.type;
      if (data && immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      if ("flags" in data) {
        this.flags = new ChannelFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new ChannelFlagsBitField().freeze();
      }
      this.id = data.id;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.isDMBased() ? channelLink(this.id) : channelLink(this.id, this.guildId);
    }
    get partial() {
      return false;
    }
    toString() {
      return channelMention(this.id);
    }
    async delete() {
      await this.client.rest.delete(Routes.channel(this.id));
      return this;
    }
    fetch(force = true) {
      return this.client.channels.fetch(this.id, { force });
    }
    isThread() {
      return ThreadChannelTypes.includes(this.type);
    }
    isTextBased() {
      return "messages" in this;
    }
    isDMBased() {
      return [ChannelType.DM, ChannelType.GroupDM].includes(this.type);
    }
    isVoiceBased() {
      return "bitrate" in this;
    }
    isThreadOnly() {
      return "availableTags" in this;
    }
    isSendable() {
      return "send" in this;
    }
    toJSON(...props) {
      return super.toJSON({ createdTimestamp: true }, ...props);
    }
  }
  exports.BaseChannel = BaseChannel;
});

// node_modules/discord.js/src/managers/BaseManager.js
var require_BaseManager = __commonJS((exports, module) => {
  class BaseManager {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
  }
  module.exports = BaseManager;
});

// node_modules/discord.js/src/managers/DataManager.js
var require_DataManager = __commonJS((exports, module) => {
  var BaseManager = require_BaseManager();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class DataManager extends BaseManager {
    constructor(client, holds) {
      super(client);
      Object.defineProperty(this, "holds", { value: holds });
    }
    get cache() {
      throw new DiscordjsError(ErrorCodes.NotImplemented, "get cache", this.constructor.name);
    }
    resolve(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance;
      if (typeof idOrInstance === "string")
        return this.cache.get(idOrInstance) ?? null;
      return null;
    }
    resolveId(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance.id;
      if (typeof idOrInstance === "string")
        return idOrInstance;
      return null;
    }
    valueOf() {
      return this.cache;
    }
  }
  module.exports = DataManager;
});

// node_modules/discord.js/src/util/Symbols.js
var require_Symbols = __commonJS((exports) => {
  exports.MakeCacheOverrideSymbol = Symbol("djs.managers.makeCacheOverride");
});

// node_modules/discord.js/src/managers/CachedManager.js
var require_CachedManager = __commonJS((exports, module) => {
  var DataManager = require_DataManager();
  var { MakeCacheOverrideSymbol } = require_Symbols();

  class CachedManager extends DataManager {
    constructor(client, holds, iterable) {
      super(client, holds);
      Object.defineProperty(this, "_cache", {
        value: this.client.options.makeCache(this.constructor[MakeCacheOverrideSymbol] ?? this.constructor, this.holds, this.constructor)
      });
      if (iterable) {
        for (const item of iterable) {
          this._add(item);
        }
      }
    }
    get cache() {
      return this._cache;
    }
    _add(data, cache = true, { id, extras = [] } = {}) {
      const existing = this.cache.get(id ?? data.id);
      if (existing) {
        if (cache) {
          existing._patch(data);
          return existing;
        }
        const clone = existing._clone();
        clone._patch(data);
        return clone;
      }
      const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
      if (cache)
        this.cache.set(id ?? entry.id, entry);
      return entry;
    }
  }
  module.exports = CachedManager;
});

// node_modules/discord.js/src/util/PermissionsBitField.js
var require_PermissionsBitField = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BitField = require_BitField();

  class PermissionsBitField extends BitField {
    static Flags = PermissionFlagsBits;
    static All = Object.values(PermissionFlagsBits).reduce((all, p) => all | p, 0n);
    static Default = BigInt(104324673);
    static StageModerator = PermissionFlagsBits.ManageChannels | PermissionFlagsBits.MuteMembers | PermissionFlagsBits.MoveMembers;
    static DefaultBit = BigInt(0);
    missing(bits, checkAdmin = true) {
      return checkAdmin && this.has(PermissionFlagsBits.Administrator) ? [] : super.missing(bits);
    }
    any(permission, checkAdmin = true) {
      return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.any(permission);
    }
    has(permission, checkAdmin = true) {
      return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.has(permission);
    }
    toArray() {
      return super.toArray(false);
    }
  }
  module.exports = PermissionsBitField;
});

// node_modules/discord.js/src/util/RoleFlagsBitField.js
var require_RoleFlagsBitField = __commonJS((exports, module) => {
  var { RoleFlags } = require_v106();
  var BitField = require_BitField();

  class RoleFlagsBitField extends BitField {
    static Flags = RoleFlags;
  }
  module.exports = RoleFlagsBitField;
});

// node_modules/discord.js/src/structures/Role.js
var require_Role = __commonJS((exports) => {
  var { roleMention } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var { PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var PermissionsBitField = require_PermissionsBitField();
  var RoleFlagsBitField = require_RoleFlagsBitField();

  class Role extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.icon = null;
      this.unicodeEmoji = null;
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("color" in data) {
        this.color = data.color;
      }
      if ("hoist" in data) {
        this.hoist = data.hoist;
      }
      if ("position" in data) {
        this.rawPosition = data.position;
      }
      if ("permissions" in data) {
        this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("mentionable" in data) {
        this.mentionable = data.mentionable;
      }
      if ("icon" in data)
        this.icon = data.icon;
      if ("unicode_emoji" in data)
        this.unicodeEmoji = data.unicode_emoji;
      if ("flags" in data) {
        this.flags = new RoleFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new RoleFlagsBitField().freeze();
      }
      this.tags = data.tags ? {} : null;
      if (data.tags) {
        if ("bot_id" in data.tags) {
          this.tags.botId = data.tags.bot_id;
        }
        if ("integration_id" in data.tags) {
          this.tags.integrationId = data.tags.integration_id;
        }
        if ("premium_subscriber" in data.tags) {
          this.tags.premiumSubscriberRole = true;
        }
        if ("subscription_listing_id" in data.tags) {
          this.tags.subscriptionListingId = data.tags.subscription_listing_id;
        }
        if ("available_for_purchase" in data.tags) {
          this.tags.availableForPurchase = true;
        }
        if ("guild_connections" in data.tags) {
          this.tags.guildConnections = true;
        }
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get hexColor() {
      return `#${this.color.toString(16).padStart(6, "0")}`;
    }
    get members() {
      return this.id === this.guild.id ? this.guild.members.cache.clone() : this.guild.members.cache.filter((member) => member._roles.includes(this.id));
    }
    get editable() {
      if (this.managed)
        return false;
      const clientMember = this.guild.members.resolve(this.client.user);
      if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles))
        return false;
      return clientMember.roles.highest.comparePositionTo(this) > 0;
    }
    get position() {
      return this.guild.roles.cache.reduce((acc, role) => acc + (this.rawPosition === role.rawPosition ? BigInt(this.id) < BigInt(role.id) : this.rawPosition > role.rawPosition), 0);
    }
    comparePositionTo(role) {
      return this.guild.roles.comparePositions(this, role);
    }
    edit(options) {
      return this.guild.roles.edit(this, options);
    }
    permissionsIn(channel, checkAdmin = true) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      return channel.rolePermissions(this, checkAdmin);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setColor(color, reason) {
      return this.edit({ color, reason });
    }
    setHoist(hoist = true, reason) {
      return this.edit({ hoist, reason });
    }
    setPermissions(permissions, reason) {
      return this.edit({ permissions, reason });
    }
    setMentionable(mentionable = true, reason) {
      return this.edit({ mentionable, reason });
    }
    setIcon(icon, reason) {
      return this.edit({ icon, reason });
    }
    setUnicodeEmoji(unicodeEmoji, reason) {
      return this.edit({ unicodeEmoji, reason });
    }
    setPosition(position, options = {}) {
      return this.guild.roles.setPosition(this, position, options);
    }
    async delete(reason) {
      await this.guild.roles.delete(this.id, reason);
      return this;
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);
    }
    equals(role) {
      return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;
    }
    toString() {
      if (this.id === this.guild.id)
        return "@everyone";
      return roleMention(this.id);
    }
    toJSON() {
      return {
        ...super.toJSON({ createdTimestamp: true }),
        permissions: this.permissions.toJSON()
      };
    }
  }
  exports.Role = Role;
});

// node_modules/discord.js/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS((exports, module) => {
  var { OverwriteType } = require_v106();
  var Base = require_Base();
  var { Role } = require_Role();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var PermissionsBitField = require_PermissionsBitField();

  class PermissionOverwrites extends Base {
    constructor(client, data, channel) {
      super(client);
      Object.defineProperty(this, "channel", { value: channel });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("type" in data) {
        this.type = data.type;
      }
      if ("deny" in data) {
        this.deny = new PermissionsBitField(BigInt(data.deny)).freeze();
      }
      if ("allow" in data) {
        this.allow = new PermissionsBitField(BigInt(data.allow)).freeze();
      }
    }
    async edit(options, reason) {
      await this.channel.permissionOverwrites.upsert(this.id, options, { type: this.type, reason }, this);
      return this;
    }
    async delete(reason) {
      await this.channel.permissionOverwrites.delete(this.id, reason);
      return this;
    }
    toJSON() {
      return {
        id: this.id,
        type: this.type,
        allow: this.allow,
        deny: this.deny
      };
    }
    static resolveOverwriteOptions(options, { allow, deny } = {}) {
      allow = new PermissionsBitField(allow);
      deny = new PermissionsBitField(deny);
      for (const [perm, value] of Object.entries(options)) {
        if (value === true) {
          allow.add(perm);
          deny.remove(perm);
        } else if (value === false) {
          allow.remove(perm);
          deny.add(perm);
        } else if (value === null) {
          allow.remove(perm);
          deny.remove(perm);
        }
      }
      return { allow, deny };
    }
    static resolve(overwrite, guild) {
      if (overwrite instanceof this)
        return overwrite.toJSON();
      if (typeof overwrite.id === "string" && overwrite.type in OverwriteType) {
        return {
          id: overwrite.id,
          type: overwrite.type,
          allow: PermissionsBitField.resolve(overwrite.allow ?? PermissionsBitField.DefaultBit).toString(),
          deny: PermissionsBitField.resolve(overwrite.deny ?? PermissionsBitField.DefaultBit).toString()
        };
      }
      const userOrRole = guild.roles.resolve(overwrite.id) ?? guild.client.users.resolve(overwrite.id);
      if (!userOrRole) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "cached User or Role");
      }
      const type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
      return {
        id: userOrRole.id,
        type,
        allow: PermissionsBitField.resolve(overwrite.allow ?? PermissionsBitField.DefaultBit).toString(),
        deny: PermissionsBitField.resolve(overwrite.deny ?? PermissionsBitField.DefaultBit).toString()
      };
    }
  }
  module.exports = PermissionOverwrites;
});

// node_modules/discord.js/src/managers/PermissionOverwriteManager.js
var require_PermissionOverwriteManager = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var { Collection } = require_dist6();
  var { OverwriteType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var PermissionOverwrites = require_PermissionOverwrites();
  var { Role } = require_Role();
  var cacheWarningEmitted = false;

  class PermissionOverwriteManager extends CachedManager {
    constructor(channel, iterable) {
      super(channel.client, PermissionOverwrites);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.channel = channel;
      if (iterable) {
        for (const item of iterable) {
          this._add(item);
        }
      }
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.channel] });
    }
    async set(overwrites, reason) {
      if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "overwrites", "Array or Collection of Permission Overwrites", true);
      }
      return this.channel.edit({ permissionOverwrites: overwrites, reason });
    }
    async upsert(userOrRole, options, overwriteOptions = {}, existing) {
      let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
      let { type, reason } = overwriteOptions;
      if (typeof type !== "number") {
        userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);
        if (!userOrRole)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
        type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
      }
      const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);
      await this.client.rest.put(Routes.channelPermission(this.channel.id, userOrRoleId), {
        body: { id: userOrRoleId, type, allow, deny },
        reason
      });
      return this.channel;
    }
    create(userOrRole, options, overwriteOptions) {
      return this.upsert(userOrRole, options, overwriteOptions);
    }
    edit(userOrRole, options, overwriteOptions) {
      const existing = this.cache.get(this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole));
      return this.upsert(userOrRole, options, overwriteOptions, existing);
    }
    async delete(userOrRole, reason) {
      const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
      if (!userOrRoleId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
      await this.client.rest.delete(Routes.channelPermission(this.channel.id, userOrRoleId), { reason });
      return this.channel;
    }
  }
  module.exports = PermissionOverwriteManager;
});

// node_modules/discord.js/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS((exports, module) => {
  var { Snowflake } = require_cjs();
  var { PermissionFlagsBits, ChannelType } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var PermissionOverwriteManager = require_PermissionOverwriteManager();
  var { VoiceBasedChannelTypes } = require_Constants();
  var PermissionsBitField = require_PermissionsBitField();
  var { getSortableGroupTypes } = require_Util();

  class GuildChannel extends BaseChannel {
    constructor(guild, data, client, immediatePatch = true) {
      super(client, data, false);
      this.guild = guild;
      this.guildId = guild?.id ?? data.guild_id;
      this.permissionOverwrites = new PermissionOverwriteManager(this);
      if (data && immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("name" in data) {
        this.name = data.name;
      }
      if ("position" in data) {
        this.rawPosition = data.position;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("parent_id" in data) {
        this.parentId = data.parent_id;
      } else {
        this.parentId ??= null;
      }
      if ("permission_overwrites" in data) {
        this.permissionOverwrites.cache.clear();
        for (const overwrite of data.permission_overwrites) {
          this.permissionOverwrites._add(overwrite);
        }
      }
    }
    _clone() {
      const clone = super._clone();
      clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());
      return clone;
    }
    get parent() {
      return this.guild.channels.resolve(this.parentId);
    }
    get permissionsLocked() {
      if (!this.parent)
        return null;
      const overwriteIds = new Set([
        ...this.permissionOverwrites.cache.keys(),
        ...this.parent.permissionOverwrites.cache.keys()
      ]);
      return [...overwriteIds].every((key) => {
        const channelVal = this.permissionOverwrites.cache.get(key);
        const parentVal = this.parent.permissionOverwrites.cache.get(key);
        if (!channelVal && parentVal.deny.bitfield === PermissionsBitField.DefaultBit && parentVal.allow.bitfield === PermissionsBitField.DefaultBit || !parentVal && channelVal.deny.bitfield === PermissionsBitField.DefaultBit && channelVal.allow.bitfield === PermissionsBitField.DefaultBit) {
          return true;
        }
        return channelVal !== undefined && parentVal !== undefined && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;
      });
    }
    get position() {
      const selfIsCategory = this.type === ChannelType.GuildCategory;
      const types = getSortableGroupTypes(this.type);
      let count = 0;
      for (const channel of this.guild.channels.cache.values()) {
        if (!types.includes(channel.type))
          continue;
        if (!selfIsCategory && channel.parentId !== this.parentId)
          continue;
        if (this.rawPosition === channel.rawPosition) {
          if (Snowflake.compare(channel.id, this.id) === -1)
            count++;
        } else if (this.rawPosition > channel.rawPosition) {
          count++;
        }
      }
      return count;
    }
    permissionsFor(memberOrRole, checkAdmin = true) {
      const member = this.guild.members.resolve(memberOrRole);
      if (member)
        return this.memberPermissions(member, checkAdmin);
      const role = this.guild.roles.resolve(memberOrRole);
      return role && this.rolePermissions(role, checkAdmin);
    }
    overwritesFor(member, verified = false, roles = null) {
      if (!verified)
        member = this.guild.members.resolve(member);
      if (!member)
        return [];
      roles ??= member.roles.cache;
      const roleOverwrites = [];
      let memberOverwrites;
      let everyoneOverwrites;
      for (const overwrite of this.permissionOverwrites.cache.values()) {
        if (overwrite.id === this.guild.id) {
          everyoneOverwrites = overwrite;
        } else if (roles.has(overwrite.id)) {
          roleOverwrites.push(overwrite);
        } else if (overwrite.id === member.id) {
          memberOverwrites = overwrite;
        }
      }
      return {
        everyone: everyoneOverwrites,
        roles: roleOverwrites,
        member: memberOverwrites
      };
    }
    memberPermissions(member, checkAdmin) {
      if (checkAdmin && member.id === this.guild.ownerId) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const roles = member.roles.cache;
      const permissions = new PermissionsBitField(roles.map((role) => role.permissions));
      if (checkAdmin && permissions.has(PermissionFlagsBits.Administrator)) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const overwrites = this.overwritesFor(member, true, roles);
      return permissions.remove(overwrites.everyone?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.everyone?.allow ?? PermissionsBitField.DefaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : PermissionsBitField.DefaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : PermissionsBitField.DefaultBit).remove(overwrites.member?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.member?.allow ?? PermissionsBitField.DefaultBit).freeze();
    }
    rolePermissions(role, checkAdmin) {
      if (checkAdmin && role.permissions.has(PermissionFlagsBits.Administrator)) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);
      const roleOverwrites = this.permissionOverwrites.cache.get(role.id);
      return role.permissions.remove(everyoneOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(everyoneOverwrites?.allow ?? PermissionsBitField.DefaultBit).remove(roleOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(roleOverwrites?.allow ?? PermissionsBitField.DefaultBit).freeze();
    }
    async lockPermissions() {
      if (!this.parent)
        throw new DiscordjsError(ErrorCodes.GuildChannelOrphan);
      const permissionOverwrites = this.parent.permissionOverwrites.cache.map((overwrite) => overwrite.toJSON());
      return this.edit({ permissionOverwrites });
    }
    get members() {
      return this.guild.members.cache.filter((member) => this.permissionsFor(member).has(PermissionFlagsBits.ViewChannel, false));
    }
    edit(options) {
      return this.guild.channels.edit(this, options);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setParent(channel, { lockPermissions = true, reason } = {}) {
      return this.edit({
        parent: channel ?? null,
        lockPermissions,
        reason
      });
    }
    setPosition(position, options = {}) {
      return this.guild.channels.setPosition(this, position, options);
    }
    clone(options = {}) {
      return this.guild.channels.create({
        name: options.name ?? this.name,
        permissionOverwrites: this.permissionOverwrites.cache,
        topic: this.topic,
        type: this.type,
        nsfw: this.nsfw,
        parent: this.parent,
        bitrate: this.bitrate,
        userLimit: this.userLimit,
        rateLimitPerUser: this.rateLimitPerUser,
        position: this.rawPosition,
        reason: null,
        ...options
      });
    }
    equals(channel) {
      let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
      if (equal) {
        if (this.permissionOverwrites && channel.permissionOverwrites) {
          equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);
        } else {
          equal = !this.permissionOverwrites && !channel.permissionOverwrites;
        }
      }
      return equal;
    }
    get deletable() {
      return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;
    }
    get manageable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now())
        return false;
      const bitfield = VoiceBasedChannelTypes.includes(this.type) ? PermissionFlagsBits.ManageChannels | PermissionFlagsBits.Connect : PermissionFlagsBits.ViewChannel | PermissionFlagsBits.ManageChannels;
      return permissions.has(bitfield, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(PermissionFlagsBits.ViewChannel, false);
    }
    async delete(reason) {
      await this.guild.channels.delete(this.id, reason);
      return this;
    }
  }
  module.exports = GuildChannel;
});

// node_modules/discord.js/src/util/SKUFlagsBitField.js
var require_SKUFlagsBitField = __commonJS((exports) => {
  var { SKUFlags } = require_v106();
  var BitField = require_BitField();

  class SKUFlagsBitField extends BitField {
    static Flags = SKUFlags;
  }
  exports.SKUFlagsBitField = SKUFlagsBitField;
});

// node_modules/discord.js/src/structures/SKU.js
var require_SKU = __commonJS((exports) => {
  var Base = require_Base();
  var { SKUFlagsBitField } = require_SKUFlagsBitField();

  class SKU extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.type = data.type;
      this.applicationId = data.application_id;
      this.name = data.name;
      this.slug = data.slug;
      this.flags = new SKUFlagsBitField(data.flags).freeze();
    }
  }
  exports.SKU = SKU;
});

// node_modules/discord.js/src/util/Util.js
var require_Util = __commonJS((exports, module) => {
  var flatten = function(obj, ...props) {
    if (!isObject(obj))
      return obj;
    const objProps = Object.keys(obj).filter((key) => !key.startsWith("_")).map((key) => ({ [key]: true }));
    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);
    const out = {};
    for (let [prop, newProp] of Object.entries(props)) {
      if (!newProp)
        continue;
      newProp = newProp === true ? prop : newProp;
      const element = obj[prop];
      const elemIsObj = isObject(element);
      const valueOf = elemIsObj && typeof element.valueOf === "function" ? element.valueOf() : null;
      const hasToJSON = elemIsObj && typeof element.toJSON === "function";
      if (element instanceof Collection)
        out[newProp] = Array.from(element.keys());
      else if (valueOf instanceof Collection)
        out[newProp] = Array.from(valueOf.keys());
      else if (Array.isArray(element))
        out[newProp] = element.map((elm) => elm.toJSON?.() ?? flatten(elm));
      else if (typeof valueOf !== "object")
        out[newProp] = valueOf;
      else if (hasToJSON)
        out[newProp] = element.toJSON();
      else if (typeof element === "object")
        out[newProp] = flatten(element);
      else if (!elemIsObj)
        out[newProp] = element;
    }
    return out;
  };
  async function fetchRecommendedShardCount(token, { guildsPerShard = 1000, multipleOf = 1 } = {}) {
    if (!token)
      throw new DiscordjsError(ErrorCodes.TokenMissing);
    const response = await fetch2(RouteBases.api + Routes.gatewayBot(), {
      method: "GET",
      headers: { Authorization: `Bot ${token.replace(/^Bot\s*/i, "")}` }
    });
    if (!response.ok) {
      if (response.status === 401)
        throw new DiscordjsError(ErrorCodes.TokenInvalid);
      throw response;
    }
    const { shards } = await response.json();
    return Math.ceil(shards * (1000 / guildsPerShard) / multipleOf) * multipleOf;
  }
  var parseEmoji = function(text) {
    if (text.includes("%"))
      text = decodeURIComponent(text);
    if (!text.includes(":"))
      return { animated: false, name: text, id: undefined };
    const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
    return match && { animated: Boolean(match[1]), name: match[2], id: match[3] };
  };
  var resolvePartialEmoji = function(emoji) {
    if (!emoji)
      return null;
    if (typeof emoji === "string")
      return /^\d{17,19}$/.test(emoji) ? { id: emoji } : parseEmoji(emoji);
    const { id, name, animated } = emoji;
    if (!id && !name)
      return null;
    return { id, name, animated: Boolean(animated) };
  };
  var makeError = function(obj) {
    const err = new Error(obj.message);
    err.name = obj.name;
    err.stack = obj.stack;
    return err;
  };
  var makePlainError = function(err) {
    return {
      name: err.name,
      message: err.message,
      stack: err.stack
    };
  };
  var getSortableGroupTypes = function(type) {
    switch (type) {
      case ChannelType.GuildText:
      case ChannelType.GuildAnnouncement:
      case ChannelType.GuildForum:
      case ChannelType.GuildMedia:
        return TextSortableGroupTypes;
      case ChannelType.GuildVoice:
      case ChannelType.GuildStageVoice:
        return VoiceSortableGroupTypes;
      case ChannelType.GuildCategory:
        return CategorySortableGroupTypes;
      default:
        return [type];
    }
  };
  var moveElementInArray = function(array, element, newIndex, offset = false) {
    const index = array.indexOf(element);
    newIndex = (offset ? index : 0) + newIndex;
    if (newIndex > -1 && newIndex < array.length) {
      const removedElement = array.splice(index, 1)[0];
      array.splice(newIndex, 0, removedElement);
    }
    return array.indexOf(element);
  };
  var verifyString = function(data, error = Error, errorMessage = `Expected a string, got ${data} instead.`, allowEmpty = true) {
    if (typeof data !== "string")
      throw new error(errorMessage);
    if (!allowEmpty && data.length === 0)
      throw new error(errorMessage);
    return data;
  };
  var resolveColor = function(color) {
    let resolvedColor;
    if (typeof color === "string") {
      if (color === "Random")
        return Math.floor(Math.random() * (16777215 + 1));
      if (color === "Default")
        return 0;
      if (/^#?[\da-f]{6}$/i.test(color))
        return parseInt(color.replace("#", ""), 16);
      resolvedColor = Colors[color];
    } else if (Array.isArray(color)) {
      resolvedColor = (color[0] << 16) + (color[1] << 8) + color[2];
    } else {
      resolvedColor = color;
    }
    if (!Number.isInteger(resolvedColor)) {
      throw new DiscordjsTypeError(ErrorCodes.ColorConvert, color);
    }
    if (resolvedColor < 0 || resolvedColor > 16777215) {
      throw new DiscordjsRangeError(ErrorCodes.ColorRange);
    }
    return resolvedColor;
  };
  var discordSort = function(collection) {
    const isGuildChannel = collection.first() instanceof GuildChannel;
    return collection.sorted(isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id)));
  };
  async function setPosition(item, position, relative, sorted, client, route, reason) {
    let updatedItems = [...sorted.values()];
    moveElementInArray(updatedItems, item, position, relative);
    updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));
    await client.rest.patch(route, { body: updatedItems, reason });
    return updatedItems;
  }
  var basename = function(path, ext) {
    const res = parse(path);
    return ext && res.ext.startsWith(ext) ? res.name : res.base.split("?")[0];
  };
  var cleanContent = function(str, channel) {
    return str.replaceAll(/<(?:(?<type>@[!&]?|#)|(?:\/(?<commandName>[-_\p{L}\p{N}\p{sc=Deva}\p{sc=Thai} ]+):)|(?:a?:(?<emojiName>[\w]+):))(?<id>\d{17,19})>/gu, (match, type, commandName, emojiName, id) => {
      if (commandName)
        return `/${commandName}`;
      if (emojiName)
        return `:${emojiName}:`;
      switch (type) {
        case "@":
        case "@!": {
          const member = channel.guild?.members.cache.get(id);
          if (member) {
            return `@${member.displayName}`;
          }
          const user = channel.client.users.cache.get(id);
          return user ? `@${user.displayName}` : match;
        }
        case "@&": {
          if (channel.type === ChannelType.DM)
            return match;
          const role = channel.guild.roles.cache.get(id);
          return role ? `@${role.name}` : match;
        }
        case "#": {
          const mentionedChannel = channel.client.channels.cache.get(id);
          return mentionedChannel ? `#${mentionedChannel.name}` : match;
        }
        default: {
          return match;
        }
      }
    });
  };
  var cleanCodeBlockContent = function(text) {
    return text.replaceAll("```", "`\u200B``");
  };
  var parseWebhookURL = function(url) {
    const matches = url.match(/https?:\/\/(?:ptb\.|canary\.)?discord\.com\/api(?:\/v\d{1,2})?\/webhooks\/(\d{17,19})\/([\w-]{68})/i);
    if (!matches || matches.length <= 2)
      return null;
    const [, id, token] = matches;
    return {
      id,
      token
    };
  };
  var transformResolved = function({ client, guild, channel }, { members, users, channels, roles, messages, attachments } = {}) {
    const result = {};
    if (members) {
      result.members = new Collection;
      for (const [id, member] of Object.entries(members)) {
        const user = users[id];
        result.members.set(id, guild?.members._add({ user, ...member }) ?? member);
      }
    }
    if (users) {
      result.users = new Collection;
      for (const user of Object.values(users)) {
        result.users.set(user.id, client.users._add(user));
      }
    }
    if (roles) {
      result.roles = new Collection;
      for (const role of Object.values(roles)) {
        result.roles.set(role.id, guild?.roles._add(role) ?? role);
      }
    }
    if (channels) {
      result.channels = new Collection;
      for (const apiChannel of Object.values(channels)) {
        result.channels.set(apiChannel.id, client.channels._add(apiChannel, guild) ?? apiChannel);
      }
    }
    if (messages) {
      result.messages = new Collection;
      for (const message of Object.values(messages)) {
        result.messages.set(message.id, channel?.messages?._add(message) ?? message);
      }
    }
    if (attachments) {
      result.attachments = new Collection;
      for (const attachment of Object.values(attachments)) {
        const patched = new Attachment(attachment);
        result.attachments.set(attachment.id, patched);
      }
    }
    return result;
  };
  var resolveSKUId = function(resolvable) {
    if (typeof resolvable === "string")
      return resolvable;
    if (resolvable instanceof SKU)
      return resolvable.id;
    return null;
  };
  var emitDeprecationWarningForUserFetchFlags = function(name) {
    if (deprecationEmittedForUserFetchFlags)
      return;
    process2.emitWarning(`${name}#fetchFlags() is deprecated. Use ${name}#fetch() instead.`);
    deprecationEmittedForUserFetchFlags = true;
  };
  var emitDeprecationWarningForRemoveThreadMember = function(name) {
    if (deprecationEmittedForRemoveThreadMember)
      return;
    process2.emitWarning(`The reason parameter of ${name}#remove() is deprecated as Discord does not parse them. It will be removed in the next major version.`);
    deprecationEmittedForRemoveThreadMember = true;
  };
  var { parse } = import.meta.require("path");
  var process2 = import.meta.require("process");
  var { Collection } = require_dist6();
  var { ChannelType, RouteBases, Routes } = require_v106();
  var { fetch: fetch2 } = import.meta.require("undici");
  var Colors = require_Colors();
  var { DiscordjsError, DiscordjsRangeError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var isObject = (d) => typeof d === "object" && d !== null;
  var deprecationEmittedForUserFetchFlags = false;
  var deprecationEmittedForRemoveThreadMember = false;
  var TextSortableGroupTypes = [
    ChannelType.GuildText,
    ChannelType.GuildAnnouncement,
    ChannelType.GuildForum,
    ChannelType.GuildMedia
  ];
  var VoiceSortableGroupTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  var CategorySortableGroupTypes = [ChannelType.GuildCategory];
  module.exports = {
    flatten,
    fetchRecommendedShardCount,
    parseEmoji,
    resolvePartialEmoji,
    makeError,
    makePlainError,
    getSortableGroupTypes,
    moveElementInArray,
    verifyString,
    resolveColor,
    discordSort,
    setPosition,
    basename,
    cleanContent,
    cleanCodeBlockContent,
    parseWebhookURL,
    transformResolved,
    resolveSKUId,
    emitDeprecationWarningForUserFetchFlags,
    emitDeprecationWarningForRemoveThreadMember
  };
  var Attachment = require_Attachment();
  var GuildChannel = require_GuildChannel();
  var { SKU } = require_SKU();
});

// node_modules/discord.js/src/client/BaseClient.js
var require_BaseClient = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var { REST } = require_dist5();
  var { Routes } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var Options = require_Options();
  var { flatten } = require_Util();

  class BaseClient extends EventEmitter {
    constructor(options = {}) {
      super({ captureRejections: true });
      if (typeof options !== "object" || options === null) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      }
      const defaultOptions = Options.createDefault();
      this.options = {
        ...defaultOptions,
        ...options,
        presence: {
          ...defaultOptions.presence,
          ...options.presence
        },
        sweepers: {
          ...defaultOptions.sweepers,
          ...options.sweepers
        },
        ws: {
          ...defaultOptions.ws,
          ...options.ws
        },
        rest: {
          ...defaultOptions.rest,
          ...options.rest,
          userAgentAppendix: options.rest?.userAgentAppendix ? `${Options.userAgentAppendix} ${options.rest.userAgentAppendix}` : Options.userAgentAppendix
        }
      };
      this.rest = new REST(this.options.rest);
    }
    destroy() {
      this.rest.clearHashSweeper();
      this.rest.clearHandlerSweeper();
    }
    async deleteWebhook(id, { token, reason } = {}) {
      await this.rest.delete(Routes.webhook(id, token), { auth: !token, reason });
    }
    incrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners - 1);
      }
    }
    toJSON(...props) {
      return flatten(this, ...props);
    }
    async[Symbol.asyncDispose]() {
      await this.destroy();
    }
  }
  module.exports = BaseClient;
});

// node_modules/discord.js/src/util/Enums.js
var require_Enums = __commonJS((exports, module) => {
  var createEnum = function(keys) {
    const obj = {};
    for (const [index, key] of keys.entries()) {
      if (key === null)
        continue;
      obj[key] = index;
      obj[index] = key;
    }
    return obj;
  };
  module.exports = { createEnum };
});

// node_modules/discord.js/src/util/Partials.js
var require_Partials = __commonJS((exports, module) => {
  var { createEnum } = require_Enums();
  module.exports = createEnum([
    "User",
    "Channel",
    "GuildMember",
    "Message",
    "Reaction",
    "GuildScheduledEvent",
    "ThreadMember",
    "SoundboardSound"
  ]);
});

// node_modules/discord.js/src/client/actions/Action.js
var require_Action = __commonJS((exports, module) => {
  var Partials = require_Partials();

  class GenericAction {
    constructor(client) {
      this.client = client;
    }
    handle(data) {
      return data;
    }
    getPayload(data, manager, id, partialType, cache) {
      return this.client.options.partials.includes(partialType) ? manager._add(data, cache) : manager.cache.get(id);
    }
    getChannel(data) {
      const payloadData = {};
      const id = data.channel_id ?? data.id;
      if (!("recipients" in data)) {
        const recipient = data.author ?? data.user ?? { id: data.user_id };
        if (recipient.id !== this.client.user.id)
          payloadData.recipients = [recipient];
      }
      if (id !== undefined)
        payloadData.id = id;
      return data[this.client.actions.injectedChannel] ?? this.getPayload({ ...data, ...payloadData }, this.client.channels, id, Partials.Channel);
    }
    getMessage(data, channel, cache) {
      const id = data.message_id ?? data.id;
      return data[this.client.actions.injectedMessage] ?? this.getPayload({
        id,
        channel_id: channel.id,
        guild_id: data.guild_id ?? channel.guild?.id
      }, channel.messages, id, Partials.Message, cache);
    }
    getReaction(data, message, user) {
      const id = data.emoji.id ?? decodeURIComponent(data.emoji.name);
      return this.getPayload({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user?.id === this.client.user.id
      }, message.reactions, id, Partials.Reaction);
    }
    getMember(data, guild) {
      return this.getPayload(data, guild.members, data.user.id, Partials.GuildMember);
    }
    getUser(data) {
      const id = data.user_id;
      return data[this.client.actions.injectedUser] ?? this.getPayload({ id }, this.client.users, id, Partials.User);
    }
    getUserFromMember(data) {
      if (data.guild_id && data.member?.user) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (guild) {
          return guild.members._add(data.member).user;
        } else {
          return this.client.users._add(data.member.user);
        }
      }
      return this.getUser(data);
    }
    getScheduledEvent(data, guild) {
      const id = data.guild_scheduled_event_id ?? data.id;
      return this.getPayload({ id, guild_id: data.guild_id ?? guild.id }, guild.scheduledEvents, id, Partials.GuildScheduledEvent);
    }
    getThreadMember(id, manager) {
      return this.getPayload({ user_id: id }, manager, id, Partials.ThreadMember, false);
    }
    getSoundboardSound(data, guild) {
      return this.getPayload(data, guild.soundboardSounds, data.sound_id, Partials.SoundboardSound);
    }
    spreadInjectedData(data) {
      return Object.fromEntries(Object.getOwnPropertySymbols(data).map((symbol) => [symbol, data[symbol]]));
    }
  }
  module.exports = GenericAction;
});

// node_modules/discord.js/src/util/Events.js
var require_Events = __commonJS((exports, module) => {
  module.exports = {
    ApplicationCommandPermissionsUpdate: "applicationCommandPermissionsUpdate",
    AutoModerationActionExecution: "autoModerationActionExecution",
    AutoModerationRuleCreate: "autoModerationRuleCreate",
    AutoModerationRuleDelete: "autoModerationRuleDelete",
    AutoModerationRuleUpdate: "autoModerationRuleUpdate",
    CacheSweep: "cacheSweep",
    ChannelCreate: "channelCreate",
    ChannelDelete: "channelDelete",
    ChannelPinsUpdate: "channelPinsUpdate",
    ChannelUpdate: "channelUpdate",
    ClientReady: "ready",
    Debug: "debug",
    EntitlementCreate: "entitlementCreate",
    EntitlementUpdate: "entitlementUpdate",
    EntitlementDelete: "entitlementDelete",
    Error: "error",
    GuildAuditLogEntryCreate: "guildAuditLogEntryCreate",
    GuildAvailable: "guildAvailable",
    GuildBanAdd: "guildBanAdd",
    GuildBanRemove: "guildBanRemove",
    GuildCreate: "guildCreate",
    GuildDelete: "guildDelete",
    GuildEmojiCreate: "emojiCreate",
    GuildEmojiDelete: "emojiDelete",
    GuildEmojiUpdate: "emojiUpdate",
    GuildIntegrationsUpdate: "guildIntegrationsUpdate",
    GuildMemberAdd: "guildMemberAdd",
    GuildMemberAvailable: "guildMemberAvailable",
    GuildMemberRemove: "guildMemberRemove",
    GuildMembersChunk: "guildMembersChunk",
    GuildMemberUpdate: "guildMemberUpdate",
    GuildRoleCreate: "roleCreate",
    GuildRoleDelete: "roleDelete",
    GuildRoleUpdate: "roleUpdate",
    GuildScheduledEventCreate: "guildScheduledEventCreate",
    GuildScheduledEventDelete: "guildScheduledEventDelete",
    GuildScheduledEventUpdate: "guildScheduledEventUpdate",
    GuildScheduledEventUserAdd: "guildScheduledEventUserAdd",
    GuildScheduledEventUserRemove: "guildScheduledEventUserRemove",
    GuildSoundboardSoundCreate: "guildSoundboardSoundCreate",
    GuildSoundboardSoundDelete: "guildSoundboardSoundDelete",
    GuildSoundboardSoundsUpdate: "guildSoundboardSoundsUpdate",
    GuildSoundboardSoundUpdate: "guildSoundboardSoundUpdate",
    GuildStickerCreate: "stickerCreate",
    GuildStickerDelete: "stickerDelete",
    GuildStickerUpdate: "stickerUpdate",
    GuildUnavailable: "guildUnavailable",
    GuildUpdate: "guildUpdate",
    InteractionCreate: "interactionCreate",
    Invalidated: "invalidated",
    InviteCreate: "inviteCreate",
    InviteDelete: "inviteDelete",
    MessageBulkDelete: "messageDeleteBulk",
    MessageCreate: "messageCreate",
    MessageDelete: "messageDelete",
    MessagePollVoteAdd: "messagePollVoteAdd",
    MessagePollVoteRemove: "messagePollVoteRemove",
    MessageReactionAdd: "messageReactionAdd",
    MessageReactionRemove: "messageReactionRemove",
    MessageReactionRemoveAll: "messageReactionRemoveAll",
    MessageReactionRemoveEmoji: "messageReactionRemoveEmoji",
    MessageUpdate: "messageUpdate",
    PresenceUpdate: "presenceUpdate",
    SoundboardSounds: "soundboardSounds",
    Raw: "raw",
    ShardDisconnect: "shardDisconnect",
    ShardError: "shardError",
    ShardReady: "shardReady",
    ShardReconnecting: "shardReconnecting",
    ShardResume: "shardResume",
    StageInstanceCreate: "stageInstanceCreate",
    StageInstanceDelete: "stageInstanceDelete",
    StageInstanceUpdate: "stageInstanceUpdate",
    SubscriptionCreate: "subscriptionCreate",
    SubscriptionUpdate: "subscriptionUpdate",
    SubscriptionDelete: "subscriptionDelete",
    ThreadCreate: "threadCreate",
    ThreadDelete: "threadDelete",
    ThreadListSync: "threadListSync",
    ThreadMembersUpdate: "threadMembersUpdate",
    ThreadMemberUpdate: "threadMemberUpdate",
    ThreadUpdate: "threadUpdate",
    TypingStart: "typingStart",
    UserUpdate: "userUpdate",
    VoiceChannelEffectSend: "voiceChannelEffectSend",
    VoiceServerUpdate: "voiceServerUpdate",
    VoiceStateUpdate: "voiceStateUpdate",
    Warn: "warn",
    WebhooksUpdate: "webhookUpdate"
  };
});

// node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js
var require_ApplicationCommandPermissionsUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ApplicationCommandPermissionsUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      client.emit(Events.ApplicationCommandPermissionsUpdate, {
        permissions: data.permissions,
        id: data.id,
        guildId: data.guild_id,
        applicationId: data.application_id
      });
    }
  }
  module.exports = ApplicationCommandPermissionsUpdateAction;
});

// node_modules/discord.js/src/structures/AutoModerationActionExecution.js
var require_AutoModerationActionExecution = __commonJS((exports, module) => {
  var { _transformAPIAutoModerationAction } = require_Transformers();

  class AutoModerationActionExecution {
    constructor(data, guild) {
      this.guild = guild;
      this.action = _transformAPIAutoModerationAction(data.action);
      this.ruleId = data.rule_id;
      this.ruleTriggerType = data.rule_trigger_type;
      this.userId = data.user_id;
      this.channelId = data.channel_id ?? null;
      this.messageId = data.message_id ?? null;
      this.alertSystemMessageId = data.alert_system_message_id ?? null;
      this.content = data.content;
      this.matchedKeyword = data.matched_keyword ?? null;
      this.matchedContent = data.matched_content ?? null;
    }
    get autoModerationRule() {
      return this.guild.autoModerationRules.cache.get(this.ruleId) ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get user() {
      return this.guild.client.users.cache.get(this.userId) ?? null;
    }
    get member() {
      return this.guild.members.cache.get(this.userId) ?? null;
    }
  }
  module.exports = AutoModerationActionExecution;
});

// node_modules/discord.js/src/client/actions/AutoModerationActionExecution.js
var require_AutoModerationActionExecution2 = __commonJS((exports, module) => {
  var Action = require_Action();
  var AutoModerationActionExecution = require_AutoModerationActionExecution();
  var Events = require_Events();

  class AutoModerationActionExecutionAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        client.emit(Events.AutoModerationActionExecution, new AutoModerationActionExecution(data, guild));
      }
      return {};
    }
  }
  module.exports = AutoModerationActionExecutionAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleCreate.js
var require_AutoModerationRuleCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleCreateAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const autoModerationRule = guild.autoModerationRules._add(data);
        client.emit(Events.AutoModerationRuleCreate, autoModerationRule);
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleCreateAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleDelete.js
var require_AutoModerationRuleDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleDeleteAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const autoModerationRule = guild.autoModerationRules.cache.get(data.id);
        if (autoModerationRule) {
          guild.autoModerationRules.cache.delete(autoModerationRule.id);
          client.emit(Events.AutoModerationRuleDelete, autoModerationRule);
        }
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleDeleteAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleUpdate.js
var require_AutoModerationRuleUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleUpdateAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldAutoModerationRule = guild.autoModerationRules.cache.get(data.id)?._clone() ?? null;
        const newAutoModerationRule = guild.autoModerationRules._add(data);
        client.emit(Events.AutoModerationRuleUpdate, oldAutoModerationRule, newAutoModerationRule);
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleUpdateAction;
});

// node_modules/discord.js/src/client/actions/ChannelCreate.js
var require_ChannelCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ChannelCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const channel = client.channels._add(data);
      if (!existing && channel) {
        client.emit(Events.ChannelCreate, channel);
      }
      return { channel };
    }
  }
  module.exports = ChannelCreateAction;
});

// node_modules/discord.js/src/client/actions/ChannelDelete.js
var require_ChannelDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ChannelDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.id);
      if (channel) {
        client.channels._remove(channel.id);
        client.emit(Events.ChannelDelete, channel);
      }
    }
  }
  module.exports = ChannelDeleteAction;
});

// node_modules/discord.js/src/managers/CategoryChannelChildManager.js
var require_CategoryChannelChildManager = __commonJS((exports, module) => {
  var DataManager = require_DataManager();
  var GuildChannel = require_GuildChannel();

  class CategoryChannelChildManager extends DataManager {
    constructor(channel) {
      super(channel.client, GuildChannel);
      this.channel = channel;
    }
    get cache() {
      return this.guild.channels.cache.filter((channel) => channel.parentId === this.channel.id);
    }
    get guild() {
      return this.channel.guild;
    }
    create(options) {
      return this.guild.channels.create({
        ...options,
        parent: this.channel.id
      });
    }
  }
  module.exports = CategoryChannelChildManager;
});

// node_modules/discord.js/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var CategoryChannelChildManager = require_CategoryChannelChildManager();

  class CategoryChannel extends GuildChannel {
    get children() {
      return new CategoryChannelChildManager(this);
    }
  }
  module.exports = CategoryChannel;
});

// node_modules/discord.js/src/structures/interfaces/Collector.js
var require_Collector = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = import.meta.require("timers");
  var { Collection } = require_dist6();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { flatten } = require_Util();

  class Collector extends EventEmitter {
    constructor(client, options = {}) {
      super();
      Object.defineProperty(this, "client", { value: client });
      this.filter = options.filter ?? (() => true);
      this.options = options;
      this.collected = new Collection;
      this.ended = false;
      this._timeout = null;
      this._idletimeout = null;
      this._endReason = null;
      if (typeof this.filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.filter", "function");
      }
      this.handleCollect = this.handleCollect.bind(this);
      this.handleDispose = this.handleDispose.bind(this);
      if (options.time)
        this._timeout = setTimeout2(() => this.stop("time"), options.time).unref();
      if (options.idle)
        this._idletimeout = setTimeout2(() => this.stop("idle"), options.idle).unref();
      this.lastCollectedTimestamp = null;
    }
    get lastCollectedAt() {
      return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);
    }
    async handleCollect(...args) {
      const collectedId = await this.collect(...args);
      if (collectedId) {
        const filterResult = await this.filter(...args, this.collected);
        if (filterResult) {
          this.collected.set(collectedId, args[0]);
          this.emit("collect", ...args);
          this.lastCollectedTimestamp = Date.now();
          if (this._idletimeout) {
            clearTimeout2(this._idletimeout);
            this._idletimeout = setTimeout2(() => this.stop("idle"), this.options.idle).unref();
          }
        } else {
          this.emit("ignore", ...args);
        }
      }
      this.checkEnd();
    }
    async handleDispose(...args) {
      if (!this.options.dispose)
        return;
      const dispose = this.dispose(...args);
      if (!dispose || !await this.filter(...args) || !this.collected.has(dispose))
        return;
      this.collected.delete(dispose);
      this.emit("dispose", ...args);
      this.checkEnd();
    }
    get next() {
      return new Promise((resolve, reject) => {
        if (this.ended) {
          reject(this.collected);
          return;
        }
        const cleanup = () => {
          this.removeListener("collect", onCollect);
          this.removeListener("end", onEnd);
        };
        const onCollect = (item) => {
          cleanup();
          resolve(item);
        };
        const onEnd = () => {
          cleanup();
          reject(this.collected);
        };
        this.on("collect", onCollect);
        this.on("end", onEnd);
      });
    }
    stop(reason = "user") {
      if (this.ended)
        return;
      if (this._timeout) {
        clearTimeout2(this._timeout);
        this._timeout = null;
      }
      if (this._idletimeout) {
        clearTimeout2(this._idletimeout);
        this._idletimeout = null;
      }
      this._endReason = reason;
      this.ended = true;
      this.emit("end", this.collected, reason);
    }
    resetTimer({ time, idle } = {}) {
      if (this._timeout) {
        clearTimeout2(this._timeout);
        this._timeout = setTimeout2(() => this.stop("time"), time ?? this.options.time).unref();
      }
      if (this._idletimeout) {
        clearTimeout2(this._idletimeout);
        this._idletimeout = setTimeout2(() => this.stop("idle"), idle ?? this.options.idle).unref();
      }
    }
    checkEnd() {
      const reason = this.endReason;
      if (reason)
        this.stop(reason);
      return Boolean(reason);
    }
    async* [Symbol.asyncIterator]() {
      const queue = [];
      const onCollect = (...item) => queue.push(item);
      this.on("collect", onCollect);
      try {
        while (queue.length || !this.ended) {
          if (queue.length) {
            yield queue.shift();
          } else {
            await new Promise((resolve) => {
              const tick = () => {
                this.removeListener("collect", tick);
                this.removeListener("end", tick);
                return resolve();
              };
              this.on("collect", tick);
              this.on("end", tick);
            });
          }
        }
      } finally {
        this.removeListener("collect", onCollect);
      }
    }
    toJSON() {
      return flatten(this);
    }
    get endReason() {
      return this._endReason;
    }
    collect() {
    }
    dispose() {
    }
  }
  module.exports = Collector;
});

// node_modules/discord.js/src/structures/InteractionCollector.js
var require_InteractionCollector = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Collector = require_Collector();
  var Events = require_Events();

  class InteractionCollector extends Collector {
    constructor(client, options = {}) {
      super(client, options);
      this.messageId = options.message?.id ?? options.interactionResponse?.interaction.message?.id ?? null;
      this.messageInteractionId = options.interactionResponse?.id ?? null;
      this.channelId = options.interactionResponse?.interaction.channelId ?? options.message?.channelId ?? options.message?.channel_id ?? this.client.channels.resolveId(options.channel);
      this.guildId = options.interactionResponse?.interaction.guildId ?? options.message?.guildId ?? options.message?.guild_id ?? this.client.guilds.resolveId(options.channel?.guild) ?? this.client.guilds.resolveId(options.guild);
      this.interactionType = options.interactionType ?? null;
      this.componentType = options.componentType ?? null;
      this.users = new Collection;
      this.total = 0;
      this.client.incrementMaxListeners();
      const bulkDeleteListener = (messages) => {
        if (messages.has(this.messageId))
          this.stop("messageDelete");
      };
      if (this.messageId || this.messageInteractionId) {
        this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
        this.client.on(Events.MessageDelete, this._handleMessageDeletion);
        this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      }
      if (this.channelId) {
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      }
      if (this.guildId) {
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      }
      this.client.on(Events.InteractionCreate, this.handleCollect);
      this.once("end", () => {
        this.client.removeListener(Events.InteractionCreate, this.handleCollect);
        this.client.removeListener(Events.MessageDelete, this._handleMessageDeletion);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (interaction) => {
        this.total++;
        this.users.set(interaction.user.id, interaction.user);
      });
    }
    collect(interaction) {
      if (this.interactionType && interaction.type !== this.interactionType)
        return null;
      if (this.componentType && interaction.componentType !== this.componentType)
        return null;
      if (this.messageId && interaction.message?.id !== this.messageId)
        return null;
      if (this.messageInteractionId && interaction.message?.interactionMetadata?.id && interaction.message.interactionMetadata.id !== this.messageInteractionId) {
        return null;
      }
      if (this.channelId && interaction.channelId !== this.channelId)
        return null;
      if (this.guildId && interaction.guildId !== this.guildId)
        return null;
      return interaction.id;
    }
    dispose(interaction) {
      if (this.type && interaction.type !== this.type)
        return null;
      if (this.componentType && interaction.componentType !== this.componentType)
        return null;
      if (this.messageId && interaction.message?.id !== this.messageId)
        return null;
      if (this.messageInteractionId && interaction.message?.interactionMetadata?.id && interaction.message.interactionMetadata.id !== this.messageInteractionId) {
        return null;
      }
      if (this.channelId && interaction.channelId !== this.channelId)
        return null;
      if (this.guildId && interaction.guildId !== this.guildId)
        return null;
      return interaction.id;
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    get endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxComponents && this.collected.size >= this.options.maxComponents)
        return "componentLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return super.endReason;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.messageId) {
        this.stop("messageDelete");
      }
      if (message.interactionMetadata?.id === this.messageInteractionId) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channelId || channel.threads?.cache.has(this.channelId)) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.channelId) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.guildId) {
        this.stop("guildDelete");
      }
    }
  }
  module.exports = InteractionCollector;
});

// node_modules/discord.js/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS((exports, module) => {
  var Collector = require_Collector();
  var Events = require_Events();

  class MessageCollector extends Collector {
    constructor(channel, options = {}) {
      super(channel.client, options);
      this.channel = channel;
      this.received = 0;
      const bulkDeleteListener = (messages) => {
        for (const message of messages.values())
          this.handleDispose(message);
      };
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this.client.incrementMaxListeners();
      this.client.on(Events.MessageCreate, this.handleCollect);
      this.client.on(Events.MessageDelete, this.handleDispose);
      this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
      this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events.MessageCreate, this.handleCollect);
        this.client.removeListener(Events.MessageDelete, this.handleDispose);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
    }
    collect(message) {
      if (message.channelId !== this.channel.id)
        return null;
      this.received++;
      return message.id;
    }
    dispose(message) {
      return message.channelId === this.channel.id ? message.id : null;
    }
    get endReason() {
      if (this.options.max && this.collected.size >= this.options.max)
        return "limit";
      if (this.options.maxProcessed && this.received === this.options.maxProcessed)
        return "processedLimit";
      return super.endReason;
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channel.id || channel.id === this.channel.parentId) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.channel.id) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.channel.guild?.id) {
        this.stop("guildDelete");
      }
    }
  }
  module.exports = MessageCollector;
});

// node_modules/discord.js/src/structures/GuildTemplate.js
var require_GuildTemplate = __commonJS((exports, module) => {
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = import.meta.require("timers");
  var { RouteBases, Routes } = require_v106();
  var Base = require_Base();
  var { resolveImage } = require_DataResolver();
  var Events = require_Events();

  class GuildTemplate extends Base {
    static GuildTemplatesPattern = /discord(?:app)?\.(?:com\/template|new)\/(?<code>[\w-]{2,255})/i;
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      if ("code" in data) {
        this.code = data.code;
      }
      if ("name" in data) {
        this.name = data.name;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("usage_count" in data) {
        this.usageCount = data.usage_count;
      }
      if ("creator_id" in data) {
        this.creatorId = data.creator_id;
      }
      if ("creator" in data) {
        this.creator = this.client.users._add(data.creator);
      }
      if ("created_at" in data) {
        this.createdTimestamp = Date.parse(data.created_at);
      }
      if ("updated_at" in data) {
        this.updatedTimestamp = Date.parse(data.updated_at);
      }
      if ("source_guild_id" in data) {
        this.guildId = data.source_guild_id;
      }
      if ("serialized_source_guild" in data) {
        this.serializedGuild = data.serialized_source_guild;
      }
      this.unSynced = "is_dirty" in data ? Boolean(data.is_dirty) : null;
      return this;
    }
    async createGuild(name, icon) {
      const { client } = this;
      const data = await client.rest.post(Routes.template(this.code), {
        body: {
          name,
          icon: await resolveImage(icon)
        }
      });
      if (client.guilds.cache.has(data.id))
        return client.guilds.cache.get(data.id);
      return new Promise((resolve) => {
        const resolveGuild = (guild) => {
          client.off(Events.GuildCreate, handleGuild);
          client.decrementMaxListeners();
          resolve(guild);
        };
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            clearTimeout2(timeout);
            resolveGuild(guild);
          }
        };
        client.incrementMaxListeners();
        client.on(Events.GuildCreate, handleGuild);
        const timeout = setTimeout2(() => resolveGuild(client.guilds._add(data)), 1e4).unref();
      });
    }
    async edit({ name, description } = {}) {
      const data = await this.client.rest.patch(Routes.guildTemplate(this.guildId, this.code), {
        body: { name, description }
      });
      return this._patch(data);
    }
    async delete() {
      await this.client.rest.delete(Routes.guildTemplate(this.guildId, this.code));
      return this;
    }
    async sync() {
      const data = await this.client.rest.put(Routes.guildTemplate(this.guildId, this.code));
      return this._patch(data);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get updatedAt() {
      return new Date(this.updatedTimestamp);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return `${RouteBases.template}/${this.code}`;
    }
    toString() {
      return this.code;
    }
  }
  module.exports = GuildTemplate;
});

// node_modules/discord.js/src/structures/GuildScheduledEvent.js
var require_GuildScheduledEvent = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var { GuildScheduledEventStatus, GuildScheduledEventEntityType, RouteBases } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class GuildScheduledEvent extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.guildId = data.guild_id;
      this._patch(data);
    }
    _patch(data) {
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      } else {
        this.channelId ??= null;
      }
      if ("creator_id" in data) {
        this.creatorId = data.creator_id;
      } else {
        this.creatorId ??= null;
      }
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if ("scheduled_start_time" in data) {
        this.scheduledStartTimestamp = Date.parse(data.scheduled_start_time);
      } else {
        this.scheduledStartTimestamp ??= null;
      }
      if ("scheduled_end_time" in data) {
        this.scheduledEndTimestamp = data.scheduled_end_time ? Date.parse(data.scheduled_end_time) : null;
      } else {
        this.scheduledEndTimestamp ??= null;
      }
      if ("privacy_level" in data) {
        this.privacyLevel = data.privacy_level;
      } else {
        this.privacyLevel ??= null;
      }
      if ("status" in data) {
        this.status = data.status;
      } else {
        this.status ??= null;
      }
      if ("entity_type" in data) {
        this.entityType = data.entity_type;
      } else {
        this.entityType ??= null;
      }
      if ("entity_id" in data) {
        this.entityId = data.entity_id;
      } else {
        this.entityId ??= null;
      }
      if ("user_count" in data) {
        this.userCount = data.user_count;
      } else {
        this.userCount ??= null;
      }
      if ("creator" in data) {
        this.creator = this.client.users._add(data.creator);
      } else {
        this.creator ??= this.client.users.resolve(this.creatorId);
      }
      if ("entity_metadata" in data) {
        if (data.entity_metadata) {
          this.entityMetadata = {
            location: data.entity_metadata.location ?? this.entityMetadata?.location ?? null
          };
        } else {
          this.entityMetadata = null;
        }
      } else {
        this.entityMetadata ??= null;
      }
      if ("image" in data) {
        this.image = data.image;
      } else {
        this.image ??= null;
      }
      if ("recurrence_rule" in data) {
        this.recurrenceRule = data.recurrence_rule && {
          startTimestamp: Date.parse(data.recurrence_rule.start),
          get startAt() {
            return new Date(this.startTimestamp);
          },
          endTimestamp: data.recurrence_rule.end && Date.parse(data.recurrence_rule.end),
          get endAt() {
            return this.endTimestamp && new Date(this.endTimestamp);
          },
          frequency: data.recurrence_rule.frequency,
          interval: data.recurrence_rule.interval,
          byWeekday: data.recurrence_rule.by_weekday,
          byNWeekday: data.recurrence_rule.by_n_weekday,
          byMonth: data.recurrence_rule.by_month,
          byMonthDay: data.recurrence_rule.by_month_day,
          byYearDay: data.recurrence_rule.by_year_day,
          count: data.recurrence_rule.count
        };
      } else {
        this.recurrenceRule ??= null;
      }
    }
    get partial() {
      return this.name === null;
    }
    coverImageURL(options = {}) {
      return this.image && this.client.rest.cdn.guildScheduledEventCover(this.id, this.image, options);
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get scheduledStartAt() {
      return this.scheduledStartTimestamp && new Date(this.scheduledStartTimestamp);
    }
    get scheduledEndAt() {
      return this.scheduledEndTimestamp && new Date(this.scheduledEndTimestamp);
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return `${RouteBases.scheduledEvent}/${this.guildId}/${this.id}`;
    }
    async createInviteURL(options) {
      let channelId = this.channelId;
      if (this.entityType === GuildScheduledEventEntityType.External) {
        if (!options?.channel)
          throw new DiscordjsError(ErrorCodes.InviteOptionsMissingChannel);
        channelId = this.guild.channels.resolveId(options.channel);
        if (!channelId)
          throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      }
      const invite = await this.guild.invites.create(channelId, options);
      return `${RouteBases.invite}/${invite.code}?event=${this.id}`;
    }
    edit(options) {
      return this.guild.scheduledEvents.edit(this.id, options);
    }
    fetch(force = true) {
      return this.guild.scheduledEvents.fetch({ guildScheduledEvent: this.id, force });
    }
    async delete() {
      await this.guild.scheduledEvents.delete(this.id);
      return this;
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setScheduledStartTime(scheduledStartTime, reason) {
      return this.edit({ scheduledStartTime, reason });
    }
    setScheduledEndTime(scheduledEndTime, reason) {
      return this.edit({ scheduledEndTime, reason });
    }
    setDescription(description, reason) {
      return this.edit({ description, reason });
    }
    setStatus(status, reason) {
      return this.edit({ status, reason });
    }
    setLocation(location, reason) {
      return this.edit({ entityMetadata: { location }, reason });
    }
    fetchSubscribers(options) {
      return this.guild.scheduledEvents.fetchSubscribers(this.id, options);
    }
    toString() {
      return this.url;
    }
    isActive() {
      return this.status === GuildScheduledEventStatus.Active;
    }
    isCanceled() {
      return this.status === GuildScheduledEventStatus.Canceled;
    }
    isCompleted() {
      return this.status === GuildScheduledEventStatus.Completed;
    }
    isScheduled() {
      return this.status === GuildScheduledEventStatus.Scheduled;
    }
  }
  exports.GuildScheduledEvent = GuildScheduledEvent;
});

// node_modules/discord.js/src/structures/interfaces/Application.js
var require_Application = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();

  class Application extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      } else {
        this.icon ??= null;
      }
      if ("terms_of_service_url" in data) {
        this.termsOfServiceURL = data.terms_of_service_url;
      } else {
        this.termsOfServiceURL ??= null;
      }
      if ("privacy_policy_url" in data) {
        this.privacyPolicyURL = data.privacy_policy_url;
      } else {
        this.privacyPolicyURL ??= null;
      }
      if ("rpc_origins" in data) {
        this.rpcOrigins = data.rpc_origins;
      } else {
        this.rpcOrigins ??= [];
      }
      if ("cover_image" in data) {
        this.cover = data.cover_image;
      } else {
        this.cover ??= null;
      }
      if ("verify_key" in data) {
        this.verifyKey = data.verify_key;
      } else {
        this.verifyKey ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.appIcon(this.id, this.icon, options);
    }
    coverURL(options = {}) {
      return this.cover && this.client.rest.cdn.appIcon(this.id, this.cover, options);
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({ createdTimestamp: true });
    }
  }
  module.exports = Application;
});

// node_modules/discord.js/src/structures/IntegrationApplication.js
var require_IntegrationApplication = __commonJS((exports, module) => {
  var Application = require_Application();

  class IntegrationApplication extends Application {
    _patch(data) {
      super._patch(data);
      if ("bot" in data) {
        this.bot = this.client.users._add(data.bot);
      } else {
        this.bot ??= null;
      }
      if ("terms_of_service_url" in data) {
        this.termsOfServiceURL = data.terms_of_service_url;
      } else {
        this.termsOfServiceURL ??= null;
      }
      if ("privacy_policy_url" in data) {
        this.privacyPolicyURL = data.privacy_policy_url;
      } else {
        this.privacyPolicyURL ??= null;
      }
      if ("rpc_origins" in data) {
        this.rpcOrigins = data.rpc_origins;
      } else {
        this.rpcOrigins ??= [];
      }
      if ("hook" in data) {
        this.hook = data.hook;
      } else {
        this.hook ??= null;
      }
      if ("cover_image" in data) {
        this.cover = data.cover_image;
      } else {
        this.cover ??= null;
      }
      if ("verify_key" in data) {
        this.verifyKey = data.verify_key;
      } else {
        this.verifyKey ??= null;
      }
    }
  }
  module.exports = IntegrationApplication;
});

// node_modules/discord.js/src/structures/InviteStageInstance.js
var require_InviteStageInstance = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Base = require_Base();

  class InviteStageInstance extends Base {
    constructor(client, data, channelId, guildId) {
      super(client);
      this.channelId = channelId;
      this.guildId = guildId;
      this.members = new Collection;
      this._patch(data);
    }
    _patch(data) {
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("participant_count" in data) {
        this.participantCount = data.participant_count;
      }
      if ("speaker_count" in data) {
        this.speakerCount = data.speaker_count;
      }
      this.members.clear();
      for (const rawMember of data.members) {
        const member = this.guild.members._add(rawMember);
        this.members.set(member.id, member);
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
  }
  module.exports = InviteStageInstance;
});

// node_modules/discord.js/src/structures/BaseGuild.js
var require_BaseGuild = __commonJS((exports, module) => {
  var { makeURLSearchParams } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var { Routes, GuildFeature } = require_v106();
  var Base = require_Base();

  class BaseGuild extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.name = data.name;
      this.icon = data.icon;
      this.features = data.features;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get nameAcronym() {
      return this.name.replace(/'s /g, " ").replace(/\w+/g, (e) => e[0]).replace(/\s/g, "");
    }
    get partnered() {
      return this.features.includes(GuildFeature.Partnered);
    }
    get verified() {
      return this.features.includes(GuildFeature.Verified);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guild(this.id), {
        query: makeURLSearchParams({ with_counts: true })
      });
      return this.client.guilds._add(data);
    }
    toString() {
      return this.name;
    }
  }
  module.exports = BaseGuild;
});

// node_modules/discord.js/src/structures/AnonymousGuild.js
var require_AnonymousGuild = __commonJS((exports, module) => {
  var BaseGuild = require_BaseGuild();

  class AnonymousGuild extends BaseGuild {
    constructor(client, data, immediatePatch = true) {
      super(client, data);
      if (immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      if ("features" in data)
        this.features = data.features;
      if ("splash" in data) {
        this.splash = data.splash;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("verification_level" in data) {
        this.verificationLevel = data.verification_level;
      }
      if ("vanity_url_code" in data) {
        this.vanityURLCode = data.vanity_url_code;
      }
      if ("nsfw_level" in data) {
        this.nsfwLevel = data.nsfw_level;
      }
      if ("premium_subscription_count" in data) {
        this.premiumSubscriptionCount = data.premium_subscription_count;
      } else {
        this.premiumSubscriptionCount ??= null;
      }
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
    }
    splashURL(options = {}) {
      return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
    }
  }
  module.exports = AnonymousGuild;
});

// node_modules/discord.js/src/structures/Emoji.js
var require_Emoji = __commonJS((exports) => {
  var process2 = import.meta.require("process");
  var { formatEmoji } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var deprecationEmittedForURL = false;

  class Emoji extends Base {
    constructor(client, emoji) {
      super(client);
      this.animated = emoji.animated ?? null;
      this.name = emoji.name ?? null;
      this.id = emoji.id ?? null;
    }
    get identifier() {
      if (this.id)
        return `${this.animated ? "a:" : ""}${this.name}:${this.id}`;
      return encodeURIComponent(this.name);
    }
    imageURL(options) {
      return this.id && this.client.rest.cdn.emoji(this.id, options);
    }
    get url() {
      if (!deprecationEmittedForURL) {
        process2.emitWarning("The Emoji#url getter is deprecated. Use Emoji#imageURL() instead.", "DeprecationWarning");
        deprecationEmittedForURL = true;
      }
      return this.imageURL({ extension: this.animated ? "gif" : "png" });
    }
    get createdTimestamp() {
      return this.id && DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return this.id && new Date(this.createdTimestamp);
    }
    toString() {
      return this.id ? formatEmoji({ animated: this.animated, id: this.id, name: this.name }) : this.name;
    }
    toJSON() {
      const json = super.toJSON({
        guild: "guildId",
        createdTimestamp: true,
        identifier: true
      });
      json.imageURL = this.imageURL();
      return json;
    }
  }
  exports.Emoji = Emoji;
});

// node_modules/discord.js/src/structures/WelcomeChannel.js
var require_WelcomeChannel = __commonJS((exports, module) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class WelcomeChannel extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.description = data.description;
      this._emoji = {
        name: data.emoji_name,
        id: data.emoji_id
      };
      this.channelId = data.channel_id;
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get emoji() {
      return this.client.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
  }
  module.exports = WelcomeChannel;
});

// node_modules/discord.js/src/structures/WelcomeScreen.js
var require_WelcomeScreen = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { GuildFeature } = require_v106();
  var Base = require_Base();
  var WelcomeChannel = require_WelcomeChannel();

  class WelcomeScreen extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.description = data.description ?? null;
      this.welcomeChannels = new Collection;
      for (const channel of data.welcome_channels) {
        const welcomeChannel = new WelcomeChannel(this.guild, channel);
        this.welcomeChannels.set(welcomeChannel.channelId, welcomeChannel);
      }
    }
    get enabled() {
      return this.guild.features.includes(GuildFeature.WelcomeScreenEnabled);
    }
  }
  module.exports = WelcomeScreen;
});

// node_modules/discord.js/src/structures/InviteGuild.js
var require_InviteGuild = __commonJS((exports, module) => {
  var AnonymousGuild = require_AnonymousGuild();
  var WelcomeScreen = require_WelcomeScreen();

  class InviteGuild extends AnonymousGuild {
    constructor(client, data) {
      super(client, data);
      this.welcomeScreen = data.welcome_screen !== undefined ? new WelcomeScreen(this, data.welcome_screen) : null;
    }
  }
  module.exports = InviteGuild;
});

// node_modules/discord.js/src/structures/Invite.js
var require_Invite = __commonJS((exports, module) => {
  var { RouteBases, Routes, PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var IntegrationApplication = require_IntegrationApplication();
  var InviteStageInstance = require_InviteStageInstance();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class Invite extends Base {
    static InvitesPattern = /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/(?<code>[\w-]{2,255})/i;
    constructor(client, data) {
      super(client);
      this.type = data.type;
      this._patch(data);
    }
    _patch(data) {
      const InviteGuild = require_InviteGuild();
      this.guild ??= null;
      if (data.guild) {
        this.guild = this.client.guilds.cache.get(data.guild.id) ?? new InviteGuild(this.client, data.guild);
      }
      if ("code" in data) {
        this.code = data.code;
      }
      if ("approximate_presence_count" in data) {
        this.presenceCount = data.approximate_presence_count;
      } else {
        this.presenceCount ??= null;
      }
      if ("approximate_member_count" in data) {
        this.memberCount = data.approximate_member_count;
      } else {
        this.memberCount ??= null;
      }
      if ("temporary" in data) {
        this.temporary = data.temporary ?? null;
      } else {
        this.temporary ??= null;
      }
      if ("max_age" in data) {
        this.maxAge = data.max_age;
      } else {
        this.maxAge ??= null;
      }
      if ("uses" in data) {
        this.uses = data.uses;
      } else {
        this.uses ??= null;
      }
      if ("max_uses" in data) {
        this.maxUses = data.max_uses;
      } else {
        this.maxUses ??= null;
      }
      if ("inviter_id" in data) {
        this.inviterId = data.inviter_id;
      } else {
        this.inviterId ??= null;
      }
      if ("inviter" in data) {
        this.client.users._add(data.inviter);
        this.inviterId = data.inviter.id;
      }
      if ("target_user" in data) {
        this.targetUser = this.client.users._add(data.target_user);
      } else {
        this.targetUser ??= null;
      }
      if ("target_application" in data) {
        this.targetApplication = new IntegrationApplication(this.client, data.target_application);
      } else {
        this.targetApplication ??= null;
      }
      if ("target_type" in data) {
        this.targetType = data.target_type;
      } else {
        this.targetType ??= null;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("channel" in data) {
        this.channel = this.client.channels._add(data.channel, this.guild, { cache: false }) ?? this.client.channels.resolve(this.channelId);
        this.channelId ??= data.channel.id;
      }
      if ("created_at" in data) {
        this.createdTimestamp = Date.parse(data.created_at);
      } else {
        this.createdTimestamp ??= null;
      }
      if ("expires_at" in data) {
        this._expiresTimestamp = data.expires_at && Date.parse(data.expires_at);
      } else {
        this._expiresTimestamp ??= null;
      }
      if ("stage_instance" in data) {
        this.stageInstance = new InviteStageInstance(this.client, data.stage_instance, this.channel.id, this.guild.id);
      } else {
        this.stageInstance ??= null;
      }
      if ("guild_scheduled_event" in data) {
        this.guildScheduledEvent = new GuildScheduledEvent(this.client, data.guild_scheduled_event);
      } else {
        this.guildScheduledEvent ??= null;
      }
    }
    get createdAt() {
      return this.createdTimestamp && new Date(this.createdTimestamp);
    }
    get deletable() {
      const guild = this.guild;
      if (!guild || !this.client.guilds.cache.has(guild.id))
        return false;
      if (!guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return Boolean(this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageChannels, false) || guild.members.me.permissions.has(PermissionFlagsBits.ManageGuild));
    }
    get expiresTimestamp() {
      return this._expiresTimestamp ?? (this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1000 : null);
    }
    get expiresAt() {
      return this.expiresTimestamp && new Date(this.expiresTimestamp);
    }
    get inviter() {
      return this.inviterId && this.client.users.resolve(this.inviterId);
    }
    get url() {
      return `${RouteBases.invite}/${this.code}`;
    }
    async delete(reason) {
      await this.client.rest.delete(Routes.invite(this.code), { reason });
      return this;
    }
    toString() {
      return this.url;
    }
    toJSON() {
      return super.toJSON({
        url: true,
        expiresTimestamp: true,
        presenceCount: false,
        memberCount: false,
        uses: false,
        channel: "channelId",
        inviter: "inviterId",
        guild: "guildId"
      });
    }
    valueOf() {
      return this.code;
    }
  }
  module.exports = Invite;
});

// node_modules/discord.js/src/util/DataResolver.js
var require_DataResolver = __commonJS((exports, module) => {
  var resolveCode = function(data, regex) {
    return regex.exec(data)?.[1] ?? data;
  };
  var resolveInviteCode = function(data) {
    return resolveCode(data, Invite.InvitesPattern);
  };
  var resolveGuildTemplateCode = function(data) {
    const GuildTemplate = require_GuildTemplate();
    return resolveCode(data, GuildTemplate.GuildTemplatesPattern);
  };
  async function resolveFile(resource) {
    if (Buffer2.isBuffer(resource))
      return { data: resource };
    if (typeof resource[Symbol.asyncIterator] === "function") {
      const buffers = [];
      for await (const data of resource)
        buffers.push(Buffer2.from(data));
      return { data: Buffer2.concat(buffers) };
    }
    if (typeof resource === "string") {
      if (/^https?:\/\//.test(resource)) {
        const res = await fetch2(resource);
        return { data: Buffer2.from(await res.arrayBuffer()), contentType: res.headers.get("content-type") };
      }
      const file = path.resolve(resource);
      const stats = await fs.stat(file);
      if (!stats.isFile())
        throw new DiscordjsError(ErrorCodes.FileNotFound, file);
      return { data: await fs.readFile(file) };
    }
    throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
  }
  var resolveBase64 = function(data, contentType = "image/jpg") {
    if (Buffer2.isBuffer(data))
      return `data:${contentType};base64,${data.toString("base64")}`;
    return data;
  };
  async function resolveImage(image) {
    if (!image)
      return null;
    if (typeof image === "string" && image.startsWith("data:")) {
      return image;
    }
    const file = await resolveFile(image);
    return resolveBase64(file.data);
  }
  var { Buffer: Buffer2 } = import.meta.require("buffer");
  var fs = import.meta.require("fs/promises");
  var path = import.meta.require("path");
  var { fetch: fetch2 } = import.meta.require("undici");
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var Invite = require_Invite();
  module.exports = { resolveCode, resolveInviteCode, resolveGuildTemplateCode, resolveImage, resolveBase64, resolveFile };
});

// node_modules/discord.js/src/util/MessageFlagsBitField.js
var require_MessageFlagsBitField = __commonJS((exports, module) => {
  var { MessageFlags } = require_v106();
  var BitField = require_BitField();

  class MessageFlagsBitField extends BitField {
    static Flags = MessageFlags;
  }
  module.exports = MessageFlagsBitField;
});

// node_modules/discord.js/src/structures/BaseInteraction.js
var require_BaseInteraction = __commonJS((exports, module) => {
  var { deprecate } = import.meta.require("util");
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var { InteractionType, ApplicationCommandType, ComponentType } = require_v106();
  var Base = require_Base();
  var { SelectMenuTypes } = require_Constants();
  var PermissionsBitField = require_PermissionsBitField();

  class BaseInteraction extends Base {
    constructor(client, data) {
      super(client);
      this.type = data.type;
      this.id = data.id;
      Object.defineProperty(this, "token", { value: data.token });
      this.applicationId = data.application_id;
      this.channelId = data.channel?.id ?? null;
      this.guildId = data.guild_id ?? null;
      this.user = this.client.users._add(data.user ?? data.member.user);
      this.member = data.member ? this.guild?.members._add(data.member) ?? data.member : null;
      this.version = data.version;
      this.appPermissions = new PermissionsBitField(data.app_permissions).freeze();
      this.memberPermissions = data.member?.permissions ? new PermissionsBitField(data.member.permissions).freeze() : null;
      this.locale = data.locale;
      this.guildLocale = data.guild_locale ?? null;
      this.entitlements = data.entitlements.reduce((coll, entitlement) => coll.set(entitlement.id, this.client.application.entitlements._add(entitlement)), new Collection);
      this.authorizingIntegrationOwners = data.authorizing_integration_owners;
      this.context = data.context ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get channel() {
      return this.client.channels.cache.get(this.channelId) ?? null;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    inGuild() {
      return Boolean(this.guildId && this.member);
    }
    inCachedGuild() {
      return Boolean(this.guild && this.member);
    }
    inRawGuild() {
      return Boolean(this.guildId && !this.guild && this.member);
    }
    isAutocomplete() {
      return this.type === InteractionType.ApplicationCommandAutocomplete;
    }
    isCommand() {
      return this.type === InteractionType.ApplicationCommand;
    }
    isChatInputCommand() {
      return this.type === InteractionType.ApplicationCommand && this.commandType === ApplicationCommandType.ChatInput;
    }
    isContextMenuCommand() {
      return this.type === InteractionType.ApplicationCommand && [ApplicationCommandType.User, ApplicationCommandType.Message].includes(this.commandType);
    }
    isMessageComponent() {
      return this.type === InteractionType.MessageComponent;
    }
    isModalSubmit() {
      return this.type === InteractionType.ModalSubmit;
    }
    isUserContextMenuCommand() {
      return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.User;
    }
    isMessageContextMenuCommand() {
      return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.Message;
    }
    isButton() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.Button;
    }
    isSelectMenu() {
      return this.isStringSelectMenu();
    }
    isAnySelectMenu() {
      return this.type === InteractionType.MessageComponent && SelectMenuTypes.includes(this.componentType);
    }
    isStringSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.StringSelect;
    }
    isUserSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.UserSelect;
    }
    isRoleSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.RoleSelect;
    }
    isChannelSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.ChannelSelect;
    }
    isMentionableSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.MentionableSelect;
    }
    isRepliable() {
      return ![InteractionType.Ping, InteractionType.ApplicationCommandAutocomplete].includes(this.type);
    }
  }
  BaseInteraction.prototype.isSelectMenu = deprecate(BaseInteraction.prototype.isSelectMenu, "BaseInteraction#isSelectMenu() is deprecated. Use BaseInteraction#isStringSelectMenu() instead.");
  module.exports = BaseInteraction;
});

// node_modules/discord.js/src/structures/ApplicationRoleConnectionMetadata.js
var require_ApplicationRoleConnectionMetadata = __commonJS((exports) => {
  class ApplicationRoleConnectionMetadata {
    constructor(data) {
      this.name = data.name;
      this.nameLocalizations = data.name_localizations ?? null;
      this.description = data.description;
      this.descriptionLocalizations = data.description_localizations ?? null;
      this.key = data.key;
      this.type = data.type;
    }
  }
  exports.ApplicationRoleConnectionMetadata = ApplicationRoleConnectionMetadata;
});

// node_modules/discord.js/src/structures/TeamMember.js
var require_TeamMember = __commonJS((exports, module) => {
  var Base = require_Base();

  class TeamMember extends Base {
    constructor(team, data) {
      super(team.client);
      this.team = team;
      this._patch(data);
    }
    _patch(data) {
      if ("permissions" in data) {
        this.permissions = data.permissions;
      }
      if ("membership_state" in data) {
        this.membershipState = data.membership_state;
      }
      if ("user" in data) {
        this.user = this.client.users._add(data.user);
      }
      if ("role" in data) {
        this.role = data.role;
      }
    }
    get id() {
      return this.user.id;
    }
    toString() {
      return this.user.toString();
    }
  }
  module.exports = TeamMember;
});

// node_modules/discord.js/src/structures/Team.js
var require_Team = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var TeamMember = require_TeamMember();

  class Team extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      } else {
        this.icon ??= null;
      }
      if ("owner_user_id" in data) {
        this.ownerId = data.owner_user_id;
      } else {
        this.ownerId ??= null;
      }
      this.members = new Collection;
      for (const memberData of data.members) {
        const member = new TeamMember(this, memberData);
        this.members.set(member.id, member);
      }
    }
    get owner() {
      return this.members.get(this.ownerId) ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.teamIcon(this.id, this.icon, options);
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({ createdTimestamp: true });
    }
  }
  module.exports = Team;
});

// node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js
var require_ApplicationCommandPermissionsManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { ApplicationCommandPermissionType, RESTJSONErrorCodes, Routes } = require_v106();
  var BaseManager = require_BaseManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();

  class ApplicationCommandPermissionsManager extends BaseManager {
    constructor(manager) {
      super(manager.client);
      this.manager = manager;
      this.guild = manager.guild ?? null;
      this.guildId = manager.guildId ?? manager.guild?.id ?? null;
      this.commandId = manager.id ?? null;
    }
    permissionsPath(guildId, commandId) {
      if (commandId) {
        return Routes.applicationCommandPermissions(this.client.application.id, guildId, commandId);
      }
      return Routes.guildApplicationCommandsPermissions(this.client.application.id, guildId);
    }
    async fetch({ guild, command } = {}) {
      const { guildId, commandId } = this._validateOptions(guild, command);
      if (commandId) {
        const data2 = await this.client.rest.get(this.permissionsPath(guildId, commandId));
        return data2.permissions;
      }
      const data = await this.client.rest.get(this.permissionsPath(guildId));
      return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection);
    }
    async set({ guild, command, permissions, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!Array.isArray(permissions)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissions", "Array of ApplicationCommandPermissions", true);
      }
      if (!commandId) {
        commandId = this.client.user.id;
      }
      const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {
        body: { permissions },
        auth: false,
        headers: { Authorization: `Bearer ${token}` }
      });
      return data.permissions;
    }
    async add({ guild, command, permissions, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId) {
        commandId = this.client.user.id;
      }
      if (!Array.isArray(permissions)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissions", "Array of ApplicationCommandPermissions", true);
      }
      let existingPermissions = [];
      try {
        existingPermissions = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      const newPermissions = permissions.slice();
      for (const existingPermission of existingPermissions) {
        if (!newPermissions.some((newPermission) => newPermission.id === existingPermission.id)) {
          newPermissions.push(existingPermission);
        }
      }
      return this.set({ guild: guildId, command: commandId, permissions: newPermissions, token });
    }
    async remove({ guild, command, users, roles, channels, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId) {
        commandId = this.client.user.id;
      }
      if (!users && !roles && !channels) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "users OR roles OR channels", "Array or Resolvable", true);
      }
      let resolvedUserIds = [];
      if (Array.isArray(users)) {
        for (const user of users) {
          const userId = this.client.users.resolveId(user);
          if (!userId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "users", user);
          resolvedUserIds.push(userId);
        }
      }
      let resolvedRoleIds = [];
      if (Array.isArray(roles)) {
        for (const role of roles) {
          if (typeof role === "string") {
            resolvedRoleIds.push(role);
            continue;
          }
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "roles");
          const roleId = this.guild.roles.resolveId(role);
          if (!roleId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "users", role);
          resolvedRoleIds.push(roleId);
        }
      }
      let resolvedChannelIds = [];
      if (Array.isArray(channels)) {
        for (const channel of channels) {
          if (typeof channel === "string") {
            resolvedChannelIds.push(channel);
            continue;
          }
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "channels");
          const channelId = this.guild.channels.resolveId(channel);
          if (!channelId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "channels", channel);
          resolvedChannelIds.push(channelId);
        }
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      const permissions = existing.filter((perm) => {
        switch (perm.type) {
          case ApplicationCommandPermissionType.Role:
            return !resolvedRoleIds.includes(perm.id);
          case ApplicationCommandPermissionType.User:
            return !resolvedUserIds.includes(perm.id);
          case ApplicationCommandPermissionType.Channel:
            return !resolvedChannelIds.includes(perm.id);
        }
        return true;
      });
      return this.set({ guild: guildId, command: commandId, permissions, token });
    }
    async has({ guild, command, permissionId, permissionType }) {
      const { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      if (!permissionId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissionId", "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant");
      }
      let resolvedId = permissionId;
      if (typeof permissionId !== "string") {
        resolvedId = this.client.users.resolveId(permissionId);
        if (!resolvedId) {
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "roles");
          resolvedId = this.guild.roles.resolveId(permissionId);
        }
        if (!resolvedId) {
          resolvedId = this.guild.channels.resolveId(permissionId);
        }
        if (!resolvedId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissionId", "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant");
        }
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      return existing.some((perm) => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);
    }
    _validateOptions(guild, command) {
      const guildId = this.guildId ?? this.client.guilds.resolveId(guild);
      if (!guildId)
        throw new DiscordjsError(ErrorCodes.GlobalCommandPermissions);
      let commandId = this.commandId;
      if (command && !commandId) {
        commandId = this.manager.resolveId?.(command);
        if (!commandId && this.guild) {
          commandId = this.guild.commands.resolveId(command);
        }
        commandId ??= this.client.application?.commands.resolveId(command);
        if (!commandId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable", true);
        }
      }
      return { guildId, commandId };
    }
  }
  module.exports = ApplicationCommandPermissionsManager;
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/discord.js/src/structures/ApplicationCommand.js
var require_ApplicationCommand = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var { ApplicationCommandOptionType } = require_v106();
  var isEqual = require_fast_deep_equal();
  var Base = require_Base();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  var PermissionsBitField = require_PermissionsBitField();

  class ApplicationCommand extends Base {
    constructor(client, data, guild, guildId) {
      super(client);
      this.id = data.id;
      this.applicationId = data.application_id;
      this.guild = guild ?? null;
      this.guildId = guild?.id ?? guildId ?? null;
      this.permissions = new ApplicationCommandPermissionsManager(this);
      this.type = data.type;
      this.nsfw = data.nsfw ?? false;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      if ("name_localizations" in data) {
        this.nameLocalizations = data.name_localizations;
      } else {
        this.nameLocalizations ??= null;
      }
      if ("name_localized" in data) {
        this.nameLocalized = data.name_localized;
      } else {
        this.nameLocalized ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("description_localizations" in data) {
        this.descriptionLocalizations = data.description_localizations;
      } else {
        this.descriptionLocalizations ??= null;
      }
      if ("description_localized" in data) {
        this.descriptionLocalized = data.description_localized;
      } else {
        this.descriptionLocalized ??= null;
      }
      if ("options" in data) {
        this.options = data.options.map((option) => this.constructor.transformOption(option, true));
      } else {
        this.options ??= [];
      }
      if ("default_member_permissions" in data) {
        this.defaultMemberPermissions = data.default_member_permissions ? new PermissionsBitField(BigInt(data.default_member_permissions)).freeze() : null;
      } else {
        this.defaultMemberPermissions ??= null;
      }
      if ("dm_permission" in data) {
        this.dmPermission = data.dm_permission;
      } else {
        this.dmPermission ??= null;
      }
      if ("integration_types" in data) {
        this.integrationTypes = data.integration_types;
      } else {
        this.integrationTypes ??= null;
      }
      if ("contexts" in data) {
        this.contexts = data.contexts;
      } else {
        this.contexts ??= null;
      }
      if ("version" in data) {
        this.version = data.version;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get manager() {
      return (this.guild ?? this.client.application).commands;
    }
    edit(data) {
      return this.manager.edit(this, data, this.guildId);
    }
    setName(name) {
      return this.edit({ name });
    }
    setNameLocalizations(nameLocalizations) {
      return this.edit({ nameLocalizations });
    }
    setDescription(description) {
      return this.edit({ description });
    }
    setDescriptionLocalizations(descriptionLocalizations) {
      return this.edit({ descriptionLocalizations });
    }
    setDefaultMemberPermissions(defaultMemberPermissions) {
      return this.edit({ defaultMemberPermissions });
    }
    setDMPermission(dmPermission = true) {
      return this.edit({ dmPermission });
    }
    setOptions(options) {
      return this.edit({ options });
    }
    delete() {
      return this.manager.delete(this, this.guildId);
    }
    equals(command, enforceOptionOrder = false) {
      if (command.id && this.id !== command.id)
        return false;
      let defaultMemberPermissions = null;
      let dmPermission = command.dmPermission ?? command.dm_permission;
      if ("default_member_permissions" in command) {
        defaultMemberPermissions = command.default_member_permissions ? new PermissionsBitField(BigInt(command.default_member_permissions)).bitfield : null;
      }
      if ("defaultMemberPermissions" in command) {
        defaultMemberPermissions = command.defaultMemberPermissions !== null ? new PermissionsBitField(command.defaultMemberPermissions).bitfield : null;
      }
      if (command.name !== this.name || "description" in command && command.description !== this.description || "version" in command && command.version !== this.version || command.type && command.type !== this.type || "nsfw" in command && command.nsfw !== this.nsfw || (command.options?.length ?? 0) !== (this.options?.length ?? 0) || defaultMemberPermissions !== (this.defaultMemberPermissions?.bitfield ?? null) || dmPermission !== undefined && dmPermission !== this.dmPermission || !isEqual(command.nameLocalizations ?? command.name_localizations ?? {}, this.nameLocalizations ?? {}) || !isEqual(command.descriptionLocalizations ?? command.description_localizations ?? {}, this.descriptionLocalizations ?? {}) || !isEqual(command.integrationTypes ?? command.integration_types ?? [], this.integrationTypes ?? []) || !isEqual(command.contexts ?? [], this.contexts ?? [])) {
        return false;
      }
      if (command.options) {
        return this.constructor.optionsEqual(this.options, command.options, enforceOptionOrder);
      }
      return true;
    }
    static optionsEqual(existing, options, enforceOptionOrder = false) {
      if (existing.length !== options.length)
        return false;
      if (enforceOptionOrder) {
        return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));
      }
      const newOptions = new Map(options.map((option) => [option.name, option]));
      for (const option of existing) {
        const foundOption = newOptions.get(option.name);
        if (!foundOption || !this._optionEquals(option, foundOption))
          return false;
      }
      return true;
    }
    static _optionEquals(existing, option, enforceOptionOrder = false) {
      if (option.name !== existing.name || option.type !== existing.type || option.description !== existing.description || option.autocomplete !== existing.autocomplete || (option.required ?? ([ApplicationCommandOptionType.Subcommand, ApplicationCommandOptionType.SubcommandGroup].includes(option.type) ? undefined : false)) !== existing.required || option.choices?.length !== existing.choices?.length || option.options?.length !== existing.options?.length || (option.channelTypes ?? option.channel_types)?.length !== existing.channelTypes?.length || (option.minValue ?? option.min_value) !== existing.minValue || (option.maxValue ?? option.max_value) !== existing.maxValue || (option.minLength ?? option.min_length) !== existing.minLength || (option.maxLength ?? option.max_length) !== existing.maxLength || !isEqual(option.nameLocalizations ?? option.name_localizations ?? {}, existing.nameLocalizations ?? {}) || !isEqual(option.descriptionLocalizations ?? option.description_localizations ?? {}, existing.descriptionLocalizations ?? {})) {
        return false;
      }
      if (existing.choices) {
        if (enforceOptionOrder && !existing.choices.every((choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value && isEqual(choice.nameLocalizations ?? {}, option.choices[index].nameLocalizations ?? option.choices[index].name_localizations ?? {}))) {
          return false;
        }
        if (!enforceOptionOrder) {
          const newChoices = new Map(option.choices.map((choice) => [choice.name, choice]));
          for (const choice of existing.choices) {
            const foundChoice = newChoices.get(choice.name);
            if (!foundChoice || foundChoice.value !== choice.value)
              return false;
          }
        }
      }
      if (existing.channelTypes) {
        const newTypes = option.channelTypes ?? option.channel_types;
        for (const type of existing.channelTypes) {
          if (!newTypes.includes(type))
            return false;
        }
      }
      if (existing.options) {
        return this.optionsEqual(existing.options, option.options, enforceOptionOrder);
      }
      return true;
    }
    static transformOption(option, received) {
      const channelTypesKey = received ? "channelTypes" : "channel_types";
      const minValueKey = received ? "minValue" : "min_value";
      const maxValueKey = received ? "maxValue" : "max_value";
      const minLengthKey = received ? "minLength" : "min_length";
      const maxLengthKey = received ? "maxLength" : "max_length";
      const nameLocalizationsKey = received ? "nameLocalizations" : "name_localizations";
      const nameLocalizedKey = received ? "nameLocalized" : "name_localized";
      const descriptionLocalizationsKey = received ? "descriptionLocalizations" : "description_localizations";
      const descriptionLocalizedKey = received ? "descriptionLocalized" : "description_localized";
      return {
        type: option.type,
        name: option.name,
        [nameLocalizationsKey]: option.nameLocalizations ?? option.name_localizations,
        [nameLocalizedKey]: option.nameLocalized ?? option.name_localized,
        description: option.description,
        [descriptionLocalizationsKey]: option.descriptionLocalizations ?? option.description_localizations,
        [descriptionLocalizedKey]: option.descriptionLocalized ?? option.description_localized,
        required: option.required ?? (option.type === ApplicationCommandOptionType.Subcommand || option.type === ApplicationCommandOptionType.SubcommandGroup ? undefined : false),
        autocomplete: option.autocomplete,
        choices: option.choices?.map((choice) => ({
          name: choice.name,
          [nameLocalizedKey]: choice.nameLocalized ?? choice.name_localized,
          [nameLocalizationsKey]: choice.nameLocalizations ?? choice.name_localizations,
          value: choice.value
        })),
        options: option.options?.map((opt) => this.transformOption(opt, received)),
        [channelTypesKey]: option.channelTypes ?? option.channel_types,
        [minValueKey]: option.minValue ?? option.min_value,
        [maxValueKey]: option.maxValue ?? option.max_value,
        [minLengthKey]: option.minLength ?? option.min_length,
        [maxLengthKey]: option.maxLength ?? option.max_length
      };
    }
  }
  module.exports = ApplicationCommand;
});

// node_modules/discord.js/src/managers/ApplicationCommandManager.js
var require_ApplicationCommandManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { isJSONEncodable } = require_dist();
  var { Routes } = require_v106();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var ApplicationCommand = require_ApplicationCommand();
  var PermissionsBitField = require_PermissionsBitField();

  class ApplicationCommandManager extends CachedManager {
    constructor(client, iterable) {
      super(client, ApplicationCommand, iterable);
      this.permissions = new ApplicationCommandPermissionsManager(this);
    }
    _add(data, cache, guildId) {
      return super._add(data, cache, { extras: [this.guild, guildId] });
    }
    commandPath({ id, guildId } = {}) {
      if (this.guild ?? guildId) {
        if (id) {
          return Routes.applicationGuildCommand(this.client.application.id, this.guild?.id ?? guildId, id);
        }
        return Routes.applicationGuildCommands(this.client.application.id, this.guild?.id ?? guildId);
      }
      if (id) {
        return Routes.applicationCommand(this.client.application.id, id);
      }
      return Routes.applicationCommands(this.client.application.id);
    }
    async fetch(id, { guildId, cache = true, force = false, locale, withLocalizations } = {}) {
      if (typeof id === "object") {
        ({ guildId, cache = true, locale, withLocalizations } = id);
      } else if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const command = await this.client.rest.get(this.commandPath({ id, guildId }));
        return this._add(command, cache);
      }
      const data = await this.client.rest.get(this.commandPath({ guildId }), {
        headers: {
          "X-Discord-Locale": locale
        },
        query: makeURLSearchParams({ with_localizations: withLocalizations })
      });
      return data.reduce((coll, command) => coll.set(command.id, this._add(command, cache, guildId)), new Collection);
    }
    async create(command, guildId) {
      const data = await this.client.rest.post(this.commandPath({ guildId }), {
        body: this.constructor.transformCommand(command)
      });
      return this._add(data, true, guildId);
    }
    async set(commands, guildId) {
      const data = await this.client.rest.put(this.commandPath({ guildId }), {
        body: commands.map((command) => this.constructor.transformCommand(command))
      });
      return data.reduce((collection, command) => collection.set(command.id, this._add(command, true, guildId)), new Collection);
    }
    async edit(command, data, guildId) {
      const id = this.resolveId(command);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      const patched = await this.client.rest.patch(this.commandPath({ id, guildId }), {
        body: this.constructor.transformCommand(data)
      });
      return this._add(patched, true, guildId);
    }
    async delete(command, guildId) {
      const id = this.resolveId(command);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      await this.client.rest.delete(this.commandPath({ id, guildId }));
      const cached = this.cache.get(id);
      this.cache.delete(id);
      return cached ?? null;
    }
    static transformCommand(command) {
      if (isJSONEncodable(command))
        return command.toJSON();
      let default_member_permissions;
      if ("default_member_permissions" in command) {
        default_member_permissions = command.default_member_permissions ? new PermissionsBitField(BigInt(command.default_member_permissions)).bitfield.toString() : command.default_member_permissions;
      }
      if ("defaultMemberPermissions" in command) {
        default_member_permissions = command.defaultMemberPermissions !== null ? new PermissionsBitField(command.defaultMemberPermissions).bitfield.toString() : command.defaultMemberPermissions;
      }
      return {
        name: command.name,
        name_localizations: command.nameLocalizations ?? command.name_localizations,
        description: command.description,
        nsfw: command.nsfw,
        description_localizations: command.descriptionLocalizations ?? command.description_localizations,
        type: command.type,
        options: command.options?.map((option) => ApplicationCommand.transformOption(option)),
        default_member_permissions,
        dm_permission: command.dmPermission ?? command.dm_permission,
        integration_types: command.integrationTypes ?? command.integration_types,
        contexts: command.contexts
      };
    }
  }
  module.exports = ApplicationCommandManager;
});

// node_modules/discord.js/src/structures/ApplicationEmoji.js
var require_ApplicationEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class ApplicationEmoji extends Emoji {
    constructor(client, data, application) {
      super(client, data);
      this.application = application;
      this.author = null;
      this.managed = null;
      this.requiresColons = null;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data)
        this.name = data.name;
      if (data.user)
        this.author = this.client.users._add(data.user);
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("require_colons" in data) {
        this.requiresColons = data.require_colons;
      }
    }
    fetchAuthor() {
      return this.application.emojis.fetchAuthor(this);
    }
    edit(options) {
      return this.application.emojis.edit(this.id, options);
    }
    setName(name) {
      return this.edit({ name });
    }
    async delete() {
      await this.application.emojis.delete(this.id);
      return this;
    }
    equals(other) {
      if (other instanceof ApplicationEmoji) {
        return other.animated === this.animated && other.id === this.id && other.name === this.name && other.managed === this.managed && other.requiresColons === this.requiresColons;
      }
      return other.id === this.id && other.name === this.name;
    }
  }
  module.exports = ApplicationEmoji;
});

// node_modules/discord.js/src/managers/ApplicationEmojiManager.js
var require_ApplicationEmojiManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var ApplicationEmoji = require_ApplicationEmoji();
  var { resolveImage } = require_DataResolver();

  class ApplicationEmojiManager extends CachedManager {
    constructor(application, iterable) {
      super(application.client, ApplicationEmoji, iterable);
      this.application = application;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.application] });
    }
    async create({ attachment, name }) {
      attachment = await resolveImage(attachment);
      if (!attachment)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      const body = { image: attachment, name };
      const emoji = await this.client.rest.post(Routes.applicationEmojis(this.application.id), { body });
      return this._add(emoji);
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const emoji = await this.client.rest.get(Routes.applicationEmoji(this.application.id, id));
        return this._add(emoji, cache);
      }
      const { items: data } = await this.client.rest.get(Routes.applicationEmojis(this.application.id));
      const emojis = new Collection;
      for (const emoji of data)
        emojis.set(emoji.id, this._add(emoji, cache));
      return emojis;
    }
    async delete(emoji) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      await this.client.rest.delete(Routes.applicationEmoji(this.application.id, id));
    }
    async edit(emoji, options) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const newData = await this.client.rest.patch(Routes.applicationEmoji(this.application.id, id), {
        body: {
          name: options.name
        }
      });
      const existing = this.cache.get(id);
      if (existing) {
        existing._patch(newData);
        return existing;
      }
      return this._add(newData);
    }
    async fetchAuthor(emoji) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const data = await this.client.rest.get(Routes.applicationEmoji(this.application.id, id));
      return this._add(data).author;
    }
  }
  module.exports = ApplicationEmojiManager;
});

// node_modules/discord.js/src/structures/Entitlement.js
var require_Entitlement = __commonJS((exports) => {
  var Base = require_Base();

  class Entitlement extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this._patch(data);
    }
    _patch(data) {
      if ("sku_id" in data) {
        this.skuId = data.sku_id;
      }
      if ("user_id" in data) {
        this.userId = data.user_id;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      }
      if ("type" in data) {
        this.type = data.type;
      }
      if ("deleted" in data) {
        this.deleted = data.deleted;
      }
      if ("starts_at" in data) {
        this.startsTimestamp = data.starts_at ? Date.parse(data.starts_at) : null;
      } else {
        this.startsTimestamp ??= null;
      }
      if ("ends_at" in data) {
        this.endsTimestamp = data.ends_at ? Date.parse(data.ends_at) : null;
      } else {
        this.endsTimestamp ??= null;
      }
      if ("consumed" in data) {
        this.consumed = data.consumed;
      } else {
        this.consumed ??= false;
      }
    }
    get guild() {
      if (!this.guildId)
        return null;
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    get startsAt() {
      return this.startsTimestamp && new Date(this.startsTimestamp);
    }
    get endsAt() {
      return this.endsTimestamp && new Date(this.endsTimestamp);
    }
    isActive() {
      return !this.deleted && (!this.endsTimestamp || this.endsTimestamp > Date.now());
    }
    isTest() {
      return this.startsTimestamp === null;
    }
    isUserSubscription() {
      return this.guildId === null;
    }
    isGuildSubscription() {
      return this.guildId !== null;
    }
    fetchUser() {
      return this.client.users.fetch(this.userId);
    }
    async consume() {
      await this.client.application.entitlements.consume(this.id);
    }
  }
  exports.Entitlement = Entitlement;
});

// node_modules/discord.js/src/managers/EntitlementManager.js
var require_EntitlementManager = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes, EntitlementOwnerType } = require_v106();
  var CachedManager = require_CachedManager();
  var { ErrorCodes, DiscordjsTypeError } = require_errors();
  var { Entitlement } = require_Entitlement();
  var { resolveSKUId } = require_Util();

  class EntitlementManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Entitlement, iterable);
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany(options);
      const { entitlement, cache, force } = options;
      const resolvedEntitlement = this.resolveId(entitlement ?? options);
      if (resolvedEntitlement) {
        return this._fetchSingle({ entitlement: resolvedEntitlement, cache, force });
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ entitlement, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(entitlement);
        if (existing) {
          return existing;
        }
      }
      const data = await this.client.rest.get(Routes.entitlement(this.client.application.id, entitlement));
      return this._add(data, cache);
    }
    async _fetchMany({ limit, guild, user, skus, excludeEnded, excludeDeleted, cache, before, after } = {}) {
      const query = makeURLSearchParams({
        limit,
        guild_id: guild && this.client.guilds.resolveId(guild),
        user_id: user && this.client.users.resolveId(user),
        sku_ids: skus?.map((sku) => resolveSKUId(sku)).join(","),
        exclude_ended: excludeEnded,
        exclude_deleted: excludeDeleted,
        before,
        after
      });
      const entitlements = await this.client.rest.get(Routes.entitlements(this.client.application.id), { query });
      return entitlements.reduce((coll, entitlement) => coll.set(entitlement.id, this._add(entitlement, cache)), new Collection);
    }
    async createTest({ sku, guild, user }) {
      const skuId = resolveSKUId(sku);
      if (!skuId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sku", "SKUResolvable");
      if (guild && user || !guild && !user) {
        throw new DiscordjsTypeError(ErrorCodes.EntitlementCreateInvalidOwner);
      }
      const resolved = guild ? this.client.guilds.resolveId(guild) : this.client.users.resolveId(user);
      if (!resolved) {
        const name = guild ? "guild" : "user";
        const type = guild ? "GuildResolvable" : "UserResolvable";
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, name, type);
      }
      const entitlement = await this.client.rest.post(Routes.entitlements(this.client.application.id), {
        body: {
          sku_id: skuId,
          owner_id: resolved,
          owner_type: guild ? EntitlementOwnerType.Guild : EntitlementOwnerType.User
        }
      });
      return new Entitlement(this.client, entitlement);
    }
    async deleteTest(entitlement) {
      const resolved = this.resolveId(entitlement);
      if (!resolved)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "entitlement", "EntitlementResolvable");
      await this.client.rest.delete(Routes.entitlement(this.client.application.id, resolved));
    }
    async consume(entitlementId) {
      await this.client.rest.post(Routes.consumeEntitlement(this.client.application.id, entitlementId));
    }
  }
  exports.EntitlementManager = EntitlementManager;
});

// node_modules/discord.js/src/structures/Subscription.js
var require_Subscription = __commonJS((exports) => {
  var Base = require_Base();

  class Subscription extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.userId = data.user_id;
      this._patch(data);
    }
    _patch(data) {
      this.skuIds = data.sku_ids;
      this.entitlementIds = data.entitlement_ids;
      this.currentPeriodStartTimestamp = Date.parse(data.current_period_start);
      this.currentPeriodEndTimestamp = Date.parse(data.current_period_end);
      this.status = data.status;
      if ("renewal_sku_ids" in data) {
        this.renewalSkuIds = data.renewal_sku_ids;
      }
      if ("canceled_at" in data) {
        this.canceledTimestamp = data.canceled_at ? Date.parse(data.canceled_at) : null;
      } else {
        this.canceledTimestamp ??= null;
      }
      if ("country" in data) {
        this.country = data.country;
      } else {
        this.country ??= null;
      }
    }
    get canceledAt() {
      return this.canceledTimestamp && new Date(this.canceledTimestamp);
    }
    get currentPeriodStartAt() {
      return new Date(this.currentPeriodStartTimestamp);
    }
    get currentPeriodEndAt() {
      return new Date(this.currentPeriodEndTimestamp);
    }
  }
  exports.Subscription = Subscription;
});

// node_modules/discord.js/src/managers/SubscriptionManager.js
var require_SubscriptionManager = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { Subscription } = require_Subscription();
  var { resolveSKUId } = require_Util();

  class SubscriptionManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Subscription, iterable);
    }
    async fetch(options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const { after, before, cache, limit, sku, subscriptionId, user } = options;
      const skuId = resolveSKUId(sku);
      if (!skuId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sku", "SKUResolvable");
      if (subscriptionId) {
        const subscription = await this.client.rest.get(Routes.skuSubscription(skuId, subscriptionId));
        return this._add(subscription, cache);
      }
      const query = makeURLSearchParams({
        limit,
        user_id: this.client.users.resolveId(user) ?? undefined,
        sku_id: skuId,
        before,
        after
      });
      const subscriptions = await this.client.rest.get(Routes.skuSubscriptions(skuId), { query });
      return subscriptions.reduce((coll, subscription) => coll.set(subscription.id, this._add(subscription, cache)), new Collection);
    }
  }
  exports.SubscriptionManager = SubscriptionManager;
});

// node_modules/discord.js/src/util/ApplicationFlagsBitField.js
var require_ApplicationFlagsBitField = __commonJS((exports, module) => {
  var { ApplicationFlags } = require_v106();
  var BitField = require_BitField();

  class ApplicationFlagsBitField extends BitField {
    static Flags = ApplicationFlags;
  }
  module.exports = ApplicationFlagsBitField;
});

// node_modules/discord.js/src/structures/ClientApplication.js
var require_ClientApplication = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var { ApplicationRoleConnectionMetadata } = require_ApplicationRoleConnectionMetadata();
  var { SKU } = require_SKU();
  var Team = require_Team();
  var Application = require_Application();
  var ApplicationCommandManager = require_ApplicationCommandManager();
  var ApplicationEmojiManager = require_ApplicationEmojiManager();
  var { EntitlementManager } = require_EntitlementManager();
  var { SubscriptionManager } = require_SubscriptionManager();
  var ApplicationFlagsBitField = require_ApplicationFlagsBitField();
  var { resolveImage } = require_DataResolver();
  var PermissionsBitField = require_PermissionsBitField();

  class ClientApplication extends Application {
    constructor(client, data) {
      super(client, data);
      this.commands = new ApplicationCommandManager(this.client);
      this.emojis = new ApplicationEmojiManager(this);
      this.entitlements = new EntitlementManager(this.client);
      this.subscriptions = new SubscriptionManager(this.client);
    }
    _patch(data) {
      super._patch(data);
      this.tags = data.tags ?? [];
      if ("install_params" in data) {
        this.installParams = {
          scopes: data.install_params.scopes,
          permissions: new PermissionsBitField(data.install_params.permissions).freeze()
        };
      } else {
        this.installParams ??= null;
      }
      if ("integration_types_config" in data) {
        this.integrationTypesConfig = Object.fromEntries(Object.entries(data.integration_types_config).map(([key, config]) => {
          let oauth2InstallParams = null;
          if (config.oauth2_install_params) {
            oauth2InstallParams = {
              scopes: config.oauth2_install_params.scopes,
              permissions: new PermissionsBitField(config.oauth2_install_params.permissions).freeze()
            };
          }
          const context = {
            oauth2InstallParams
          };
          return [key, context];
        }));
      } else {
        this.integrationTypesConfig ??= null;
      }
      if ("custom_install_url" in data) {
        this.customInstallURL = data.custom_install_url;
      } else {
        this.customInstallURL = null;
      }
      if ("flags" in data) {
        this.flags = new ApplicationFlagsBitField(data.flags).freeze();
      }
      if ("approximate_guild_count" in data) {
        this.approximateGuildCount = data.approximate_guild_count;
      } else {
        this.approximateGuildCount ??= null;
      }
      if ("approximate_user_install_count" in data) {
        this.approximateUserInstallCount = data.approximate_user_install_count;
      } else {
        this.approximateUserInstallCount ??= null;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("bot_require_code_grant" in data) {
        this.botRequireCodeGrant = data.bot_require_code_grant;
      } else {
        this.botRequireCodeGrant ??= null;
      }
      if ("bot" in data) {
        this.bot = this.client.users._add(data.bot);
      } else {
        this.bot ??= null;
      }
      if ("bot_public" in data) {
        this.botPublic = data.bot_public;
      } else {
        this.botPublic ??= null;
      }
      if ("interactions_endpoint_url" in data) {
        this.interactionsEndpointURL = data.interactions_endpoint_url;
      } else {
        this.interactionsEndpointURL ??= null;
      }
      if ("role_connections_verification_url" in data) {
        this.roleConnectionsVerificationURL = data.role_connections_verification_url;
      } else {
        this.roleConnectionsVerificationURL ??= null;
      }
      if ("event_webhooks_url" in data) {
        this.eventWebhooksURL = data.event_webhooks_url;
      } else {
        this.eventWebhooksURL ??= null;
      }
      if ("event_webhooks_status" in data) {
        this.eventWebhooksStatus = data.event_webhooks_status;
      } else {
        this.eventWebhooksStatus ??= null;
      }
      if ("event_webhooks_types" in data) {
        this.eventWebhooksTypes = data.event_webhooks_types;
      } else {
        this.eventWebhooksTypes ??= null;
      }
      this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users._add(data.owner) : this.owner ?? null;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    get partial() {
      return !this.name;
    }
    async edit({
      customInstallURL,
      description,
      roleConnectionsVerificationURL,
      installParams,
      flags,
      icon,
      coverImage,
      interactionsEndpointURL,
      eventWebhooksURL,
      eventWebhooksStatus,
      eventWebhooksTypes,
      tags
    } = {}) {
      const data = await this.client.rest.patch(Routes.currentApplication(), {
        body: {
          custom_install_url: customInstallURL,
          description,
          role_connections_verification_url: roleConnectionsVerificationURL,
          install_params: installParams,
          flags: flags === undefined ? undefined : ApplicationFlagsBitField.resolve(flags),
          icon: icon && await resolveImage(icon),
          cover_image: coverImage && await resolveImage(coverImage),
          interactions_endpoint_url: interactionsEndpointURL,
          event_webhooks_url: eventWebhooksURL,
          event_webhooks_status: eventWebhooksStatus,
          event_webhooks_types: eventWebhooksTypes,
          tags
        }
      });
      this._patch(data);
      return this;
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.currentApplication());
      this._patch(data);
      return this;
    }
    async fetchRoleConnectionMetadataRecords() {
      const metadata = await this.client.rest.get(Routes.applicationRoleConnectionMetadata(this.client.user.id));
      return metadata.map((data) => new ApplicationRoleConnectionMetadata(data));
    }
    async editRoleConnectionMetadataRecords(records) {
      const newRecords = await this.client.rest.put(Routes.applicationRoleConnectionMetadata(this.client.user.id), {
        body: records.map((record) => ({
          type: record.type,
          key: record.key,
          name: record.name,
          name_localizations: record.nameLocalizations,
          description: record.description,
          description_localizations: record.descriptionLocalizations
        }))
      });
      return newRecords.map((data) => new ApplicationRoleConnectionMetadata(data));
    }
    async fetchSKUs() {
      const skus = await this.client.rest.get(Routes.skus(this.id));
      return skus.reduce((coll, sku) => coll.set(sku.id, new SKU(this.client, sku)), new Collection);
    }
  }
  module.exports = ClientApplication;
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module.exports = Symbol2;
});

// node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  var getRawTag = function(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  };
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module.exports = getRawTag;
});

// node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  var objectToString = function(value) {
    return nativeObjectToString.call(value);
  };
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  module.exports = objectToString;
});

// node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  var baseGetTag = function(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  };
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module.exports = baseGetTag;
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  var isObjectLike = function(value) {
    return value != null && typeof value == "object";
  };
  module.exports = isObjectLike;
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS((exports, module) => {
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  };
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var symbolTag = "[object Symbol]";
  module.exports = isSymbol;
});

// node_modules/lodash/_isKey.js
var require__isKey = __commonJS((exports, module) => {
  var isKey = function(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  };
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  module.exports = isKey;
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  var isObject = function(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  };
  module.exports = isObject;
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports, module) => {
  var isFunction = function(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  };
  var baseGetTag = require__baseGetTag();
  var isObject = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  module.exports = isFunction;
});

// node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root();
  var coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  var isMasked = function(func) {
    return !!maskSrcKey && maskSrcKey in func;
  };
  var coreJsData = require__coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  module.exports = isMasked;
});

// node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  var toSource = function(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  };
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  module.exports = toSource;
});

// node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  var baseIsNative = function(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  };
  var isFunction = require_isFunction();
  var isMasked = require__isMasked();
  var isObject = require_isObject();
  var toSource = require__toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  module.exports = baseIsNative;
});

// node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  var getValue = function(object, key) {
    return object == null ? undefined : object[key];
  };
  module.exports = getValue;
});

// node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  var getNative = function(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  };
  var baseIsNative = require__baseIsNative();
  var getValue = require__getValue();
  module.exports = getNative;
});

// node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  var hashClear = function() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  };
  var nativeCreate = require__nativeCreate();
  module.exports = hashClear;
});

// node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  var hashDelete = function(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  };
  module.exports = hashDelete;
});

// node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  var hashGet = function(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  };
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = hashGet;
});

// node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  var hashHas = function(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  };
  var nativeCreate = require__nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = hashHas;
});

// node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  var hashSet = function(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  };
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = hashSet;
});

// node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  var Hash = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var hashClear = require__hashClear();
  var hashDelete = require__hashDelete();
  var hashGet = require__hashGet();
  var hashHas = require__hashHas();
  var hashSet = require__hashSet();
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
});

// node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  var listCacheClear = function() {
    this.__data__ = [];
    this.size = 0;
  };
  module.exports = listCacheClear;
});

// node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  var eq = function(value, other) {
    return value === other || value !== value && other !== other;
  };
  module.exports = eq;
});

// node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  var assocIndexOf = function(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  };
  var eq = require_eq();
  module.exports = assocIndexOf;
});

// node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  var listCacheDelete = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  };
  var assocIndexOf = require__assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  module.exports = listCacheDelete;
});

// node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  var listCacheGet = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheGet;
});

// node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  var listCacheHas = function(key) {
    return assocIndexOf(this.__data__, key) > -1;
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheHas;
});

// node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  var listCacheSet = function(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheSet;
});

// node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  var ListCache = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var listCacheClear = require__listCacheClear();
  var listCacheDelete = require__listCacheDelete();
  var listCacheGet = require__listCacheGet();
  var listCacheHas = require__listCacheHas();
  var listCacheSet = require__listCacheSet();
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  var mapCacheClear = function() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  };
  var Hash = require__Hash();
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  module.exports = mapCacheClear;
});

// node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  var isKeyable = function(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  };
  module.exports = isKeyable;
});

// node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  var getMapData = function(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  };
  var isKeyable = require__isKeyable();
  module.exports = getMapData;
});

// node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  var mapCacheDelete = function(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheDelete;
});

// node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  var mapCacheGet = function(key) {
    return getMapData(this, key).get(key);
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheGet;
});

// node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  var mapCacheHas = function(key) {
    return getMapData(this, key).has(key);
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheHas;
});

// node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  var mapCacheSet = function(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheSet;
});

// node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  var MapCache = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var mapCacheClear = require__mapCacheClear();
  var mapCacheDelete = require__mapCacheDelete();
  var mapCacheGet = require__mapCacheGet();
  var mapCacheHas = require__mapCacheHas();
  var mapCacheSet = require__mapCacheSet();
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS((exports, module) => {
  var memoize = function(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  };
  var MapCache = require__MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  memoize.Cache = MapCache;
  module.exports = memoize;
});

// node_modules/lodash/_memoizeCapped.js
var require__memoizeCapped = __commonJS((exports, module) => {
  var memoizeCapped = function(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  };
  var memoize = require_memoize();
  var MAX_MEMOIZE_SIZE = 500;
  module.exports = memoizeCapped;
});

// node_modules/lodash/_stringToPath.js
var require__stringToPath = __commonJS((exports, module) => {
  var memoizeCapped = require__memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  module.exports = stringToPath;
});

// node_modules/lodash/_arrayMap.js
var require__arrayMap = __commonJS((exports, module) => {
  var arrayMap = function(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  };
  module.exports = arrayMap;
});

// node_modules/lodash/_baseToString.js
var require__baseToString = __commonJS((exports, module) => {
  var baseToString = function(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  };
  var Symbol2 = require__Symbol();
  var arrayMap = require__arrayMap();
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  module.exports = baseToString;
});

// node_modules/lodash/toString.js
var require_toString = __commonJS((exports, module) => {
  var toString = function(value) {
    return value == null ? "" : baseToString(value);
  };
  var baseToString = require__baseToString();
  module.exports = toString;
});

// node_modules/lodash/_castPath.js
var require__castPath = __commonJS((exports, module) => {
  var castPath = function(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  };
  var isArray = require_isArray();
  var isKey = require__isKey();
  var stringToPath = require__stringToPath();
  var toString = require_toString();
  module.exports = castPath;
});

// node_modules/lodash/_toKey.js
var require__toKey = __commonJS((exports, module) => {
  var toKey = function(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  };
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  module.exports = toKey;
});

// node_modules/lodash/_baseGet.js
var require__baseGet = __commonJS((exports, module) => {
  var baseGet = function(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
  };
  var castPath = require__castPath();
  var toKey = require__toKey();
  module.exports = baseGet;
});

// node_modules/lodash/get.js
var require_get = __commonJS((exports, module) => {
  var get = function(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  };
  var baseGet = require__baseGet();
  module.exports = get;
});

// node_modules/fast-deep-equal/es6/index.js
var require_es6 = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a instanceof Map && b instanceof Map) {
        if (a.size !== b.size)
          return false;
        for (i of a.entries())
          if (!b.has(i[0]))
            return false;
        for (i of a.entries())
          if (!equal(i[1], b.get(i[0])))
            return false;
        return true;
      }
      if (a instanceof Set && b instanceof Set) {
        if (a.size !== b.size)
          return false;
        for (i of a.entries())
          if (!b.has(i[0]))
            return false;
        return true;
      }
      if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (a[i] !== b[i])
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/lodash/_setCacheAdd.js
var require__setCacheAdd = __commonJS((exports, module) => {
  var setCacheAdd = function(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  };
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = setCacheAdd;
});

// node_modules/lodash/_setCacheHas.js
var require__setCacheHas = __commonJS((exports, module) => {
  var setCacheHas = function(value) {
    return this.__data__.has(value);
  };
  module.exports = setCacheHas;
});

// node_modules/lodash/_SetCache.js
var require__SetCache = __commonJS((exports, module) => {
  var SetCache = function(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  };
  var MapCache = require__MapCache();
  var setCacheAdd = require__setCacheAdd();
  var setCacheHas = require__setCacheHas();
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
});

// node_modules/lodash/_baseFindIndex.js
var require__baseFindIndex = __commonJS((exports, module) => {
  var baseFindIndex = function(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  };
  module.exports = baseFindIndex;
});

// node_modules/lodash/_baseIsNaN.js
var require__baseIsNaN = __commonJS((exports, module) => {
  var baseIsNaN = function(value) {
    return value !== value;
  };
  module.exports = baseIsNaN;
});

// node_modules/lodash/_strictIndexOf.js
var require__strictIndexOf = __commonJS((exports, module) => {
  var strictIndexOf = function(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  };
  module.exports = strictIndexOf;
});

// node_modules/lodash/_baseIndexOf.js
var require__baseIndexOf = __commonJS((exports, module) => {
  var baseIndexOf = function(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  };
  var baseFindIndex = require__baseFindIndex();
  var baseIsNaN = require__baseIsNaN();
  var strictIndexOf = require__strictIndexOf();
  module.exports = baseIndexOf;
});

// node_modules/lodash/_arrayIncludes.js
var require__arrayIncludes = __commonJS((exports, module) => {
  var arrayIncludes = function(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  };
  var baseIndexOf = require__baseIndexOf();
  module.exports = arrayIncludes;
});

// node_modules/lodash/_arrayIncludesWith.js
var require__arrayIncludesWith = __commonJS((exports, module) => {
  var arrayIncludesWith = function(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  };
  module.exports = arrayIncludesWith;
});

// node_modules/lodash/_cacheHas.js
var require__cacheHas = __commonJS((exports, module) => {
  var cacheHas = function(cache, key) {
    return cache.has(key);
  };
  module.exports = cacheHas;
});

// node_modules/lodash/_Set.js
var require__Set = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Set2 = getNative(root, "Set");
  module.exports = Set2;
});

// node_modules/lodash/noop.js
var require_noop = __commonJS((exports, module) => {
  var noop = function() {
  };
  module.exports = noop;
});

// node_modules/lodash/_setToArray.js
var require__setToArray = __commonJS((exports, module) => {
  var setToArray = function(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  };
  module.exports = setToArray;
});

// node_modules/lodash/_createSet.js
var require__createSet = __commonJS((exports, module) => {
  var Set2 = require__Set();
  var noop = require_noop();
  var setToArray = require__setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  module.exports = createSet;
});

// node_modules/lodash/_baseUniq.js
var require__baseUniq = __commonJS((exports, module) => {
  var baseUniq = function(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache;
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  };
  var SetCache = require__SetCache();
  var arrayIncludes = require__arrayIncludes();
  var arrayIncludesWith = require__arrayIncludesWith();
  var cacheHas = require__cacheHas();
  var createSet = require__createSet();
  var setToArray = require__setToArray();
  var LARGE_ARRAY_SIZE = 200;
  module.exports = baseUniq;
});

// node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS((exports, module) => {
  var uniqWith = function(array, comparator) {
    comparator = typeof comparator == "function" ? comparator : undefined;
    return array && array.length ? baseUniq(array, undefined, comparator) : [];
  };
  var baseUniq = require__baseUniq();
  module.exports = uniqWith;
});

// node_modules/@sapphire/shapeshift/dist/cjs/index.cjs
var require_cjs3 = __commonJS((exports) => {
  var _interopDefault = function(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  };
  var i = function() {
    throw new Error("setTimeout has not been defined");
  };
  var u = function() {
    throw new Error("clearTimeout has not been defined");
  };
  var c = function(e3) {
    if (t === setTimeout)
      return setTimeout(e3, 0);
    if ((t === i || !t) && setTimeout)
      return t = setTimeout, setTimeout(e3, 0);
    try {
      return t(e3, 0);
    } catch (n3) {
      try {
        return t.call(null, e3, 0);
      } catch (n4) {
        return t.call(this || r, e3, 0);
      }
    }
  };
  var h = function() {
    f && l && (f = false, l.length ? s = l.concat(s) : a = -1, s.length && d());
  };
  var d = function() {
    if (!f) {
      var e3 = c(h);
      f = true;
      for (var t3 = s.length;t3; ) {
        for (l = s, s = [];++a < t3; )
          l && l[a].run();
        a = -1, t3 = s.length;
      }
      l = null, f = false, function(e4) {
        if (n === clearTimeout)
          return clearTimeout(e4);
        if ((n === u || !n) && clearTimeout)
          return n = clearTimeout, clearTimeout(e4);
        try {
          n(e4);
        } catch (t4) {
          try {
            return n.call(null, e4);
          } catch (t5) {
            return n.call(this || r, e4);
          }
        }
      }(e3);
    }
  };
  var m = function(e3, t3) {
    (this || r).fun = e3, (this || r).array = t3;
  };
  var p = function() {
  };
  var c$1 = function(e3) {
    return e3.call.bind(e3);
  };
  var O = function(e3, t3) {
    if (typeof e3 != "object")
      return false;
    try {
      return t3(e3), true;
    } catch (e4) {
      return false;
    }
  };
  var S = function(e3) {
    return l$1 && y ? b(e3) !== undefined : B(e3) || k(e3) || E(e3) || D(e3) || U(e3) || P(e3) || x(e3) || I(e3) || M(e3) || z(e3) || F(e3);
  };
  var B = function(e3) {
    return l$1 && y ? b(e3) === "Uint8Array" : m2(e3) === "[object Uint8Array]" || u$1(e3) && e3.buffer !== undefined;
  };
  var k = function(e3) {
    return l$1 && y ? b(e3) === "Uint8ClampedArray" : m2(e3) === "[object Uint8ClampedArray]";
  };
  var E = function(e3) {
    return l$1 && y ? b(e3) === "Uint16Array" : m2(e3) === "[object Uint16Array]";
  };
  var D = function(e3) {
    return l$1 && y ? b(e3) === "Uint32Array" : m2(e3) === "[object Uint32Array]";
  };
  var U = function(e3) {
    return l$1 && y ? b(e3) === "Int8Array" : m2(e3) === "[object Int8Array]";
  };
  var P = function(e3) {
    return l$1 && y ? b(e3) === "Int16Array" : m2(e3) === "[object Int16Array]";
  };
  var x = function(e3) {
    return l$1 && y ? b(e3) === "Int32Array" : m2(e3) === "[object Int32Array]";
  };
  var I = function(e3) {
    return l$1 && y ? b(e3) === "Float32Array" : m2(e3) === "[object Float32Array]";
  };
  var M = function(e3) {
    return l$1 && y ? b(e3) === "Float64Array" : m2(e3) === "[object Float64Array]";
  };
  var z = function(e3) {
    return l$1 && y ? b(e3) === "BigInt64Array" : m2(e3) === "[object BigInt64Array]";
  };
  var F = function(e3) {
    return l$1 && y ? b(e3) === "BigUint64Array" : m2(e3) === "[object BigUint64Array]";
  };
  var T2 = function(e3) {
    return m2(e3) === "[object Map]";
  };
  var N = function(e3) {
    return m2(e3) === "[object Set]";
  };
  var W = function(e3) {
    return m2(e3) === "[object WeakMap]";
  };
  var $ = function(e3) {
    return m2(e3) === "[object WeakSet]";
  };
  var C = function(e3) {
    return m2(e3) === "[object ArrayBuffer]";
  };
  var V = function(e3) {
    return typeof ArrayBuffer != "undefined" && (C.working ? C(e3) : e3 instanceof ArrayBuffer);
  };
  var G = function(e3) {
    return m2(e3) === "[object DataView]";
  };
  var R = function(e3) {
    return typeof DataView != "undefined" && (G.working ? G(e3) : e3 instanceof DataView);
  };
  var J = function(e3) {
    return m2(e3) === "[object SharedArrayBuffer]";
  };
  var _ = function(e3) {
    return typeof SharedArrayBuffer != "undefined" && (J.working ? J(e3) : e3 instanceof SharedArrayBuffer);
  };
  var H = function(e3) {
    return O(e3, h2);
  };
  var Z = function(e3) {
    return O(e3, j);
  };
  var q = function(e3) {
    return O(e3, A);
  };
  var K = function(e3) {
    return s2 && O(e3, w);
  };
  var L = function(e3) {
    return p2 && O(e3, v);
  };
  var oe = function(e3, t3) {
    var r3 = { seen: [], stylize: fe };
    return arguments.length >= 3 && (r3.depth = arguments[2]), arguments.length >= 4 && (r3.colors = arguments[3]), ye(t3) ? r3.showHidden = t3 : t3 && X._extend(r3, t3), be(r3.showHidden) && (r3.showHidden = false), be(r3.depth) && (r3.depth = 2), be(r3.colors) && (r3.colors = false), be(r3.customInspect) && (r3.customInspect = true), r3.colors && (r3.stylize = ue), ae(r3, e3, r3.depth);
  };
  var ue = function(e3, t3) {
    var r3 = oe.styles[t3];
    return r3 ? "\x1B[" + oe.colors[r3][0] + "m" + e3 + "\x1B[" + oe.colors[r3][1] + "m" : e3;
  };
  var fe = function(e3, t3) {
    return e3;
  };
  var ae = function(e3, t3, r3) {
    if (e3.customInspect && t3 && we(t3.inspect) && t3.inspect !== X.inspect && (!t3.constructor || t3.constructor.prototype !== t3)) {
      var n3 = t3.inspect(r3, e3);
      return ge(n3) || (n3 = ae(e3, n3, r3)), n3;
    }
    var i3 = function(e4, t4) {
      if (be(t4))
        return e4.stylize("undefined", "undefined");
      if (ge(t4)) {
        var r4 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e4.stylize(r4, "string");
      }
      if (de(t4))
        return e4.stylize("" + t4, "number");
      if (ye(t4))
        return e4.stylize("" + t4, "boolean");
      if (le(t4))
        return e4.stylize("null", "null");
    }(e3, t3);
    if (i3)
      return i3;
    var o3 = Object.keys(t3), u3 = function(e4) {
      var t4 = {};
      return e4.forEach(function(e5, r4) {
        t4[e5] = true;
      }), t4;
    }(o3);
    if (e3.showHidden && (o3 = Object.getOwnPropertyNames(t3)), Ae(t3) && (o3.indexOf("message") >= 0 || o3.indexOf("description") >= 0))
      return ce(t3);
    if (o3.length === 0) {
      if (we(t3)) {
        var f3 = t3.name ? ": " + t3.name : "";
        return e3.stylize("[Function" + f3 + "]", "special");
      }
      if (me(t3))
        return e3.stylize(RegExp.prototype.toString.call(t3), "regexp");
      if (je(t3))
        return e3.stylize(Date.prototype.toString.call(t3), "date");
      if (Ae(t3))
        return ce(t3);
    }
    var a3, c3 = "", s4 = false, p3 = ["{", "}"];
    (pe(t3) && (s4 = true, p3 = ["[", "]"]), we(t3)) && (c3 = " [Function" + (t3.name ? ": " + t3.name : "") + "]");
    return me(t3) && (c3 = " " + RegExp.prototype.toString.call(t3)), je(t3) && (c3 = " " + Date.prototype.toUTCString.call(t3)), Ae(t3) && (c3 = " " + ce(t3)), o3.length !== 0 || s4 && t3.length != 0 ? r3 < 0 ? me(t3) ? e3.stylize(RegExp.prototype.toString.call(t3), "regexp") : e3.stylize("[Object]", "special") : (e3.seen.push(t3), a3 = s4 ? function(e4, t4, r4, n4, i4) {
      for (var o4 = [], u4 = 0, f4 = t4.length;u4 < f4; ++u4)
        ke(t4, String(u4)) ? o4.push(se(e4, t4, r4, n4, String(u4), true)) : o4.push("");
      return i4.forEach(function(i5) {
        i5.match(/^\d+$/) || o4.push(se(e4, t4, r4, n4, i5, true));
      }), o4;
    }(e3, t3, r3, u3, o3) : o3.map(function(n4) {
      return se(e3, t3, r3, u3, n4, s4);
    }), e3.seen.pop(), function(e4, t4, r4) {
      var n4 = 0;
      if (e4.reduce(function(e5, t5) {
        return n4++, t5.indexOf("\n") >= 0 && n4++, e5 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60)
        return r4[0] + (t4 === "" ? "" : t4 + "\n ") + " " + e4.join(",\n  ") + " " + r4[1];
      return r4[0] + t4 + " " + e4.join(", ") + " " + r4[1];
    }(a3, c3, p3)) : p3[0] + c3 + p3[1];
  };
  var ce = function(e3) {
    return "[" + Error.prototype.toString.call(e3) + "]";
  };
  var se = function(e3, t3, r3, n3, i3, o3) {
    var u3, f3, a3;
    if ((a3 = Object.getOwnPropertyDescriptor(t3, i3) || { value: t3[i3] }).get ? f3 = a3.set ? e3.stylize("[Getter/Setter]", "special") : e3.stylize("[Getter]", "special") : a3.set && (f3 = e3.stylize("[Setter]", "special")), ke(n3, i3) || (u3 = "[" + i3 + "]"), f3 || (e3.seen.indexOf(a3.value) < 0 ? (f3 = le(r3) ? ae(e3, a3.value, null) : ae(e3, a3.value, r3 - 1)).indexOf("\n") > -1 && (f3 = o3 ? f3.split("\n").map(function(e4) {
      return "  " + e4;
    }).join("\n").substr(2) : "\n" + f3.split("\n").map(function(e4) {
      return "   " + e4;
    }).join("\n")) : f3 = e3.stylize("[Circular]", "special")), be(u3)) {
      if (o3 && i3.match(/^\d+$/))
        return f3;
      (u3 = JSON.stringify("" + i3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u3 = u3.substr(1, u3.length - 2), u3 = e3.stylize(u3, "name")) : (u3 = u3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u3 = e3.stylize(u3, "string"));
    }
    return u3 + ": " + f3;
  };
  var pe = function(e3) {
    return Array.isArray(e3);
  };
  var ye = function(e3) {
    return typeof e3 == "boolean";
  };
  var le = function(e3) {
    return e3 === null;
  };
  var de = function(e3) {
    return typeof e3 == "number";
  };
  var ge = function(e3) {
    return typeof e3 == "string";
  };
  var be = function(e3) {
    return e3 === undefined;
  };
  var me = function(e3) {
    return he(e3) && ve(e3) === "[object RegExp]";
  };
  var he = function(e3) {
    return typeof e3 == "object" && e3 !== null;
  };
  var je = function(e3) {
    return he(e3) && ve(e3) === "[object Date]";
  };
  var Ae = function(e3) {
    return he(e3) && (ve(e3) === "[object Error]" || e3 instanceof Error);
  };
  var we = function(e3) {
    return typeof e3 == "function";
  };
  var ve = function(e3) {
    return Object.prototype.toString.call(e3);
  };
  var Oe = function(e3) {
    return e3 < 10 ? "0" + e3.toString(10) : e3.toString(10);
  };
  var Be = function() {
    var e3 = new Date, t3 = [Oe(e3.getHours()), Oe(e3.getMinutes()), Oe(e3.getSeconds())].join(":");
    return [e3.getDate(), Se[e3.getMonth()], t3].join(" ");
  };
  var ke = function(e3, t3) {
    return Object.prototype.hasOwnProperty.call(e3, t3);
  };
  var De = function(e3, t3) {
    if (!e3) {
      var r3 = new Error("Promise was rejected with a falsy value");
      r3.reason = e3, e3 = r3;
    }
    return t3(e3);
  };
  var whenConstraint = function(key, options, validator, validatorOptions) {
    return {
      run(input, parent) {
        if (!parent) {
          return Result.err(new ExpectedConstraintError("s.object(T.when)", validatorOptions?.message ?? "Validator has no parent", parent, "Validator to have a parent"));
        }
        const isKeyArray = Array.isArray(key);
        const value = isKeyArray ? key.map((k2) => get__default.default(parent, k2)) : get__default.default(parent, key);
        const predicate = resolveBooleanIs(options, value, isKeyArray) ? options.then : options.otherwise;
        if (predicate) {
          return predicate(validator).run(input);
        }
        return Result.ok(input);
      }
    };
  };
  var resolveBooleanIs = function(options, value, isKeyArray) {
    if (options.is === undefined) {
      return isKeyArray ? !value.some((val) => !val) : Boolean(value);
    }
    if (typeof options.is === "function") {
      return options.is(value);
    }
    return value === options.is;
  };
  var setGlobalValidationEnabled = function(enabled) {
    validationEnabled = enabled;
  };
  var getGlobalValidationEnabled = function() {
    return validationEnabled;
  };
  var getValue = function(valueOrFn) {
    return typeof valueOrFn === "function" ? valueOrFn() : valueOrFn;
  };
  var isUnique = function(input) {
    if (input.length < 2)
      return true;
    const uniqueArray2 = uniqWith__default.default(input, fastDeepEqual__default.default);
    return uniqueArray2.length === input.length;
  };
  var lessThan = function(a3, b2) {
    return a3 < b2;
  };
  var lessThanOrEqual = function(a3, b2) {
    return a3 <= b2;
  };
  var greaterThan = function(a3, b2) {
    return a3 > b2;
  };
  var greaterThanOrEqual = function(a3, b2) {
    return a3 >= b2;
  };
  var equal = function(a3, b2) {
    return a3 === b2;
  };
  var notEqual = function(a3, b2) {
    return a3 !== b2;
  };
  var arrayLengthComparator = function(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Array length", input, expected));
      }
    };
  };
  var arrayLengthLessThan = function(value, options) {
    const expected = `expected.length < ${value}`;
    return arrayLengthComparator(lessThan, "s.array(T).lengthLessThan()", expected, value, options);
  };
  var arrayLengthLessThanOrEqual = function(value, options) {
    const expected = `expected.length <= ${value}`;
    return arrayLengthComparator(lessThanOrEqual, "s.array(T).lengthLessThanOrEqual()", expected, value, options);
  };
  var arrayLengthGreaterThan = function(value, options) {
    const expected = `expected.length > ${value}`;
    return arrayLengthComparator(greaterThan, "s.array(T).lengthGreaterThan()", expected, value, options);
  };
  var arrayLengthGreaterThanOrEqual = function(value, options) {
    const expected = `expected.length >= ${value}`;
    return arrayLengthComparator(greaterThanOrEqual, "s.array(T).lengthGreaterThanOrEqual()", expected, value, options);
  };
  var arrayLengthEqual = function(value, options) {
    const expected = `expected.length === ${value}`;
    return arrayLengthComparator(equal, "s.array(T).lengthEqual()", expected, value, options);
  };
  var arrayLengthNotEqual = function(value, options) {
    const expected = `expected.length !== ${value}`;
    return arrayLengthComparator(notEqual, "s.array(T).lengthNotEqual()", expected, value, options);
  };
  var arrayLengthRange = function(start, endBefore, options) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRange()", options?.message ?? "Invalid Array length", input, expected));
      }
    };
  };
  var arrayLengthRangeInclusive = function(start, end, options) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeInclusive()", options?.message ?? "Invalid Array length", input, expected));
      }
    };
  };
  var arrayLengthRangeExclusive = function(startAfter, endBefore, options) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeExclusive()", options?.message ?? "Invalid Array length", input, expected));
      }
    };
  };
  var uniqueArray = function(options) {
    return {
      run(input) {
        return isUnique(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).unique()", options?.message ?? "Array values are not unique", input, "Expected all values to be unique"));
      }
    };
  };
  var bigintComparator = function(comparator, name, expected, number, options) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid bigint value", input, expected));
      }
    };
  };
  var bigintLessThan = function(value, options) {
    const expected = `expected < ${value}n`;
    return bigintComparator(lessThan, "s.bigint().lessThan()", expected, value, options);
  };
  var bigintLessThanOrEqual = function(value, options) {
    const expected = `expected <= ${value}n`;
    return bigintComparator(lessThanOrEqual, "s.bigint().lessThanOrEqual()", expected, value, options);
  };
  var bigintGreaterThan = function(value, options) {
    const expected = `expected > ${value}n`;
    return bigintComparator(greaterThan, "s.bigint().greaterThan()", expected, value, options);
  };
  var bigintGreaterThanOrEqual = function(value, options) {
    const expected = `expected >= ${value}n`;
    return bigintComparator(greaterThanOrEqual, "s.bigint().greaterThanOrEqual()", expected, value, options);
  };
  var bigintEqual = function(value, options) {
    const expected = `expected === ${value}n`;
    return bigintComparator(equal, "s.bigint().equal()", expected, value, options);
  };
  var bigintNotEqual = function(value, options) {
    const expected = `expected !== ${value}n`;
    return bigintComparator(notEqual, "s.bigint().notEqual()", expected, value, options);
  };
  var bigintDivisibleBy = function(divider, options) {
    const expected = `expected % ${divider}n === 0n`;
    return {
      run(input) {
        return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.bigint().divisibleBy()", options?.message ?? "BigInt is not divisible", input, expected));
      }
    };
  };
  var booleanTrue = function(options) {
    return {
      run(input) {
        return input ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.boolean().true()", options?.message ?? "Invalid boolean value", input, "true"));
      }
    };
  };
  var booleanFalse = function(options) {
    return {
      run(input) {
        return input ? Result.err(new ExpectedConstraintError("s.boolean().false()", options?.message ?? "Invalid boolean value", input, "false")) : Result.ok(input);
      }
    };
  };
  var dateComparator = function(comparator, name, expected, number, options) {
    return {
      run(input) {
        return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Date value", input, expected));
      }
    };
  };
  var dateLessThan = function(value, options) {
    const expected = `expected < ${value.toISOString()}`;
    return dateComparator(lessThan, "s.date().lessThan()", expected, value.getTime(), options);
  };
  var dateLessThanOrEqual = function(value, options) {
    const expected = `expected <= ${value.toISOString()}`;
    return dateComparator(lessThanOrEqual, "s.date().lessThanOrEqual()", expected, value.getTime(), options);
  };
  var dateGreaterThan = function(value, options) {
    const expected = `expected > ${value.toISOString()}`;
    return dateComparator(greaterThan, "s.date().greaterThan()", expected, value.getTime(), options);
  };
  var dateGreaterThanOrEqual = function(value, options) {
    const expected = `expected >= ${value.toISOString()}`;
    return dateComparator(greaterThanOrEqual, "s.date().greaterThanOrEqual()", expected, value.getTime(), options);
  };
  var dateEqual = function(value, options) {
    const expected = `expected === ${value.toISOString()}`;
    return dateComparator(equal, "s.date().equal()", expected, value.getTime(), options);
  };
  var dateNotEqual = function(value, options) {
    const expected = `expected !== ${value.toISOString()}`;
    return dateComparator(notEqual, "s.date().notEqual()", expected, value.getTime(), options);
  };
  var dateInvalid = function(options) {
    return {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.date().invalid()", options?.message ?? "Invalid Date value", input, "expected === NaN"));
      }
    };
  };
  var dateValid = function(options) {
    return {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError("s.date().valid()", options?.message ?? "Invalid Date value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
  };
  var numberComparator = function(comparator, name, expected, number, options) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid number value", input, expected));
      }
    };
  };
  var numberLessThan = function(value, options) {
    const expected = `expected < ${value}`;
    return numberComparator(lessThan, "s.number().lessThan()", expected, value, options);
  };
  var numberLessThanOrEqual = function(value, options) {
    const expected = `expected <= ${value}`;
    return numberComparator(lessThanOrEqual, "s.number().lessThanOrEqual()", expected, value, options);
  };
  var numberGreaterThan = function(value, options) {
    const expected = `expected > ${value}`;
    return numberComparator(greaterThan, "s.number().greaterThan()", expected, value, options);
  };
  var numberGreaterThanOrEqual = function(value, options) {
    const expected = `expected >= ${value}`;
    return numberComparator(greaterThanOrEqual, "s.number().greaterThanOrEqual()", expected, value, options);
  };
  var numberEqual = function(value, options) {
    const expected = `expected === ${value}`;
    return numberComparator(equal, "s.number().equal()", expected, value, options);
  };
  var numberNotEqual = function(value, options) {
    const expected = `expected !== ${value}`;
    return numberComparator(notEqual, "s.number().notEqual()", expected, value, options);
  };
  var numberInt = function(options) {
    return {
      run(input) {
        return Number.isInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().int()", options?.message ?? "Given value is not an integer", input, "Number.isInteger(expected) to be true"));
      }
    };
  };
  var numberSafeInt = function(options) {
    return {
      run(input) {
        return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().safeInt()", options?.message ?? "Given value is not a safe integer", input, "Number.isSafeInteger(expected) to be true"));
      }
    };
  };
  var numberFinite = function(options) {
    return {
      run(input) {
        return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().finite()", options?.message ?? "Given value is not finite", input, "Number.isFinite(expected) to be true"));
      }
    };
  };
  var numberNaN = function(options) {
    return {
      run(input) {
        return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().equal(NaN)", options?.message ?? "Invalid number value", input, "expected === NaN"));
      }
    };
  };
  var numberNotNaN = function(options) {
    return {
      run(input) {
        return Number.isNaN(input) ? Result.err(new ExpectedConstraintError("s.number().notEqual(NaN)", options?.message ?? "Invalid number value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
  };
  var numberDivisibleBy = function(divider, options) {
    const expected = `expected % ${divider} === 0`;
    return {
      run(input) {
        return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().divisibleBy()", options?.message ?? "Number is not divisible", input, expected));
      }
    };
  };
  var validateEmail = function(email) {
    if (!email)
      return false;
    const atIndex = email.indexOf("@");
    if (atIndex === -1)
      return false;
    if (atIndex > 64)
      return false;
    const domainIndex = atIndex + 1;
    if (email.includes("@", domainIndex))
      return false;
    if (email.length - domainIndex > 255)
      return false;
    let dotIndex = email.indexOf(".", domainIndex);
    if (dotIndex === -1)
      return false;
    let lastDotIndex = domainIndex;
    do {
      if (dotIndex - lastDotIndex > 63)
        return false;
      lastDotIndex = dotIndex + 1;
    } while ((dotIndex = email.indexOf(".", lastDotIndex)) !== -1);
    if (email.length - lastDotIndex > 63)
      return false;
    return accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));
  };
  var validateEmailDomain = function(domain) {
    try {
      return new URL(`http://${domain}`).hostname === domain;
    } catch {
      return false;
    }
  };
  var isIPv4 = function(s4) {
    return IPv4Reg.test(s4);
  };
  var isIPv6 = function(s4) {
    return IPv6Reg.test(s4);
  };
  var isIP = function(s4) {
    if (isIPv4(s4))
      return 4;
    if (isIPv6(s4))
      return 6;
    return 0;
  };
  var validatePhoneNumber = function(input) {
    return phoneNumberRegex.test(input);
  };
  var combinedErrorFn = function(...fns) {
    switch (fns.length) {
      case 0:
        return () => null;
      case 1:
        return fns[0];
      case 2: {
        const [fn0, fn1] = fns;
        return (...params) => fn0(...params) || fn1(...params);
      }
      default: {
        return (...params) => {
          for (const fn of fns) {
            const result = fn(...params);
            if (result)
              return result;
          }
          return null;
        };
      }
    }
  };
  var createUrlValidators = function(options, validatorOptions) {
    const fns = [];
    if (options?.allowedProtocols?.length)
      fns.push(allowedProtocolsFn(options.allowedProtocols, validatorOptions));
    if (options?.allowedDomains?.length)
      fns.push(allowedDomainsFn(options.allowedDomains, validatorOptions));
    return combinedErrorFn(...fns);
  };
  var allowedProtocolsFn = function(allowedProtocols, options) {
    return (input, url) => allowedProtocols.includes(url.protocol) ? null : new MultiplePossibilitiesConstraintError("s.string().url()", options?.message ?? "Invalid URL protocol", input, allowedProtocols);
  };
  var allowedDomainsFn = function(allowedDomains, options) {
    return (input, url) => allowedDomains.includes(url.hostname) ? null : new MultiplePossibilitiesConstraintError("s.string().url()", options?.message ?? "Invalid URL domain", input, allowedDomains);
  };
  var stringLengthComparator = function(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid string length", input, expected));
      }
    };
  };
  var stringLengthLessThan = function(length, options) {
    const expected = `expected.length < ${length}`;
    return stringLengthComparator(lessThan, "s.string().lengthLessThan()", expected, length, options);
  };
  var stringLengthLessThanOrEqual = function(length, options) {
    const expected = `expected.length <= ${length}`;
    return stringLengthComparator(lessThanOrEqual, "s.string().lengthLessThanOrEqual()", expected, length, options);
  };
  var stringLengthGreaterThan = function(length, options) {
    const expected = `expected.length > ${length}`;
    return stringLengthComparator(greaterThan, "s.string().lengthGreaterThan()", expected, length, options);
  };
  var stringLengthGreaterThanOrEqual = function(length, options) {
    const expected = `expected.length >= ${length}`;
    return stringLengthComparator(greaterThanOrEqual, "s.string().lengthGreaterThanOrEqual()", expected, length, options);
  };
  var stringLengthEqual = function(length, options) {
    const expected = `expected.length === ${length}`;
    return stringLengthComparator(equal, "s.string().lengthEqual()", expected, length, options);
  };
  var stringLengthNotEqual = function(length, options) {
    const expected = `expected.length !== ${length}`;
    return stringLengthComparator(notEqual, "s.string().lengthNotEqual()", expected, length, options);
  };
  var stringEmail = function(options) {
    return {
      run(input) {
        return validateEmail(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string().email()", options?.message ?? "Invalid email address", input, "expected to be an email address"));
      }
    };
  };
  var stringRegexValidator = function(type, expected, regex, options) {
    return {
      run(input) {
        return regex.test(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(type, options?.message ?? "Invalid string format", input, expected));
      }
    };
  };
  var stringUrl = function(options, validatorOptions) {
    const validatorFn = createUrlValidators(options, validatorOptions);
    return {
      run(input) {
        let url;
        try {
          url = new URL(input);
        } catch {
          return Result.err(new ExpectedConstraintError("s.string().url()", validatorOptions?.message ?? "Invalid URL", input, "expected to match a URL"));
        }
        const validatorFnResult = validatorFn(input, url);
        if (validatorFnResult === null)
          return Result.ok(input);
        return Result.err(validatorFnResult);
      }
    };
  };
  var stringIp = function(version, options) {
    const ipVersion = version ? `v${version}` : "";
    const validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;
    const name = `s.string().ip${ipVersion}()`;
    const message = `Invalid IP${ipVersion} address`;
    const expected = `expected to be an IP${ipVersion} address`;
    return {
      run(input) {
        return validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? message, input, expected));
      }
    };
  };
  var stringRegex = function(regex, options) {
    return stringRegexValidator("s.string().regex()", `expected ${regex}.test(expected) to be true`, regex, options);
  };
  var stringUuid = function({ version = 4, nullable = false } = {}, options) {
    version ?? (version = "1-5");
    const regex = new RegExp(`^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${nullable ? "|00000000-0000-0000-0000-000000000000" : ""})\$`, "i");
    const expected = `expected to match UUID${typeof version === "number" ? `v${version}` : ` in range of ${version}`}`;
    return stringRegexValidator("s.string().uuid()", expected, regex, options);
  };
  var stringDate = function(options) {
    return {
      run(input) {
        const time = Date.parse(input);
        return Number.isNaN(time) ? Result.err(new ExpectedConstraintError("s.string().date()", options?.message ?? "Invalid date string", input, "expected to be a valid date string (in the ISO 8601 or ECMA-262 format)")) : Result.ok(input);
      }
    };
  };
  var stringPhone = function(options) {
    return {
      run(input) {
        return validatePhoneNumber(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string().phone()", options?.message ?? "Invalid phone number", input, "expected to be a phone number"));
      }
    };
  };
  var typedArrayByteLengthComparator = function(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.byteLength, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayByteLengthLessThan = function(value, options) {
    const expected = `expected.byteLength < ${value}`;
    return typedArrayByteLengthComparator(lessThan, "s.typedArray(T).byteLengthLessThan()", expected, value, options);
  };
  var typedArrayByteLengthLessThanOrEqual = function(value, options) {
    const expected = `expected.byteLength <= ${value}`;
    return typedArrayByteLengthComparator(lessThanOrEqual, "s.typedArray(T).byteLengthLessThanOrEqual()", expected, value, options);
  };
  var typedArrayByteLengthGreaterThan = function(value, options) {
    const expected = `expected.byteLength > ${value}`;
    return typedArrayByteLengthComparator(greaterThan, "s.typedArray(T).byteLengthGreaterThan()", expected, value, options);
  };
  var typedArrayByteLengthGreaterThanOrEqual = function(value, options) {
    const expected = `expected.byteLength >= ${value}`;
    return typedArrayByteLengthComparator(greaterThanOrEqual, "s.typedArray(T).byteLengthGreaterThanOrEqual()", expected, value, options);
  };
  var typedArrayByteLengthEqual = function(value, options) {
    const expected = `expected.byteLength === ${value}`;
    return typedArrayByteLengthComparator(equal, "s.typedArray(T).byteLengthEqual()", expected, value, options);
  };
  var typedArrayByteLengthNotEqual = function(value, options) {
    const expected = `expected.byteLength !== ${value}`;
    return typedArrayByteLengthComparator(notEqual, "s.typedArray(T).byteLengthNotEqual()", expected, value, options);
  };
  var typedArrayByteLengthRange = function(start, endBefore, options) {
    const expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;
    return {
      run(input) {
        return input.byteLength >= start && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRange()", options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayByteLengthRangeInclusive = function(start, end, options) {
    const expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;
    return {
      run(input) {
        return input.byteLength >= start && input.byteLength <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRangeInclusive()", options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayByteLengthRangeExclusive = function(startAfter, endBefore, options) {
    const expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;
    return {
      run(input) {
        return input.byteLength > startAfter && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRangeExclusive()", options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayLengthComparator = function(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  };
  var typedArrayLengthLessThan = function(value, options) {
    const expected = `expected.length < ${value}`;
    return typedArrayLengthComparator(lessThan, "s.typedArray(T).lengthLessThan()", expected, value, options);
  };
  var typedArrayLengthLessThanOrEqual = function(value, options) {
    const expected = `expected.length <= ${value}`;
    return typedArrayLengthComparator(lessThanOrEqual, "s.typedArray(T).lengthLessThanOrEqual()", expected, value, options);
  };
  var typedArrayLengthGreaterThan = function(value, options) {
    const expected = `expected.length > ${value}`;
    return typedArrayLengthComparator(greaterThan, "s.typedArray(T).lengthGreaterThan()", expected, value, options);
  };
  var typedArrayLengthGreaterThanOrEqual = function(value, options) {
    const expected = `expected.length >= ${value}`;
    return typedArrayLengthComparator(greaterThanOrEqual, "s.typedArray(T).lengthGreaterThanOrEqual()", expected, value, options);
  };
  var typedArrayLengthEqual = function(value, options) {
    const expected = `expected.length === ${value}`;
    return typedArrayLengthComparator(equal, "s.typedArray(T).lengthEqual()", expected, value, options);
  };
  var typedArrayLengthNotEqual = function(value, options) {
    const expected = `expected.length !== ${value}`;
    return typedArrayLengthComparator(notEqual, "s.typedArray(T).lengthNotEqual()", expected, value, options);
  };
  var typedArrayLengthRange = function(start, endBefore, options) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRange()", options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  };
  var typedArrayLengthRangeInclusive = function(start, end, options) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeInclusive()", options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  };
  var typedArrayLengthRangeExclusive = function(startAfter, endBefore, options) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeExclusive()", options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  };
  var get = require_get();
  var fastDeepEqual = require_es6();
  var uniqWith = require_uniqWith();
  var get__default = _interopDefault(get);
  var fastDeepEqual__default = _interopDefault(fastDeepEqual);
  var uniqWith__default = _interopDefault(uniqWith);
  var __defProp2 = Object.defineProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var e;
  var t;
  var n;
  var r = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : globalThis;
  var o = e = {};
  __name(i, "i");
  __name(u, "u");
  __name(c, "c");
  (function() {
    try {
      t = typeof setTimeout == "function" ? setTimeout : i;
    } catch (e3) {
      t = i;
    }
    try {
      n = typeof clearTimeout == "function" ? clearTimeout : u;
    } catch (e3) {
      n = u;
    }
  })();
  var l;
  var s = [];
  var f = false;
  var a = -1;
  __name(h, "h");
  __name(d, "d");
  __name(m, "m");
  __name(p, "p");
  o.nextTick = function(e3) {
    var t3 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n3 = 1;n3 < arguments.length; n3++)
        t3[n3 - 1] = arguments[n3];
    s.push(new m(e3, t3)), s.length !== 1 || f || c(d);
  }, m.prototype.run = function() {
    (this || r).fun.apply(null, (this || r).array);
  }, o.title = "browser", o.browser = true, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = p, o.addListener = p, o.once = p, o.off = p, o.removeListener = p, o.removeAllListeners = p, o.emit = p, o.prependListener = p, o.prependOnceListener = p, o.listeners = function(e3) {
    return [];
  }, o.binding = function(e3) {
    throw new Error("process.binding is not supported");
  }, o.cwd = function() {
    return "/";
  }, o.chdir = function(e3) {
    throw new Error("process.chdir is not supported");
  }, o.umask = function() {
    return 0;
  };
  var T = e;
  T.addListener;
  T.argv;
  T.binding;
  T.browser;
  T.chdir;
  T.cwd;
  T.emit;
  T.env;
  T.listeners;
  T.nextTick;
  T.off;
  T.on;
  T.once;
  T.prependListener;
  T.prependOnceListener;
  T.removeAllListeners;
  T.removeListener;
  T.title;
  T.umask;
  T.version;
  T.versions;
  var t2 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
  var e2 = Object.prototype.toString;
  var o2 = __name(function(o3) {
    return !(t2 && o3 && typeof o3 == "object" && (Symbol.toStringTag in o3)) && e2.call(o3) === "[object Arguments]";
  }, "o");
  var n2 = __name(function(t3) {
    return !!o2(t3) || t3 !== null && typeof t3 == "object" && typeof t3.length == "number" && t3.length >= 0 && e2.call(t3) !== "[object Array]" && e2.call(t3.callee) === "[object Function]";
  }, "n");
  var r2 = function() {
    return o2(arguments);
  }();
  o2.isLegacyArguments = n2;
  var l2 = r2 ? o2 : n2;
  var t$1 = Object.prototype.toString;
  var o$1 = Function.prototype.toString;
  var n$1 = /^\s*(?:function)?\*/;
  var e$1 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
  var r$1 = Object.getPrototypeOf;
  var c2 = function() {
    if (!e$1)
      return false;
    try {
      return Function("return function*() {}")();
    } catch (t3) {
    }
  }();
  var u2 = c2 ? r$1(c2) : {};
  var i2 = __name(function(c3) {
    return typeof c3 == "function" && (!!n$1.test(o$1.call(c3)) || (e$1 ? r$1(c3) === u2 : t$1.call(c3) === "[object GeneratorFunction]"));
  }, "i");
  var t$2 = typeof Object.create == "function" ? function(t3, e3) {
    e3 && (t3.super_ = e3, t3.prototype = Object.create(e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }));
  } : function(t3, e3) {
    if (e3) {
      t3.super_ = e3;
      var o3 = __name(function() {
      }, "o");
      o3.prototype = e3.prototype, t3.prototype = new o3, t3.prototype.constructor = t3;
    }
  };
  var i$1 = __name(function(e3) {
    return e3 && typeof e3 == "object" && typeof e3.copy == "function" && typeof e3.fill == "function" && typeof e3.readUInt8 == "function";
  }, "i$1");
  var o$2 = {};
  var u$1 = i$1;
  var f2 = l2;
  var a2 = i2;
  __name(c$1, "c$1");
  var s2 = typeof BigInt != "undefined";
  var p2 = typeof Symbol != "undefined";
  var y = p2 && Symbol.toStringTag !== undefined;
  var l$1 = typeof Uint8Array != "undefined";
  var d2 = typeof ArrayBuffer != "undefined";
  if (l$1 && y)
    var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
  var m2 = c$1(Object.prototype.toString);
  var h2 = c$1(Number.prototype.valueOf);
  var j = c$1(String.prototype.valueOf);
  var A = c$1(Boolean.prototype.valueOf);
  if (s2)
    var w = c$1(BigInt.prototype.valueOf);
  if (p2)
    var v = c$1(Symbol.prototype.valueOf);
  __name(O, "O");
  __name(S, "S");
  __name(B, "B");
  __name(k, "k");
  __name(E, "E");
  __name(D, "D");
  __name(U, "U");
  __name(P, "P");
  __name(x, "x");
  __name(I, "I");
  __name(M, "M");
  __name(z, "z");
  __name(F, "F");
  __name(T2, "T");
  __name(N, "N");
  __name(W, "W");
  __name($, "$");
  __name(C, "C");
  __name(V, "V");
  __name(G, "G");
  __name(R, "R");
  __name(J, "J");
  __name(_, "_");
  __name(H, "H");
  __name(Z, "Z");
  __name(q, "q");
  __name(K, "K");
  __name(L, "L");
  o$2.isArgumentsObject = f2, o$2.isGeneratorFunction = a2, o$2.isPromise = function(e3) {
    return typeof Promise != "undefined" && e3 instanceof Promise || e3 !== null && typeof e3 == "object" && typeof e3.then == "function" && typeof e3.catch == "function";
  }, o$2.isArrayBufferView = function(e3) {
    return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e3) : S(e3) || R(e3);
  }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = typeof Map != "undefined" && T2(new Map), o$2.isMap = function(e3) {
    return typeof Map != "undefined" && (T2.working ? T2(e3) : e3 instanceof Map);
  }, N.working = typeof Set != "undefined" && N(new Set), o$2.isSet = function(e3) {
    return typeof Set != "undefined" && (N.working ? N(e3) : e3 instanceof Set);
  }, W.working = typeof WeakMap != "undefined" && W(new WeakMap), o$2.isWeakMap = function(e3) {
    return typeof WeakMap != "undefined" && (W.working ? W(e3) : e3 instanceof WeakMap);
  }, $.working = typeof WeakSet != "undefined" && $(new WeakSet), o$2.isWeakSet = function(e3) {
    return $(e3);
  }, C.working = typeof ArrayBuffer != "undefined" && C(new ArrayBuffer), o$2.isArrayBuffer = V, G.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = typeof SharedArrayBuffer != "undefined" && J(new SharedArrayBuffer), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e3) {
    return m2(e3) === "[object AsyncFunction]";
  }, o$2.isMapIterator = function(e3) {
    return m2(e3) === "[object Map Iterator]";
  }, o$2.isSetIterator = function(e3) {
    return m2(e3) === "[object Set Iterator]";
  }, o$2.isGeneratorObject = function(e3) {
    return m2(e3) === "[object Generator]";
  }, o$2.isWebAssemblyCompiledModule = function(e3) {
    return m2(e3) === "[object WebAssembly.Module]";
  }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e3) {
    return H(e3) || Z(e3) || q(e3) || K(e3) || L(e3);
  }, o$2.isAnyArrayBuffer = function(e3) {
    return l$1 && (V(e3) || _(e3));
  }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e3) {
    Object.defineProperty(o$2, e3, { enumerable: false, value: function() {
      throw new Error(e3 + " is not supported in userland");
    } });
  });
  var Q = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : globalThis;
  var X = {};
  var Y = T;
  var ee = Object.getOwnPropertyDescriptors || function(e3) {
    for (var t3 = Object.keys(e3), r3 = {}, n3 = 0;n3 < t3.length; n3++)
      r3[t3[n3]] = Object.getOwnPropertyDescriptor(e3, t3[n3]);
    return r3;
  };
  var te = /%[sdj%]/g;
  X.format = function(e3) {
    if (!ge(e3)) {
      for (var t3 = [], r3 = 0;r3 < arguments.length; r3++)
        t3.push(oe(arguments[r3]));
      return t3.join(" ");
    }
    r3 = 1;
    for (var n3 = arguments, i3 = n3.length, o3 = String(e3).replace(te, function(e4) {
      if (e4 === "%%")
        return "%";
      if (r3 >= i3)
        return e4;
      switch (e4) {
        case "%s":
          return String(n3[r3++]);
        case "%d":
          return Number(n3[r3++]);
        case "%j":
          try {
            return JSON.stringify(n3[r3++]);
          } catch (e5) {
            return "[Circular]";
          }
        default:
          return e4;
      }
    }), u3 = n3[r3];r3 < i3; u3 = n3[++r3])
      le(u3) || !he(u3) ? o3 += " " + u3 : o3 += " " + oe(u3);
    return o3;
  }, X.deprecate = function(e3, t3) {
    if (Y !== undefined && Y.noDeprecation === true)
      return e3;
    if (Y === undefined)
      return function() {
        return X.deprecate(e3, t3).apply(this || Q, arguments);
      };
    var r3 = false;
    return function() {
      if (!r3) {
        if (Y.throwDeprecation)
          throw new Error(t3);
        Y.traceDeprecation ? console.trace(t3) : console.error(t3), r3 = true;
      }
      return e3.apply(this || Q, arguments);
    };
  };
  var re = {};
  var ne = /^$/;
  if (Y.env.NODE_DEBUG) {
    ie = Y.env.NODE_DEBUG;
    ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
  }
  var ie;
  __name(oe, "oe");
  __name(ue, "ue");
  __name(fe, "fe");
  __name(ae, "ae");
  __name(ce, "ce");
  __name(se, "se");
  __name(pe, "pe");
  __name(ye, "ye");
  __name(le, "le");
  __name(de, "de");
  __name(ge, "ge");
  __name(be, "be");
  __name(me, "me");
  __name(he, "he");
  __name(je, "je");
  __name(Ae, "Ae");
  __name(we, "we");
  __name(ve, "ve");
  __name(Oe, "Oe");
  X.debuglog = function(e3) {
    if (e3 = e3.toUpperCase(), !re[e3])
      if (ne.test(e3)) {
        var t3 = Y.pid;
        re[e3] = function() {
          var r3 = X.format.apply(X, arguments);
          console.error("%s %d: %s", e3, t3, r3);
        };
      } else
        re[e3] = function() {
        };
    return re[e3];
  }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e3) {
    return e3 == null;
  }, X.isNumber = de, X.isString = ge, X.isSymbol = function(e3) {
    return typeof e3 == "symbol";
  }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e3) {
    return e3 === null || typeof e3 == "boolean" || typeof e3 == "number" || typeof e3 == "string" || typeof e3 == "symbol" || e3 === undefined;
  }, X.isBuffer = i$1;
  var Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  __name(Be, "Be");
  __name(ke, "ke");
  X.log = function() {
    console.log("%s - %s", Be(), X.format.apply(X, arguments));
  }, X.inherits = t$2, X._extend = function(e3, t3) {
    if (!t3 || !he(t3))
      return e3;
    for (var r3 = Object.keys(t3), n3 = r3.length;n3--; )
      e3[r3[n3]] = t3[r3[n3]];
    return e3;
  };
  var Ee = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : undefined;
  __name(De, "De");
  X.promisify = function(e3) {
    if (typeof e3 != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (Ee && e3[Ee]) {
      var t3;
      if (typeof (t3 = e3[Ee]) != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(t3, Ee, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
    }
    function t3() {
      for (var t4, r3, n3 = new Promise(function(e4, n4) {
        t4 = e4, r3 = n4;
      }), i3 = [], o3 = 0;o3 < arguments.length; o3++)
        i3.push(arguments[o3]);
      i3.push(function(e4, n4) {
        e4 ? r3(e4) : t4(n4);
      });
      try {
        e3.apply(this || Q, i3);
      } catch (e4) {
        r3(e4);
      }
      return n3;
    }
    __name(t3, "t");
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Ee && Object.defineProperty(t3, Ee, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, ee(e3));
  }, X.promisify.custom = Ee, X.callbackify = function(e3) {
    if (typeof e3 != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function t3() {
      for (var t4 = [], r3 = 0;r3 < arguments.length; r3++)
        t4.push(arguments[r3]);
      var n3 = t4.pop();
      if (typeof n3 != "function")
        throw new TypeError("The last argument must be of type Function");
      var i3 = this || Q, o3 = __name(function() {
        return n3.apply(i3, arguments);
      }, "o");
      e3.apply(this || Q, t4).then(function(e4) {
        Y.nextTick(o3.bind(null, null, e4));
      }, function(e4) {
        Y.nextTick(De.bind(null, e4, o3));
      });
    }
    __name(t3, "t");
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Object.defineProperties(t3, ee(e3)), t3;
  };
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X.types;
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  var inspect2 = X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X.types;
  X.TextEncoder = globalThis.TextEncoder;
  X.TextDecoder = globalThis.TextDecoder;
  var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
  var customInspectSymbolStackLess = Symbol.for("nodejs.util.inspect.custom.stack-less");
  var _BaseError = class _BaseError2 extends Error {
    toJSON() {
      return {
        name: this.name,
        message: this.message
      };
    }
    [customInspectSymbol](depth, options) {
      return `${this[customInspectSymbolStackLess](depth, options)}
${this.stack.slice(this.stack.indexOf("\n"))}`;
    }
  };
  __name(_BaseError, "BaseError");
  var BaseError = _BaseError;
  var _BaseConstraintError = class _BaseConstraintError2 extends BaseError {
    constructor(constraint, message, given) {
      super(message);
      this.constraint = constraint;
      this.given = given;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        message: this.message
      };
    }
  };
  __name(_BaseConstraintError, "BaseConstraintError");
  var BaseConstraintError = _BaseConstraintError;
  var _ExpectedConstraintError = class _ExpectedConstraintError2 extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected,
        message: this.message
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ExpectedConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected: ", "string")}${options.stylize(this.expected, "boolean")}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_ExpectedConstraintError, "ExpectedConstraintError");
  var ExpectedConstraintError = _ExpectedConstraintError;
  var _Result = class _Result2 {
    constructor(success, value, error) {
      this.success = success;
      if (success) {
        this.value = value;
      } else {
        this.error = error;
      }
    }
    isOk() {
      return this.success;
    }
    isErr() {
      return !this.success;
    }
    unwrap() {
      if (this.isOk())
        return this.value;
      throw this.error;
    }
    static ok(value) {
      return new _Result2(true, value);
    }
    static err(error) {
      return new _Result2(false, undefined, error);
    }
  };
  __name(_Result, "Result");
  var Result = _Result;
  __name(whenConstraint, "whenConstraint");
  __name(resolveBooleanIs, "resolveBooleanIs");
  var validationEnabled = true;
  __name(setGlobalValidationEnabled, "setGlobalValidationEnabled");
  __name(getGlobalValidationEnabled, "getGlobalValidationEnabled");
  __name(getValue, "getValue");
  var _BaseValidator = class _BaseValidator2 {
    constructor(validatorOptions = {}, constraints = []) {
      this.constraints = [];
      this.isValidationEnabled = null;
      this.constraints = constraints;
      this.validatorOptions = validatorOptions;
    }
    setParent(parent) {
      this.parent = parent;
      return this;
    }
    optional(options = this.validatorOptions) {
      return new UnionValidator([new LiteralValidator(undefined, options), this.clone()], options);
    }
    nullable(options = this.validatorOptions) {
      return new UnionValidator([new LiteralValidator(null, options), this.clone()], options);
    }
    nullish(options = this.validatorOptions) {
      return new UnionValidator([new NullishValidator(options), this.clone()], options);
    }
    array(options = this.validatorOptions) {
      return new ArrayValidator(this.clone(), options);
    }
    set(options = this.validatorOptions) {
      return new SetValidator(this.clone(), options);
    }
    or(...predicates) {
      return new UnionValidator([this.clone(), ...predicates], this.validatorOptions);
    }
    transform(cb, options = this.validatorOptions) {
      return this.addConstraint({
        run: (input) => Result.ok(cb(input))
      }, options);
    }
    reshape(cb, options = this.validatorOptions) {
      return this.addConstraint({
        run: cb
      }, options);
    }
    default(value, options = this.validatorOptions) {
      return new DefaultValidator(this.clone(), value, options);
    }
    when(key, options, validatorOptions) {
      return this.addConstraint(whenConstraint(key, options, this, validatorOptions));
    }
    describe(description) {
      const clone = this.clone();
      clone.description = description;
      return clone;
    }
    run(value) {
      let result = this.handle(value);
      if (result.isErr())
        return result;
      for (const constraint of this.constraints) {
        result = constraint.run(result.value, this.parent);
        if (result.isErr())
          break;
      }
      return result;
    }
    parse(value) {
      if (!this.shouldRunConstraints) {
        return this.handle(value).unwrap();
      }
      return this.constraints.reduce((v2, constraint) => constraint.run(v2).unwrap(), this.handle(value).unwrap());
    }
    is(value) {
      return this.run(value).isOk();
    }
    setValidationEnabled(isValidationEnabled) {
      const clone = this.clone();
      clone.isValidationEnabled = isValidationEnabled;
      return clone;
    }
    getValidationEnabled() {
      return getValue(this.isValidationEnabled);
    }
    get shouldRunConstraints() {
      return getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();
    }
    clone() {
      const clone = Reflect.construct(this.constructor, [this.validatorOptions, this.constraints]);
      clone.isValidationEnabled = this.isValidationEnabled;
      return clone;
    }
    addConstraint(constraint, validatorOptions = this.validatorOptions) {
      const clone = this.clone();
      clone.validatorOptions = validatorOptions;
      clone.constraints = clone.constraints.concat(constraint);
      return clone;
    }
  };
  __name(_BaseValidator, "BaseValidator");
  var BaseValidator = _BaseValidator;
  __name(isUnique, "isUnique");
  __name(lessThan, "lessThan");
  __name(lessThanOrEqual, "lessThanOrEqual");
  __name(greaterThan, "greaterThan");
  __name(greaterThanOrEqual, "greaterThanOrEqual");
  __name(equal, "equal");
  __name(notEqual, "notEqual");
  __name(arrayLengthComparator, "arrayLengthComparator");
  __name(arrayLengthLessThan, "arrayLengthLessThan");
  __name(arrayLengthLessThanOrEqual, "arrayLengthLessThanOrEqual");
  __name(arrayLengthGreaterThan, "arrayLengthGreaterThan");
  __name(arrayLengthGreaterThanOrEqual, "arrayLengthGreaterThanOrEqual");
  __name(arrayLengthEqual, "arrayLengthEqual");
  __name(arrayLengthNotEqual, "arrayLengthNotEqual");
  __name(arrayLengthRange, "arrayLengthRange");
  __name(arrayLengthRangeInclusive, "arrayLengthRangeInclusive");
  __name(arrayLengthRangeExclusive, "arrayLengthRangeExclusive");
  __name(uniqueArray, "uniqueArray");
  var _CombinedPropertyError = class _CombinedPropertyError2 extends BaseError {
    constructor(errors, validatorOptions) {
      super(validatorOptions?.message ?? "Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedPropertyError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedPropertyError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map(([key, error]) => {
        const property = _CombinedPropertyError2.formatProperty(key, options);
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
        return `  input${property}${padding}${body}`;
      }).join("\n\n");
      return `${header}
  ${message}

${errors}`;
    }
    static formatProperty(key, options) {
      if (typeof key === "string")
        return options.stylize(`.${key}`, "symbol");
      if (typeof key === "number")
        return `[${options.stylize(key.toString(), "number")}]`;
      return `[${options.stylize("Symbol", "symbol")}(${key.description})]`;
    }
  };
  __name(_CombinedPropertyError, "CombinedPropertyError");
  var CombinedPropertyError = _CombinedPropertyError;
  var _ValidationError = class _ValidationError2 extends BaseError {
    constructor(validator, message, given) {
      super(message);
      this.validator = validator;
      this.given = given;
    }
    toJSON() {
      return {
        name: this.name,
        message: "Unknown validation error occurred.",
        validator: this.validator,
        given: this.given
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(_ValidationError, "ValidationError");
  var ValidationError = _ValidationError;
  var _ArrayValidator = class _ArrayValidator2 extends BaseValidator {
    constructor(validator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    lengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthLessThan(length, options));
    }
    lengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthLessThanOrEqual(length, options));
    }
    lengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthGreaterThan(length, options));
    }
    lengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthGreaterThanOrEqual(length, options));
    }
    lengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthEqual(length, options));
    }
    lengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthNotEqual(length, options));
    }
    lengthRange(start, endBefore, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthRange(start, endBefore, options));
    }
    lengthRangeInclusive(startAt, endAt, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt, options));
    }
    lengthRangeExclusive(startAfter, endBefore, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore, options));
    }
    unique(options = this.validatorOptions) {
      return this.addConstraint(uniqueArray(options));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.array(T)", this.validatorOptions.message ?? "Expected an array", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i3 = 0;i3 < values.length; i3++) {
        const result = this.validator.run(values[i3]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i3, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_ArrayValidator, "ArrayValidator");
  var ArrayValidator = _ArrayValidator;
  __name(bigintComparator, "bigintComparator");
  __name(bigintLessThan, "bigintLessThan");
  __name(bigintLessThanOrEqual, "bigintLessThanOrEqual");
  __name(bigintGreaterThan, "bigintGreaterThan");
  __name(bigintGreaterThanOrEqual, "bigintGreaterThanOrEqual");
  __name(bigintEqual, "bigintEqual");
  __name(bigintNotEqual, "bigintNotEqual");
  __name(bigintDivisibleBy, "bigintDivisibleBy");
  var _BigIntValidator = class _BigIntValidator2 extends BaseValidator {
    lessThan(number, options = this.validatorOptions) {
      return this.addConstraint(bigintLessThan(number, options));
    }
    lessThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(bigintLessThanOrEqual(number, options));
    }
    greaterThan(number, options = this.validatorOptions) {
      return this.addConstraint(bigintGreaterThan(number, options));
    }
    greaterThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(bigintGreaterThanOrEqual(number, options));
    }
    equal(number, options = this.validatorOptions) {
      return this.addConstraint(bigintEqual(number, options));
    }
    notEqual(number, options = this.validatorOptions) {
      return this.addConstraint(bigintNotEqual(number, options));
    }
    positive(options = this.validatorOptions) {
      return this.greaterThanOrEqual(0n, options);
    }
    negative(options = this.validatorOptions) {
      return this.lessThan(0n, options);
    }
    divisibleBy(number, options = this.validatorOptions) {
      return this.addConstraint(bigintDivisibleBy(number, options));
    }
    abs(options = this.validatorOptions) {
      return this.transform((value) => value < 0 ? -value : value, options);
    }
    intN(bits, options = this.validatorOptions) {
      return this.transform((value) => BigInt.asIntN(bits, value), options);
    }
    uintN(bits, options = this.validatorOptions) {
      return this.transform((value) => BigInt.asUintN(bits, value), options);
    }
    handle(value) {
      return typeof value === "bigint" ? Result.ok(value) : Result.err(new ValidationError("s.bigint()", this.validatorOptions.message ?? "Expected a bigint primitive", value));
    }
  };
  __name(_BigIntValidator, "BigIntValidator");
  var BigIntValidator = _BigIntValidator;
  __name(booleanTrue, "booleanTrue");
  __name(booleanFalse, "booleanFalse");
  var _BooleanValidator = class _BooleanValidator2 extends BaseValidator {
    true(options = this.validatorOptions) {
      return this.addConstraint(booleanTrue(options));
    }
    false(options = this.validatorOptions) {
      return this.addConstraint(booleanFalse(options));
    }
    equal(value, options = this.validatorOptions) {
      return value ? this.true(options) : this.false(options);
    }
    notEqual(value, options = this.validatorOptions) {
      return value ? this.false(options) : this.true(options);
    }
    handle(value) {
      return typeof value === "boolean" ? Result.ok(value) : Result.err(new ValidationError("s.boolean()", this.validatorOptions.message ?? "Expected a boolean primitive", value));
    }
  };
  __name(_BooleanValidator, "BooleanValidator");
  var BooleanValidator = _BooleanValidator;
  __name(dateComparator, "dateComparator");
  __name(dateLessThan, "dateLessThan");
  __name(dateLessThanOrEqual, "dateLessThanOrEqual");
  __name(dateGreaterThan, "dateGreaterThan");
  __name(dateGreaterThanOrEqual, "dateGreaterThanOrEqual");
  __name(dateEqual, "dateEqual");
  __name(dateNotEqual, "dateNotEqual");
  __name(dateInvalid, "dateInvalid");
  __name(dateValid, "dateValid");
  var _DateValidator = class _DateValidator2 extends BaseValidator {
    lessThan(date, options = this.validatorOptions) {
      return this.addConstraint(dateLessThan(new Date(date), options));
    }
    lessThanOrEqual(date, options = this.validatorOptions) {
      return this.addConstraint(dateLessThanOrEqual(new Date(date), options));
    }
    greaterThan(date, options = this.validatorOptions) {
      return this.addConstraint(dateGreaterThan(new Date(date), options));
    }
    greaterThanOrEqual(date, options = this.validatorOptions) {
      return this.addConstraint(dateGreaterThanOrEqual(new Date(date), options));
    }
    equal(date, options = this.validatorOptions) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.invalid(options) : this.addConstraint(dateEqual(resolved, options));
    }
    notEqual(date, options = this.validatorOptions) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.valid(options) : this.addConstraint(dateNotEqual(resolved, options));
    }
    valid(options = this.validatorOptions) {
      return this.addConstraint(dateValid(options));
    }
    invalid(options = this.validatorOptions) {
      return this.addConstraint(dateInvalid(options));
    }
    handle(value) {
      return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError("s.date()", this.validatorOptions.message ?? "Expected a Date", value));
    }
  };
  __name(_DateValidator, "DateValidator");
  var DateValidator = _DateValidator;
  var _ExpectedValidationError = class _ExpectedValidationError2 extends ValidationError {
    constructor(validator, message, given, expected) {
      super(validator, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        validator: this.validator,
        given: this.given,
        expected: this.expected,
        message: this.message
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const expected = inspect2(this.expected, newOptions).replace(/\n/g, padding);
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ExpectedValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected:", "string")}${padding}${expected}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_ExpectedValidationError, "ExpectedValidationError");
  var ExpectedValidationError = _ExpectedValidationError;
  var _InstanceValidator = class _InstanceValidator2 extends BaseValidator {
    constructor(expected, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.expected = expected;
    }
    handle(value) {
      return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError("s.instance(V)", this.validatorOptions.message ?? "Expected", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.validatorOptions, this.constraints]);
    }
  };
  __name(_InstanceValidator, "InstanceValidator");
  var InstanceValidator = _InstanceValidator;
  var _LiteralValidator = class _LiteralValidator2 extends BaseValidator {
    constructor(literal, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.expected = literal;
    }
    handle(value) {
      return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError("s.literal(V)", this.validatorOptions.message ?? "Expected values to be equals", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.validatorOptions, this.constraints]);
    }
  };
  __name(_LiteralValidator, "LiteralValidator");
  var LiteralValidator = _LiteralValidator;
  var _NeverValidator = class _NeverValidator2 extends BaseValidator {
    handle(value) {
      return Result.err(new ValidationError("s.never()", this.validatorOptions.message ?? "Expected a value to not be passed", value));
    }
  };
  __name(_NeverValidator, "NeverValidator");
  var NeverValidator = _NeverValidator;
  var _NullishValidator = class _NullishValidator2 extends BaseValidator {
    handle(value) {
      return value === undefined || value === null ? Result.ok(value) : Result.err(new ValidationError("s.nullish()", this.validatorOptions.message ?? "Expected undefined or null", value));
    }
  };
  __name(_NullishValidator, "NullishValidator");
  var NullishValidator = _NullishValidator;
  __name(numberComparator, "numberComparator");
  __name(numberLessThan, "numberLessThan");
  __name(numberLessThanOrEqual, "numberLessThanOrEqual");
  __name(numberGreaterThan, "numberGreaterThan");
  __name(numberGreaterThanOrEqual, "numberGreaterThanOrEqual");
  __name(numberEqual, "numberEqual");
  __name(numberNotEqual, "numberNotEqual");
  __name(numberInt, "numberInt");
  __name(numberSafeInt, "numberSafeInt");
  __name(numberFinite, "numberFinite");
  __name(numberNaN, "numberNaN");
  __name(numberNotNaN, "numberNotNaN");
  __name(numberDivisibleBy, "numberDivisibleBy");
  var _NumberValidator = class _NumberValidator2 extends BaseValidator {
    lessThan(number, options = this.validatorOptions) {
      return this.addConstraint(numberLessThan(number, options));
    }
    lessThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(numberLessThanOrEqual(number, options));
    }
    greaterThan(number, options = this.validatorOptions) {
      return this.addConstraint(numberGreaterThan(number, options));
    }
    greaterThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(numberGreaterThanOrEqual(number, options));
    }
    equal(number, options = this.validatorOptions) {
      return Number.isNaN(number) ? this.addConstraint(numberNaN(options)) : this.addConstraint(numberEqual(number, options));
    }
    notEqual(number, options = this.validatorOptions) {
      return Number.isNaN(number) ? this.addConstraint(numberNotNaN(options)) : this.addConstraint(numberNotEqual(number, options));
    }
    int(options = this.validatorOptions) {
      return this.addConstraint(numberInt(options));
    }
    safeInt(options = this.validatorOptions) {
      return this.addConstraint(numberSafeInt(options));
    }
    finite(options = this.validatorOptions) {
      return this.addConstraint(numberFinite(options));
    }
    positive(options = this.validatorOptions) {
      return this.greaterThanOrEqual(0, options);
    }
    negative(options = this.validatorOptions) {
      return this.lessThan(0, options);
    }
    divisibleBy(divider, options = this.validatorOptions) {
      return this.addConstraint(numberDivisibleBy(divider, options));
    }
    abs(options = this.validatorOptions) {
      return this.transform(Math.abs, options);
    }
    sign(options = this.validatorOptions) {
      return this.transform(Math.sign, options);
    }
    trunc(options = this.validatorOptions) {
      return this.transform(Math.trunc, options);
    }
    floor(options = this.validatorOptions) {
      return this.transform(Math.floor, options);
    }
    fround(options = this.validatorOptions) {
      return this.transform(Math.fround, options);
    }
    round(options = this.validatorOptions) {
      return this.transform(Math.round, options);
    }
    ceil(options = this.validatorOptions) {
      return this.transform(Math.ceil, options);
    }
    handle(value) {
      return typeof value === "number" ? Result.ok(value) : Result.err(new ValidationError("s.number()", this.validatorOptions.message ?? "Expected a number primitive", value));
    }
  };
  __name(_NumberValidator, "NumberValidator");
  var NumberValidator = _NumberValidator;
  var _MissingPropertyError = class _MissingPropertyError2 extends BaseError {
    constructor(property, validatorOptions) {
      super(validatorOptions?.message ?? "A required property is missing");
      this.property = property;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        property: this.property
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[MissingPropertyError: ${property}]`, "special");
      }
      const header = `${options.stylize("MissingPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      return `${header}
  ${message}`;
    }
  };
  __name(_MissingPropertyError, "MissingPropertyError");
  var MissingPropertyError = _MissingPropertyError;
  var _UnknownPropertyError = class _UnknownPropertyError2 extends BaseError {
    constructor(property, value, options) {
      super(options?.message ?? "Received unexpected property");
      this.property = property;
      this.value = value;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        property: this.property,
        value: this.value
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownPropertyError: ${property}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.value, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("UnknownPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(_UnknownPropertyError, "UnknownPropertyError");
  var UnknownPropertyError = _UnknownPropertyError;
  var _DefaultValidator = class _DefaultValidator2 extends BaseValidator {
    constructor(validator, value, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
      this.defaultValue = value;
    }
    default(value, options = this.validatorOptions) {
      const clone = this.clone();
      clone.validatorOptions = options;
      clone.defaultValue = value;
      return clone;
    }
    handle(value) {
      return typeof value === "undefined" ? Result.ok(getValue(this.defaultValue)) : this.validator["handle"](value);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.validatorOptions, this.constraints]);
    }
  };
  __name(_DefaultValidator, "DefaultValidator");
  var DefaultValidator = _DefaultValidator;
  var _CombinedError = class _CombinedError2 extends BaseError {
    constructor(errors, validatorOptions) {
      super(validatorOptions?.message ?? "Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map((error, i3) => {
        const index = options.stylize((i3 + 1).toString(), "number");
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
        return `  ${index} ${body}`;
      }).join("\n\n");
      return `${header}
  ${message}

${errors}`;
    }
  };
  __name(_CombinedError, "CombinedError");
  var CombinedError = _CombinedError;
  var _UnionValidator = class _UnionValidator2 extends BaseValidator {
    constructor(validators, validatorOptions, constraints = []) {
      super(validatorOptions, constraints);
      this.validators = validators;
    }
    optional(options = this.validatorOptions) {
      if (this.validators.length === 0)
        return new _UnionValidator2([new LiteralValidator(undefined, options)], this.validatorOptions, this.constraints);
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === undefined)
          return this.clone();
        if (validator.expected === null) {
          return new _UnionValidator2([new NullishValidator(options), ...this.validators.slice(1)], this.validatorOptions, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new LiteralValidator(undefined, options), ...this.validators], this.validatorOptions);
    }
    required(options = this.validatorOptions) {
      if (this.validators.length === 0)
        return this.clone();
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === undefined) {
          return new _UnionValidator2(this.validators.slice(1), this.validatorOptions, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return new _UnionValidator2([new LiteralValidator(null, options), ...this.validators.slice(1)], this.validatorOptions, this.constraints);
      }
      return this.clone();
    }
    nullable(options = this.validatorOptions) {
      if (this.validators.length === 0) {
        return new _UnionValidator2([new LiteralValidator(null, options)], this.validatorOptions, this.constraints);
      }
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === null)
          return this.clone();
        if (validator.expected === undefined) {
          return new _UnionValidator2([new NullishValidator(options), ...this.validators.slice(1)], this.validatorOptions, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new LiteralValidator(null, options), ...this.validators], this.validatorOptions);
    }
    nullish(options = this.validatorOptions) {
      if (this.validators.length === 0) {
        return new _UnionValidator2([new NullishValidator(options)], options, this.constraints);
      }
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === null || validator.expected === undefined) {
          return new _UnionValidator2([new NullishValidator(options), ...this.validators.slice(1)], options, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new NullishValidator(options), ...this.validators], options);
    }
    or(...predicates) {
      return new _UnionValidator2([...this.validators, ...predicates], this.validatorOptions);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validators, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      const errors = [];
      for (const validator of this.validators) {
        const result = validator.run(value);
        if (result.isOk())
          return result;
        errors.push(result.error);
      }
      return Result.err(new CombinedError(errors, this.validatorOptions));
    }
  };
  __name(_UnionValidator, "UnionValidator");
  var UnionValidator = _UnionValidator;
  var _ObjectValidator = class _ObjectValidator2 extends BaseValidator {
    constructor(shape, strategy = 0, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.keys = [];
      this.requiredKeys = new Map;
      this.possiblyUndefinedKeys = new Map;
      this.possiblyUndefinedKeysWithDefaults = new Map;
      this.shape = shape;
      this.strategy = strategy;
      switch (this.strategy) {
        case 0:
          this.handleStrategy = (value) => this.handleIgnoreStrategy(value);
          break;
        case 1: {
          this.handleStrategy = (value) => this.handleStrictStrategy(value);
          break;
        }
        case 2:
          this.handleStrategy = (value) => this.handlePassthroughStrategy(value);
          break;
      }
      const shapeEntries = Object.entries(shape);
      this.keys = shapeEntries.map(([key]) => key);
      for (const [key, validator] of shapeEntries) {
        if (validator instanceof UnionValidator) {
          const [possiblyLiteralOrNullishPredicate] = validator["validators"];
          if (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {
            if (possiblyLiteralOrNullishPredicate.expected === undefined) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof DefaultValidator) {
            this.possiblyUndefinedKeysWithDefaults.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        } else if (validator instanceof NullishValidator) {
          this.possiblyUndefinedKeys.set(key, validator);
        } else if (validator instanceof LiteralValidator) {
          if (validator.expected === undefined) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        } else if (validator instanceof DefaultValidator) {
          this.possiblyUndefinedKeysWithDefaults.set(key, validator);
        } else {
          this.requiredKeys.set(key, validator);
        }
      }
    }
    strict(options = this.validatorOptions) {
      return Reflect.construct(this.constructor, [this.shape, 1, options, this.constraints]);
    }
    ignore(options = this.validatorOptions) {
      return Reflect.construct(this.constructor, [this.shape, 0, options, this.constraints]);
    }
    passthrough(options = this.validatorOptions) {
      return Reflect.construct(this.constructor, [this.shape, 2, options, this.constraints]);
    }
    partial(options = this.validatorOptions) {
      const shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key].optional(options)]));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    required(options = this.validatorOptions) {
      const shape = Object.fromEntries(this.keys.map((key) => {
        let validator = this.shape[key];
        if (validator instanceof UnionValidator)
          validator = validator.required(options);
        return [key, validator];
      }));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    extend(schema, options = this.validatorOptions) {
      const shape = { ...this.shape, ...schema instanceof _ObjectValidator2 ? schema.shape : schema };
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    pick(keys, options = this.validatorOptions) {
      const shape = Object.fromEntries(keys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key]]));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    omit(keys, options = this.validatorOptions) {
      const shape = Object.fromEntries(this.keys.filter((key) => !keys.includes(key)).map((key) => [key, this.shape[key]]));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    handle(value) {
      const typeOfValue = typeof value;
      if (typeOfValue !== "object") {
        return Result.err(new ValidationError("s.object(T)", this.validatorOptions.message ?? `Expected the value to be an object, but received ${typeOfValue} instead`, value));
      }
      if (value === null) {
        return Result.err(new ValidationError("s.object(T)", this.validatorOptions.message ?? "Expected the value to not be null", value));
      }
      if (Array.isArray(value)) {
        return Result.err(new ValidationError("s.object(T)", this.validatorOptions.message ?? "Expected the value to not be an array", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      for (const predicate of Object.values(this.shape)) {
        predicate.setParent(this.parent ?? value);
      }
      return this.handleStrategy(value);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.shape, this.strategy, this.validatorOptions, this.constraints]);
    }
    handleIgnoreStrategy(value) {
      const errors = [];
      const finalObject = {};
      const inputEntries = new Map(Object.entries(value));
      const runPredicate = __name((key, predicate) => {
        const result = predicate.run(value[key]);
        if (result.isOk()) {
          finalObject[key] = result.value;
        } else {
          const error = result.error;
          errors.push([key, error]);
        }
      }, "runPredicate");
      for (const [key, predicate] of this.requiredKeys) {
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        } else {
          errors.push([key, new MissingPropertyError(key, this.validatorOptions)]);
        }
      }
      for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
        inputEntries.delete(key);
        runPredicate(key, validator);
      }
      if (inputEntries.size === 0) {
        return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
      }
      const checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;
      if (checkInputEntriesInsteadOfSchemaKeys) {
        for (const [key] of inputEntries) {
          const predicate = this.possiblyUndefinedKeys.get(key);
          if (predicate) {
            runPredicate(key, predicate);
          }
        }
      } else {
        for (const [key, predicate] of this.possiblyUndefinedKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          }
        }
      }
      return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
    handleStrictStrategy(value) {
      const errors = [];
      const finalResult = {};
      const inputEntries = new Map(Object.entries(value));
      const runPredicate = __name((key, predicate) => {
        const result = predicate.run(value[key]);
        if (result.isOk()) {
          finalResult[key] = result.value;
        } else {
          const error = result.error;
          errors.push([key, error]);
        }
      }, "runPredicate");
      for (const [key, predicate] of this.requiredKeys) {
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        } else {
          errors.push([key, new MissingPropertyError(key, this.validatorOptions)]);
        }
      }
      for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
        inputEntries.delete(key);
        runPredicate(key, validator);
      }
      for (const [key, predicate] of this.possiblyUndefinedKeys) {
        if (inputEntries.size === 0) {
          break;
        }
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        }
      }
      if (inputEntries.size !== 0) {
        for (const [key, value2] of inputEntries.entries()) {
          errors.push([key, new UnknownPropertyError(key, value2, this.validatorOptions)]);
        }
      }
      return errors.length === 0 ? Result.ok(finalResult) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
    handlePassthroughStrategy(value) {
      const result = this.handleIgnoreStrategy(value);
      return result.isErr() ? result : Result.ok({ ...value, ...result.value });
    }
  };
  __name(_ObjectValidator, "ObjectValidator");
  var ObjectValidator = _ObjectValidator;
  var _PassthroughValidator = class _PassthroughValidator2 extends BaseValidator {
    handle(value) {
      return Result.ok(value);
    }
  };
  __name(_PassthroughValidator, "PassthroughValidator");
  var PassthroughValidator = _PassthroughValidator;
  var _RecordValidator = class _RecordValidator2 extends BaseValidator {
    constructor(validator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      if (typeof value !== "object") {
        return Result.err(new ValidationError("s.record(T)", this.validatorOptions.message ?? "Expected an object", value));
      }
      if (value === null) {
        return Result.err(new ValidationError("s.record(T)", this.validatorOptions.message ?? "Expected the value to not be null", value));
      }
      if (Array.isArray(value)) {
        return Result.err(new ValidationError("s.record(T)", this.validatorOptions.message ?? "Expected the value to not be an array", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      const errors = [];
      const transformed = {};
      for (const [key, val] of Object.entries(value)) {
        const result = this.validator.run(val);
        if (result.isOk())
          transformed[key] = result.value;
        else
          errors.push([key, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_RecordValidator, "RecordValidator");
  var RecordValidator = _RecordValidator;
  var _SetValidator = class _SetValidator2 extends BaseValidator {
    constructor(validator, validatorOptions, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      if (!(values instanceof Set)) {
        return Result.err(new ValidationError("s.set(T)", this.validatorOptions.message ?? "Expected a set", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = new Set;
      for (const value of values) {
        const result = this.validator.run(value);
        if (result.isOk())
          transformed.add(result.value);
        else
          errors.push(result.error);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedError(errors, this.validatorOptions));
    }
  };
  __name(_SetValidator, "SetValidator");
  var SetValidator = _SetValidator;
  var accountRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]$/i;
  __name(validateEmail, "validateEmail");
  __name(validateEmailDomain, "validateEmailDomain");
  var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
  var IPv4Reg = new RegExp(`^${v4Str}\$`);
  var v6Seg = "(?:[0-9a-fA-F]{1,4})";
  var IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?\$`);
  __name(isIPv4, "isIPv4");
  __name(isIPv6, "isIPv6");
  __name(isIP, "isIP");
  var phoneNumberRegex = /^((?:\+|0{0,2})\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}$/;
  __name(validatePhoneNumber, "validatePhoneNumber");
  var _MultiplePossibilitiesConstraintError = class _MultiplePossibilitiesConstraintError2 extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const verticalLine = options.stylize("|", "undefined");
      const padding = `
  ${verticalLine} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("MultiplePossibilitiesConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedPadding = `
  ${verticalLine} - `;
      const expectedBlock = `
  ${options.stylize("Expected any of the following:", "string")}${expectedPadding}${this.expected.map((possible) => options.stylize(possible, "boolean")).join(expectedPadding)}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_MultiplePossibilitiesConstraintError, "MultiplePossibilitiesConstraintError");
  var MultiplePossibilitiesConstraintError = _MultiplePossibilitiesConstraintError;
  __name(combinedErrorFn, "combinedErrorFn");
  __name(createUrlValidators, "createUrlValidators");
  __name(allowedProtocolsFn, "allowedProtocolsFn");
  __name(allowedDomainsFn, "allowedDomainsFn");
  __name(stringLengthComparator, "stringLengthComparator");
  __name(stringLengthLessThan, "stringLengthLessThan");
  __name(stringLengthLessThanOrEqual, "stringLengthLessThanOrEqual");
  __name(stringLengthGreaterThan, "stringLengthGreaterThan");
  __name(stringLengthGreaterThanOrEqual, "stringLengthGreaterThanOrEqual");
  __name(stringLengthEqual, "stringLengthEqual");
  __name(stringLengthNotEqual, "stringLengthNotEqual");
  __name(stringEmail, "stringEmail");
  __name(stringRegexValidator, "stringRegexValidator");
  __name(stringUrl, "stringUrl");
  __name(stringIp, "stringIp");
  __name(stringRegex, "stringRegex");
  __name(stringUuid, "stringUuid");
  __name(stringDate, "stringDate");
  __name(stringPhone, "stringPhone");
  var _StringValidator = class _StringValidator2 extends BaseValidator {
    lengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthLessThan(length, options));
    }
    lengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthLessThanOrEqual(length, options));
    }
    lengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthGreaterThan(length, options));
    }
    lengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthGreaterThanOrEqual(length, options));
    }
    lengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthEqual(length, options));
    }
    lengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthNotEqual(length, options));
    }
    email(options = this.validatorOptions) {
      return this.addConstraint(stringEmail(options));
    }
    url(options, validatorOptions = this.validatorOptions) {
      const urlOptions = this.isUrlOptions(options);
      if (urlOptions) {
        return this.addConstraint(stringUrl(options, validatorOptions));
      }
      return this.addConstraint(stringUrl(undefined, validatorOptions));
    }
    uuid(options, validatorOptions = this.validatorOptions) {
      const stringUuidOptions = this.isStringUuidOptions(options);
      if (stringUuidOptions) {
        return this.addConstraint(stringUuid(options, validatorOptions));
      }
      return this.addConstraint(stringUuid(undefined, validatorOptions));
    }
    regex(regex, options = this.validatorOptions) {
      return this.addConstraint(stringRegex(regex, options));
    }
    date(options = this.validatorOptions) {
      return this.addConstraint(stringDate(options));
    }
    ipv4(options = this.validatorOptions) {
      return this.ip(4, options);
    }
    ipv6(options = this.validatorOptions) {
      return this.ip(6, options);
    }
    ip(version, options = this.validatorOptions) {
      return this.addConstraint(stringIp(version, options));
    }
    phone(options = this.validatorOptions) {
      return this.addConstraint(stringPhone(options));
    }
    handle(value) {
      return typeof value === "string" ? Result.ok(value) : Result.err(new ValidationError("s.string()", this.validatorOptions.message ?? "Expected a string primitive", value));
    }
    isUrlOptions(options) {
      return options?.message === undefined;
    }
    isStringUuidOptions(options) {
      return options?.message === undefined;
    }
  };
  __name(_StringValidator, "StringValidator");
  var StringValidator = _StringValidator;
  var _TupleValidator = class _TupleValidator2 extends BaseValidator {
    constructor(validators, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validators = [];
      this.validators = validators;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validators, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.tuple(T)", this.validatorOptions.message ?? "Expected an array", values));
      }
      if (values.length !== this.validators.length) {
        return Result.err(new ValidationError("s.tuple(T)", this.validatorOptions.message ?? `Expected an array of length ${this.validators.length}`, values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i3 = 0;i3 < values.length; i3++) {
        const result = this.validators[i3].run(values[i3]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i3, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_TupleValidator, "TupleValidator");
  var TupleValidator = _TupleValidator;
  var _MapValidator = class _MapValidator2 extends BaseValidator {
    constructor(keyValidator, valueValidator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.keyValidator = keyValidator;
      this.valueValidator = valueValidator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      if (!(value instanceof Map)) {
        return Result.err(new ValidationError("s.map(K, V)", this.validatorOptions.message ?? "Expected a map", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      const errors = [];
      const transformed = new Map;
      for (const [key, val] of value.entries()) {
        const keyResult = this.keyValidator.run(key);
        const valueResult = this.valueValidator.run(val);
        const { length } = errors;
        if (keyResult.isErr())
          errors.push([key, keyResult.error]);
        if (valueResult.isErr())
          errors.push([key, valueResult.error]);
        if (errors.length === length)
          transformed.set(keyResult.value, valueResult.value);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_MapValidator, "MapValidator");
  var MapValidator = _MapValidator;
  var _LazyValidator = class _LazyValidator2 extends BaseValidator {
    constructor(validator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      return this.validator(values).run(values);
    }
  };
  __name(_LazyValidator, "LazyValidator");
  var LazyValidator = _LazyValidator;
  var _UnknownEnumValueError = class _UnknownEnumValueError2 extends BaseError {
    constructor(value, keys, enumMappings, validatorOptions) {
      super(validatorOptions?.message ?? "Expected the value to be one of the following enum values:");
      this.value = value;
      this.enumKeys = keys;
      this.enumMappings = enumMappings;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        value: this.value,
        enumKeys: this.enumKeys,
        enumMappings: [...this.enumMappings.entries()]
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const value = options.stylize(this.value.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownEnumValueError: ${value}]`, "special");
      }
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const pairs = this.enumKeys.map((key) => {
        const enumValue = this.enumMappings.get(key);
        return `${options.stylize(key, "string")} or ${options.stylize(enumValue.toString(), typeof enumValue === "number" ? "number" : "string")}`;
      }).join(padding);
      const header = `${options.stylize("UnknownEnumValueError", "special")} > ${value}`;
      const message = options.stylize(this.message, "regexp");
      const pairsBlock = `${padding}${pairs}`;
      return `${header}
  ${message}
${pairsBlock}`;
    }
  };
  __name(_UnknownEnumValueError, "UnknownEnumValueError");
  var UnknownEnumValueError = _UnknownEnumValueError;
  var _NativeEnumValidator = class _NativeEnumValidator2 extends BaseValidator {
    constructor(enumShape, validatorOptions = {}) {
      super(validatorOptions);
      this.hasNumericElements = false;
      this.enumMapping = new Map;
      this.enumShape = enumShape;
      this.enumKeys = Object.keys(enumShape).filter((key) => {
        return typeof enumShape[enumShape[key]] !== "number";
      });
      for (const key of this.enumKeys) {
        const enumValue = enumShape[key];
        this.enumMapping.set(key, enumValue);
        this.enumMapping.set(enumValue, enumValue);
        if (typeof enumValue === "number") {
          this.hasNumericElements = true;
          this.enumMapping.set(`${enumValue}`, enumValue);
        }
      }
    }
    handle(value) {
      const typeOfValue = typeof value;
      if (typeOfValue === "number") {
        if (!this.hasNumericElements) {
          return Result.err(new ValidationError("s.nativeEnum(T)", this.validatorOptions.message ?? "Expected the value to be a string", value));
        }
      } else if (typeOfValue !== "string") {
        return Result.err(new ValidationError("s.nativeEnum(T)", this.validatorOptions.message ?? "Expected the value to be a string or number", value));
      }
      const casted = value;
      const possibleEnumValue = this.enumMapping.get(casted);
      return typeof possibleEnumValue === "undefined" ? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping, this.validatorOptions)) : Result.ok(possibleEnumValue);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.enumShape, this.validatorOptions]);
    }
  };
  __name(_NativeEnumValidator, "NativeEnumValidator");
  var NativeEnumValidator = _NativeEnumValidator;
  __name(typedArrayByteLengthComparator, "typedArrayByteLengthComparator");
  __name(typedArrayByteLengthLessThan, "typedArrayByteLengthLessThan");
  __name(typedArrayByteLengthLessThanOrEqual, "typedArrayByteLengthLessThanOrEqual");
  __name(typedArrayByteLengthGreaterThan, "typedArrayByteLengthGreaterThan");
  __name(typedArrayByteLengthGreaterThanOrEqual, "typedArrayByteLengthGreaterThanOrEqual");
  __name(typedArrayByteLengthEqual, "typedArrayByteLengthEqual");
  __name(typedArrayByteLengthNotEqual, "typedArrayByteLengthNotEqual");
  __name(typedArrayByteLengthRange, "typedArrayByteLengthRange");
  __name(typedArrayByteLengthRangeInclusive, "typedArrayByteLengthRangeInclusive");
  __name(typedArrayByteLengthRangeExclusive, "typedArrayByteLengthRangeExclusive");
  __name(typedArrayLengthComparator, "typedArrayLengthComparator");
  __name(typedArrayLengthLessThan, "typedArrayLengthLessThan");
  __name(typedArrayLengthLessThanOrEqual, "typedArrayLengthLessThanOrEqual");
  __name(typedArrayLengthGreaterThan, "typedArrayLengthGreaterThan");
  __name(typedArrayLengthGreaterThanOrEqual, "typedArrayLengthGreaterThanOrEqual");
  __name(typedArrayLengthEqual, "typedArrayLengthEqual");
  __name(typedArrayLengthNotEqual, "typedArrayLengthNotEqual");
  __name(typedArrayLengthRange, "typedArrayLengthRange");
  __name(typedArrayLengthRangeInclusive, "typedArrayLengthRangeInclusive");
  __name(typedArrayLengthRangeExclusive, "typedArrayLengthRangeExclusive");
  var vowels = ["a", "e", "i", "o", "u"];
  var aOrAn = __name((word) => {
    return `${vowels.includes(word[0].toLowerCase()) ? "an" : "a"} ${word}`;
  }, "aOrAn");
  var TypedArrays = {
    Int8Array: (x2) => x2 instanceof Int8Array,
    Uint8Array: (x2) => x2 instanceof Uint8Array,
    Uint8ClampedArray: (x2) => x2 instanceof Uint8ClampedArray,
    Int16Array: (x2) => x2 instanceof Int16Array,
    Uint16Array: (x2) => x2 instanceof Uint16Array,
    Int32Array: (x2) => x2 instanceof Int32Array,
    Uint32Array: (x2) => x2 instanceof Uint32Array,
    Float32Array: (x2) => x2 instanceof Float32Array,
    Float64Array: (x2) => x2 instanceof Float64Array,
    BigInt64Array: (x2) => x2 instanceof BigInt64Array,
    BigUint64Array: (x2) => x2 instanceof BigUint64Array,
    TypedArray: (x2) => ArrayBuffer.isView(x2) && !(x2 instanceof DataView)
  };
  var _TypedArrayValidator = class _TypedArrayValidator2 extends BaseValidator {
    constructor(type, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.type = type;
    }
    byteLengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthLessThan(length, options));
    }
    byteLengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthLessThanOrEqual(length, options));
    }
    byteLengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthGreaterThan(length, options));
    }
    byteLengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length, options));
    }
    byteLengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthEqual(length, options));
    }
    byteLengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthNotEqual(length, options));
    }
    byteLengthRange(start, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthRange(start, endBefore, options));
    }
    byteLengthRangeInclusive(startAt, endAt, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt, options));
    }
    byteLengthRangeExclusive(startAfter, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore, options));
    }
    lengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthLessThan(length, options));
    }
    lengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthLessThanOrEqual(length, options));
    }
    lengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthGreaterThan(length, options));
    }
    lengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthGreaterThanOrEqual(length, options));
    }
    lengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthEqual(length, options));
    }
    lengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthNotEqual(length, options));
    }
    lengthRange(start, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthRange(start, endBefore, options));
    }
    lengthRangeInclusive(startAt, endAt, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt, options));
    }
    lengthRangeExclusive(startAfter, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore, options));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.type, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      return TypedArrays[this.type](value) ? Result.ok(value) : Result.err(new ValidationError("s.typedArray()", this.validatorOptions.message ?? `Expected ${aOrAn(this.type)}`, value));
    }
  };
  __name(_TypedArrayValidator, "TypedArrayValidator");
  var TypedArrayValidator = _TypedArrayValidator;
  var _Shapes = class _Shapes2 {
    string(options) {
      return new StringValidator(options);
    }
    number(options) {
      return new NumberValidator(options);
    }
    bigint(options) {
      return new BigIntValidator(options);
    }
    boolean(options) {
      return new BooleanValidator(options);
    }
    date(options) {
      return new DateValidator(options);
    }
    object(shape, options) {
      return new ObjectValidator(shape, 0, options);
    }
    undefined(options) {
      return this.literal(undefined, { equalsOptions: options });
    }
    null(options) {
      return this.literal(null, { equalsOptions: options });
    }
    nullish(options) {
      return new NullishValidator(options);
    }
    any(options) {
      return new PassthroughValidator(options);
    }
    unknown(options) {
      return new PassthroughValidator(options);
    }
    never(options) {
      return new NeverValidator(options);
    }
    enum(values, options) {
      return this.union(values.map((value) => this.literal(value, { equalsOptions: options })), options);
    }
    nativeEnum(enumShape, options) {
      return new NativeEnumValidator(enumShape, options);
    }
    literal(value, options) {
      if (value instanceof Date) {
        return this.date(options?.dateOptions).equal(value, options?.equalsOptions);
      }
      return new LiteralValidator(value, options?.equalsOptions);
    }
    instance(expected, options) {
      return new InstanceValidator(expected, options);
    }
    union(validators, options) {
      return new UnionValidator(validators, options);
    }
    array(validator, options) {
      return new ArrayValidator(validator, options);
    }
    typedArray(type = "TypedArray", options) {
      return new TypedArrayValidator(type, options);
    }
    int8Array(options) {
      return this.typedArray("Int8Array", options);
    }
    uint8Array(options) {
      return this.typedArray("Uint8Array", options);
    }
    uint8ClampedArray(options) {
      return this.typedArray("Uint8ClampedArray", options);
    }
    int16Array(options) {
      return this.typedArray("Int16Array", options);
    }
    uint16Array(options) {
      return this.typedArray("Uint16Array", options);
    }
    int32Array(options) {
      return this.typedArray("Int32Array", options);
    }
    uint32Array(options) {
      return this.typedArray("Uint32Array", options);
    }
    float32Array(options) {
      return this.typedArray("Float32Array", options);
    }
    float64Array(options) {
      return this.typedArray("Float64Array", options);
    }
    bigInt64Array(options) {
      return this.typedArray("BigInt64Array", options);
    }
    bigUint64Array(options) {
      return this.typedArray("BigUint64Array", options);
    }
    tuple(validators, options) {
      return new TupleValidator(validators, options);
    }
    set(validator, options) {
      return new SetValidator(validator, options);
    }
    record(validator, options) {
      return new RecordValidator(validator, options);
    }
    map(keyValidator, valueValidator, options) {
      return new MapValidator(keyValidator, valueValidator, options);
    }
    lazy(validator, options) {
      return new LazyValidator(validator, options);
    }
  };
  __name(_Shapes, "Shapes");
  var Shapes = _Shapes;
  var s3 = new Shapes;
  exports.BaseError = BaseError;
  exports.CombinedError = CombinedError;
  exports.CombinedPropertyError = CombinedPropertyError;
  exports.ExpectedConstraintError = ExpectedConstraintError;
  exports.ExpectedValidationError = ExpectedValidationError;
  exports.MissingPropertyError = MissingPropertyError;
  exports.MultiplePossibilitiesConstraintError = MultiplePossibilitiesConstraintError;
  exports.Result = Result;
  exports.UnknownEnumValueError = UnknownEnumValueError;
  exports.UnknownPropertyError = UnknownPropertyError;
  exports.ValidationError = ValidationError;
  exports.customInspectSymbol = customInspectSymbol;
  exports.customInspectSymbolStackLess = customInspectSymbolStackLess;
  exports.getGlobalValidationEnabled = getGlobalValidationEnabled;
  exports.s = s3;
  exports.setGlobalValidationEnabled = setGlobalValidationEnabled;
});

// node_modules/ts-mixer/dist/cjs/util.js
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flatten = exports.unique = exports.hardMixProtos = exports.nearestCommonProto = exports.protoChain = exports.copyProps = undefined;
  var copyProps = (dest, src, exclude = []) => {
    const props = Object.getOwnPropertyDescriptors(src);
    for (let prop of exclude)
      delete props[prop];
    Object.defineProperties(dest, props);
  };
  exports.copyProps = copyProps;
  var protoChain = (obj, currentChain = [obj]) => {
    const proto = Object.getPrototypeOf(obj);
    if (proto === null)
      return currentChain;
    return (0, exports.protoChain)(proto, [...currentChain, proto]);
  };
  exports.protoChain = protoChain;
  var nearestCommonProto = (...objs) => {
    if (objs.length === 0)
      return;
    let commonProto = undefined;
    const protoChains = objs.map((obj) => (0, exports.protoChain)(obj));
    while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
      const protos = protoChains.map((protoChain2) => protoChain2.pop());
      const potentialCommonProto = protos[0];
      if (protos.every((proto) => proto === potentialCommonProto))
        commonProto = potentialCommonProto;
      else
        break;
    }
    return commonProto;
  };
  exports.nearestCommonProto = nearestCommonProto;
  var hardMixProtos = (ingredients, constructor, exclude = []) => {
    var _a;
    const base = (_a = (0, exports.nearestCommonProto)(...ingredients)) !== null && _a !== undefined ? _a : Object.prototype;
    const mixedProto = Object.create(base);
    const visitedProtos = (0, exports.protoChain)(base);
    for (let prototype of ingredients) {
      let protos = (0, exports.protoChain)(prototype);
      for (let i = protos.length - 1;i >= 0; i--) {
        let newProto = protos[i];
        if (visitedProtos.indexOf(newProto) === -1) {
          (0, exports.copyProps)(mixedProto, newProto, ["constructor", ...exclude]);
          visitedProtos.push(newProto);
        }
      }
    }
    mixedProto.constructor = constructor;
    return mixedProto;
  };
  exports.hardMixProtos = hardMixProtos;
  var unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
  exports.unique = unique;
  var flatten = (arr) => arr.length === 0 ? [] : arr.length === 1 ? arr[0] : arr.reduce((a1, a2) => [...a1, ...a2]);
  exports.flatten = flatten;
});

// node_modules/ts-mixer/dist/cjs/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.softMixProtos = exports.proxyMix = exports.getIngredientWithProp = undefined;
  var util_1 = require_util();
  var getIngredientWithProp = (prop, ingredients) => {
    const protoChains = ingredients.map((ingredient) => (0, util_1.protoChain)(ingredient));
    let protoDepth = 0;
    let protosAreLeftToSearch = true;
    while (protosAreLeftToSearch) {
      protosAreLeftToSearch = false;
      for (let i = ingredients.length - 1;i >= 0; i--) {
        const searchTarget = protoChains[i][protoDepth];
        if (searchTarget !== undefined && searchTarget !== null) {
          protosAreLeftToSearch = true;
          if (Object.getOwnPropertyDescriptor(searchTarget, prop) != null) {
            return protoChains[i][0];
          }
        }
      }
      protoDepth++;
    }
    return;
  };
  exports.getIngredientWithProp = getIngredientWithProp;
  var proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
    getPrototypeOf() {
      return prototype;
    },
    setPrototypeOf() {
      throw Error("Cannot set prototype of Proxies created by ts-mixer");
    },
    getOwnPropertyDescriptor(_, prop) {
      return Object.getOwnPropertyDescriptor((0, exports.getIngredientWithProp)(prop, ingredients) || {}, prop);
    },
    defineProperty() {
      throw new Error("Cannot define new properties on Proxies created by ts-mixer");
    },
    has(_, prop) {
      return (0, exports.getIngredientWithProp)(prop, ingredients) !== undefined || prototype[prop] !== undefined;
    },
    get(_, prop) {
      return ((0, exports.getIngredientWithProp)(prop, ingredients) || prototype)[prop];
    },
    set(_, prop, val) {
      const ingredientWithProp = (0, exports.getIngredientWithProp)(prop, ingredients);
      if (ingredientWithProp === undefined)
        throw new Error("Cannot set new properties on Proxies created by ts-mixer");
      ingredientWithProp[prop] = val;
      return true;
    },
    deleteProperty() {
      throw new Error("Cannot delete properties on Proxies created by ts-mixer");
    },
    ownKeys() {
      return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
    }
  });
  exports.proxyMix = proxyMix;
  var softMixProtos = (ingredients, constructor) => (0, exports.proxyMix)([...ingredients, { constructor }]);
  exports.softMixProtos = softMixProtos;
});

// node_modules/ts-mixer/dist/cjs/settings.js
var require_settings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.settings = undefined;
  exports.settings = {
    initFunction: null,
    staticsStrategy: "copy",
    prototypeStrategy: "copy",
    decoratorInheritance: "deep"
  };
});

// node_modules/ts-mixer/dist/cjs/mixin-tracking.js
var require_mixin_tracking = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMixin = exports.registerMixins = exports.getMixinsForClass = undefined;
  var util_1 = require_util();
  var mixins = new WeakMap;
  var getMixinsForClass = (clazz) => mixins.get(clazz);
  exports.getMixinsForClass = getMixinsForClass;
  var registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
  exports.registerMixins = registerMixins;
  var hasMixin = (instance, mixin) => {
    if (instance instanceof mixin)
      return true;
    const constructor = instance.constructor;
    const visited = new Set;
    let frontier = new Set;
    frontier.add(constructor);
    while (frontier.size > 0) {
      if (frontier.has(mixin))
        return true;
      frontier.forEach((item) => visited.add(item));
      const newFrontier = new Set;
      frontier.forEach((item) => {
        var _a;
        const itemConstituents = (_a = mixins.get(item)) !== null && _a !== undefined ? _a : (0, util_1.protoChain)(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
        if (itemConstituents)
          itemConstituents.forEach((constituent) => {
            if (!visited.has(constituent) && !frontier.has(constituent))
              newFrontier.add(constituent);
          });
      });
      frontier = newFrontier;
    }
    return false;
  };
  exports.hasMixin = hasMixin;
});

// node_modules/ts-mixer/dist/cjs/decorator.js
var require_decorator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decorate = exports.getDecoratorsForClass = exports.directDecoratorSearch = exports.deepDecoratorSearch = undefined;
  var util_1 = require_util();
  var mixin_tracking_1 = require_mixin_tracking();
  var mergeObjectsOfDecorators = (o1, o2) => {
    var _a, _b;
    const allKeys = (0, util_1.unique)([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
    const mergedObject = {};
    for (let key of allKeys)
      mergedObject[key] = (0, util_1.unique)([...(_a = o1 === null || o1 === undefined ? undefined : o1[key]) !== null && _a !== undefined ? _a : [], ...(_b = o2 === null || o2 === undefined ? undefined : o2[key]) !== null && _b !== undefined ? _b : []]);
    return mergedObject;
  };
  var mergePropertyAndMethodDecorators = (d1, d2) => {
    var _a, _b, _c, _d;
    return {
      property: mergeObjectsOfDecorators((_a = d1 === null || d1 === undefined ? undefined : d1.property) !== null && _a !== undefined ? _a : {}, (_b = d2 === null || d2 === undefined ? undefined : d2.property) !== null && _b !== undefined ? _b : {}),
      method: mergeObjectsOfDecorators((_c = d1 === null || d1 === undefined ? undefined : d1.method) !== null && _c !== undefined ? _c : {}, (_d = d2 === null || d2 === undefined ? undefined : d2.method) !== null && _d !== undefined ? _d : {})
    };
  };
  var mergeDecorators = (d1, d2) => {
    var _a, _b, _c, _d, _e, _f;
    return {
      class: (0, util_1.unique)([...(_a = d1 === null || d1 === undefined ? undefined : d1.class) !== null && _a !== undefined ? _a : [], ...(_b = d2 === null || d2 === undefined ? undefined : d2.class) !== null && _b !== undefined ? _b : []]),
      static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === undefined ? undefined : d1.static) !== null && _c !== undefined ? _c : {}, (_d = d2 === null || d2 === undefined ? undefined : d2.static) !== null && _d !== undefined ? _d : {}),
      instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === undefined ? undefined : d1.instance) !== null && _e !== undefined ? _e : {}, (_f = d2 === null || d2 === undefined ? undefined : d2.instance) !== null && _f !== undefined ? _f : {})
    };
  };
  var decorators = new Map;
  var findAllConstituentClasses = (...classes) => {
    var _a;
    const allClasses = new Set;
    const frontier = new Set([...classes]);
    while (frontier.size > 0) {
      for (let clazz of frontier) {
        const protoChainClasses = (0, util_1.protoChain)(clazz.prototype).map((proto) => proto.constructor);
        const mixinClasses = (_a = (0, mixin_tracking_1.getMixinsForClass)(clazz)) !== null && _a !== undefined ? _a : [];
        const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
        const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
        for (let newClass of newClasses)
          frontier.add(newClass);
        allClasses.add(clazz);
        frontier.delete(clazz);
      }
    }
    return [...allClasses];
  };
  var deepDecoratorSearch = (...classes) => {
    const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
    if (decoratorsForClassChain.length == 0)
      return {};
    if (decoratorsForClassChain.length == 1)
      return decoratorsForClassChain[0];
    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
  };
  exports.deepDecoratorSearch = deepDecoratorSearch;
  var directDecoratorSearch = (...classes) => {
    const classDecorators = classes.map((clazz) => (0, exports.getDecoratorsForClass)(clazz));
    if (classDecorators.length === 0)
      return {};
    if (classDecorators.length === 1)
      return classDecorators[0];
    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
  };
  exports.directDecoratorSearch = directDecoratorSearch;
  var getDecoratorsForClass = (clazz) => {
    let decoratorsForClass = decorators.get(clazz);
    if (!decoratorsForClass) {
      decoratorsForClass = {};
      decorators.set(clazz, decoratorsForClass);
    }
    return decoratorsForClass;
  };
  exports.getDecoratorsForClass = getDecoratorsForClass;
  var decorateClass = (decorator) => (clazz) => {
    const decoratorsForClass = (0, exports.getDecoratorsForClass)(clazz);
    let classDecorators = decoratorsForClass.class;
    if (!classDecorators) {
      classDecorators = [];
      decoratorsForClass.class = classDecorators;
    }
    classDecorators.push(decorator);
    return decorator(clazz);
  };
  var decorateMember = (decorator) => (object, key, ...otherArgs) => {
    var _a, _b, _c;
    const decoratorTargetType = typeof object === "function" ? "static" : "instance";
    const decoratorType = typeof object[key] === "function" ? "method" : "property";
    const clazz = decoratorTargetType === "static" ? object : object.constructor;
    const decoratorsForClass = (0, exports.getDecoratorsForClass)(clazz);
    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === undefined ? undefined : decoratorsForClass[decoratorTargetType]) !== null && _a !== undefined ? _a : {};
    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === undefined ? undefined : decoratorsForTargetType[decoratorType]) !== null && _b !== undefined ? _b : {};
    decoratorsForTargetType[decoratorType] = decoratorsForType;
    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === undefined ? undefined : decoratorsForType[key]) !== null && _c !== undefined ? _c : [];
    decoratorsForType[key] = decoratorsForKey;
    decoratorsForKey.push(decorator);
    return decorator(object, key, ...otherArgs);
  };
  var decorate = (decorator) => (...args) => {
    if (args.length === 1)
      return decorateClass(decorator)(args[0]);
    return decorateMember(decorator)(...args);
  };
  exports.decorate = decorate;
});

// node_modules/ts-mixer/dist/cjs/mixins.js
var require_mixins = __commonJS((exports) => {
  var Mixin = function(...constructors) {
    var _a, _b, _c;
    const prototypes = constructors.map((constructor) => constructor.prototype);
    const initFunctionName = settings_1.settings.initFunction;
    if (initFunctionName !== null) {
      const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
      const combinedInitFunction = function(...args) {
        for (let initFunction of initFunctions)
          initFunction.apply(this, args);
      };
      const extraProto = { [initFunctionName]: combinedInitFunction };
      prototypes.push(extraProto);
    }
    function MixedClass(...args) {
      for (const constructor of constructors)
        (0, util_1.copyProps)(this, new constructor(...args));
      if (initFunctionName !== null && typeof this[initFunctionName] === "function")
        this[initFunctionName].apply(this, args);
    }
    MixedClass.prototype = settings_1.settings.prototypeStrategy === "copy" ? (0, util_1.hardMixProtos)(prototypes, MixedClass) : (0, proxy_1.softMixProtos)(prototypes, MixedClass);
    Object.setPrototypeOf(MixedClass, settings_1.settings.staticsStrategy === "copy" ? (0, util_1.hardMixProtos)(constructors, null, ["prototype"]) : (0, proxy_1.proxyMix)(constructors, Function.prototype));
    let DecoratedMixedClass = MixedClass;
    if (settings_1.settings.decoratorInheritance !== "none") {
      const classDecorators = settings_1.settings.decoratorInheritance === "deep" ? (0, decorator_1.deepDecoratorSearch)(...constructors) : (0, decorator_1.directDecoratorSearch)(...constructors);
      for (let decorator of (_a = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.class) !== null && _a !== undefined ? _a : []) {
        const result = decorator(DecoratedMixedClass);
        if (result) {
          DecoratedMixedClass = result;
        }
      }
      applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.static) !== null && _b !== undefined ? _b : {}, DecoratedMixedClass);
      applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.instance) !== null && _c !== undefined ? _c : {}, DecoratedMixedClass.prototype);
    }
    (0, mixin_tracking_1.registerMixins)(DecoratedMixedClass, constructors);
    return DecoratedMixedClass;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mix = exports.Mixin = undefined;
  var proxy_1 = require_proxy();
  var settings_1 = require_settings();
  var util_1 = require_util();
  var decorator_1 = require_decorator();
  var mixin_tracking_1 = require_mixin_tracking();
  exports.Mixin = Mixin;
  var applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
    const propDecorators = propAndMethodDecorators.property;
    const methodDecorators = propAndMethodDecorators.method;
    if (propDecorators)
      for (let key in propDecorators)
        for (let decorator of propDecorators[key])
          decorator(target, key);
    if (methodDecorators)
      for (let key in methodDecorators)
        for (let decorator of methodDecorators[key])
          decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
  };
  var mix = (...ingredients) => (decoratedClass) => {
    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
    Object.defineProperty(mixedClass, "name", {
      value: decoratedClass.name,
      writable: false
    });
    return mixedClass;
  };
  exports.mix = mix;
});

// node_modules/ts-mixer/dist/cjs/index.js
var require_cjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMixin = exports.decorate = exports.settings = exports.mix = exports.Mixin = undefined;
  var mixins_1 = require_mixins();
  Object.defineProperty(exports, "Mixin", { enumerable: true, get: function() {
    return mixins_1.Mixin;
  } });
  Object.defineProperty(exports, "mix", { enumerable: true, get: function() {
    return mixins_1.mix;
  } });
  var settings_1 = require_settings();
  Object.defineProperty(exports, "settings", { enumerable: true, get: function() {
    return settings_1.settings;
  } });
  var decorator_1 = require_decorator();
  Object.defineProperty(exports, "decorate", { enumerable: true, get: function() {
    return decorator_1.decorate;
  } });
  var mixin_tracking_1 = require_mixin_tracking();
  Object.defineProperty(exports, "hasMixin", { enumerable: true, get: function() {
    return mixin_tracking_1.hasMixin;
  } });
});

// node_modules/@discordjs/builders/dist/index.js
var require_dist8 = __commonJS((exports, module) => {
  var enableValidators = function() {
    return validate = true;
  };
  var disableValidators = function() {
    return validate = false;
  };
  var isValidationEnabled = function() {
    return validate;
  };
  var validateFieldLength = function(amountAdding, fields) {
    fieldLengthPredicate.parse((fields?.length ?? 0) + amountAdding);
  };
  var normalizeArray = function(arr) {
    if (Array.isArray(arr[0]))
      return [...arr[0]];
    return arr;
  };
  var validateRequiredSelectMenuParameters = function(options, customId) {
    customIdValidator.parse(customId);
    optionsValidator.parse(options);
  };
  var validateRequiredSelectMenuOptionParameters = function(label, value) {
    labelValueDescriptionValidator.parse(label);
    labelValueDescriptionValidator.parse(value);
  };
  var validateRequiredButtonParameters = function(style, label, emoji, customId, skuId, url) {
    if (style === import_v10.ButtonStyle.Premium) {
      if (!skuId) {
        throw new RangeError("Premium buttons must have an SKU id.");
      }
      if (customId || label || url || emoji) {
        throw new RangeError("Premium buttons cannot have a custom id, label, URL, or emoji.");
      }
    } else {
      if (skuId) {
        throw new RangeError("Non-premium buttons must not have an SKU id.");
      }
      if (url && customId) {
        throw new RangeError("URL and custom id are mutually exclusive.");
      }
      if (!label && !emoji) {
        throw new RangeError("Non-premium buttons must have a label and/or an emoji.");
      }
      if (style === import_v10.ButtonStyle.Link) {
        if (!url) {
          throw new RangeError("Link buttons must have a URL.");
        }
      } else if (url) {
        throw new RangeError("Non-premium and non-link buttons cannot have a URL.");
      }
    }
  };
  var validateRequiredParameters = function(customId, style, label) {
    customIdValidator.parse(customId);
    textInputStyleValidator.parse(style);
    labelValidator.parse(label);
  };
  var assertReturnOfBuilder = function(input, ExpectedInstanceOf) {
    import_shapeshift4.s.instance(ExpectedInstanceOf).setValidationEnabled(isValidationEnabled).parse(input);
  };
  var validateComponentArray = function(input, min, max, ExpectedInstanceOf) {
    (ExpectedInstanceOf ? import_shapeshift4.s.instance(ExpectedInstanceOf) : import_shapeshift4.s.instance(ComponentBuilder)).array().lengthGreaterThanOrEqual(min).lengthLessThanOrEqual(max).setValidationEnabled(isValidationEnabled).parse(input);
  };
  var createComponentBuilder = function(data) {
    if (data instanceof ComponentBuilder) {
      return data;
    }
    switch (data.type) {
      case import_v1018.ComponentType.ActionRow:
        return new ActionRowBuilder(data);
      case import_v1018.ComponentType.Button:
        return new ButtonBuilder(data);
      case import_v1018.ComponentType.StringSelect:
        return new StringSelectMenuBuilder(data);
      case import_v1018.ComponentType.TextInput:
        return new TextInputBuilder(data);
      case import_v1018.ComponentType.UserSelect:
        return new UserSelectMenuBuilder(data);
      case import_v1018.ComponentType.RoleSelect:
        return new RoleSelectMenuBuilder(data);
      case import_v1018.ComponentType.MentionableSelect:
        return new MentionableSelectMenuBuilder(data);
      case import_v1018.ComponentType.ChannelSelect:
        return new ChannelSelectMenuBuilder(data);
      case import_v1018.ComponentType.File:
        return new FileBuilder(data);
      case import_v1018.ComponentType.Container:
        return new ContainerBuilder(data);
      case import_v1018.ComponentType.Section:
        return new SectionBuilder(data);
      case import_v1018.ComponentType.Separator:
        return new SeparatorBuilder(data);
      case import_v1018.ComponentType.TextDisplay:
        return new TextDisplayBuilder(data);
      case import_v1018.ComponentType.Thumbnail:
        return new ThumbnailBuilder(data);
      case import_v1018.ComponentType.MediaGallery:
        return new MediaGalleryBuilder(data);
      default:
        throw new Error(`Cannot properly serialize component type: ${data.type}`);
    }
  };
  var isBuilder = function(builder, Constructor) {
    return builder instanceof Constructor;
  };
  var resolveBuilder = function(builder, Constructor) {
    if (isBuilder(builder, Constructor)) {
      return builder;
    }
    if (typeof builder === "function") {
      return builder(new Constructor);
    }
    return new Constructor(builder);
  };
  var validateRequiredParameters2 = function(customId, title, components) {
    customIdValidator.parse(customId);
    titleValidator.parse(title);
    componentsValidator.parse(components);
  };
  var validateName = function(name) {
    namePredicate.parse(name);
  };
  var validateDescription = function(description) {
    descriptionPredicate3.parse(description);
  };
  var validateLocale = function(locale) {
    return localePredicate.parse(locale);
  };
  var validateMaxOptionsLength = function(options) {
    maxArrayLengthPredicate.parse(options);
  };
  var validateRequiredParameters3 = function(name, description, options) {
    validateName(name);
    validateDescription(description);
    validateMaxOptionsLength(options);
  };
  var validateDefaultPermission = function(value) {
    booleanPredicate.parse(value);
  };
  var validateRequired = function(required) {
    booleanPredicate.parse(required);
  };
  var validateChoicesLength = function(amountAdding, choices) {
    choicesLengthPredicate.parse((choices?.length ?? 0) + amountAdding);
  };
  var assertReturnOfBuilder2 = function(input, ExpectedInstanceOf) {
    import_shapeshift6.s.instance(ExpectedInstanceOf).parse(input);
  };
  var validateLocalizationMap = function(value) {
    localizationMapPredicate.parse(value);
  };
  var validateDMPermission = function(value) {
    dmPermissionPredicate.parse(value);
  };
  var validateDefaultMemberPermissions = function(permissions) {
    return memberPermissionPredicate.parse(permissions);
  };
  var validateNSFW = function(value) {
    booleanPredicate.parse(value);
  };
  var validateDefaultPermission2 = function(value) {
    booleanPredicate3.parse(value);
  };
  var validateName2 = function(name) {
    namePredicate2.parse(name);
  };
  var validateType = function(type) {
    typePredicate.parse(type);
  };
  var validateRequiredParameters4 = function(name, type) {
    validateName2(name);
    validateType(type);
  };
  var validateDMPermission2 = function(value) {
    dmPermissionPredicate2.parse(value);
  };
  var validateDefaultMemberPermissions2 = function(permissions) {
    return memberPermissionPredicate2.parse(permissions);
  };
  var embedLength = function(data) {
    return (data.title?.length ?? 0) + (data.description?.length ?? 0) + (data.fields?.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0) ?? 0) + (data.footer?.text.length ?? 0) + (data.author?.name.length ?? 0);
  };
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? undefined : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator;i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp2(target, key, result);
    return result;
  };
  var src_exports = {};
  __export(src_exports, {
    ActionRowBuilder: () => ActionRowBuilder,
    ApplicationCommandNumericOptionMinMaxValueMixin: () => ApplicationCommandNumericOptionMinMaxValueMixin,
    ApplicationCommandOptionBase: () => ApplicationCommandOptionBase,
    ApplicationCommandOptionChannelTypesMixin: () => ApplicationCommandOptionChannelTypesMixin,
    ApplicationCommandOptionWithAutocompleteMixin: () => ApplicationCommandOptionWithAutocompleteMixin,
    ApplicationCommandOptionWithChoicesMixin: () => ApplicationCommandOptionWithChoicesMixin,
    BaseSelectMenuBuilder: () => BaseSelectMenuBuilder,
    ButtonBuilder: () => ButtonBuilder,
    ChannelSelectMenuBuilder: () => ChannelSelectMenuBuilder,
    ComponentAssertions: () => Assertions_exports2,
    ComponentBuilder: () => ComponentBuilder,
    ComponentsV2Assertions: () => Assertions_exports4,
    ContainerBuilder: () => ContainerBuilder,
    ContextMenuCommandAssertions: () => Assertions_exports7,
    ContextMenuCommandBuilder: () => ContextMenuCommandBuilder,
    EmbedAssertions: () => Assertions_exports,
    EmbedBuilder: () => EmbedBuilder,
    FileBuilder: () => FileBuilder,
    MediaGalleryBuilder: () => MediaGalleryBuilder,
    MediaGalleryItemBuilder: () => MediaGalleryItemBuilder,
    MentionableSelectMenuBuilder: () => MentionableSelectMenuBuilder,
    ModalAssertions: () => Assertions_exports5,
    ModalBuilder: () => ModalBuilder,
    RoleSelectMenuBuilder: () => RoleSelectMenuBuilder,
    SectionBuilder: () => SectionBuilder,
    SelectMenuBuilder: () => StringSelectMenuBuilder,
    SelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
    SeparatorBuilder: () => SeparatorBuilder,
    SharedNameAndDescription: () => SharedNameAndDescription,
    SharedSlashCommand: () => SharedSlashCommand,
    SharedSlashCommandOptions: () => SharedSlashCommandOptions,
    SharedSlashCommandSubcommands: () => SharedSlashCommandSubcommands,
    SlashCommandAssertions: () => Assertions_exports6,
    SlashCommandAttachmentOption: () => SlashCommandAttachmentOption,
    SlashCommandBooleanOption: () => SlashCommandBooleanOption,
    SlashCommandBuilder: () => SlashCommandBuilder,
    SlashCommandChannelOption: () => SlashCommandChannelOption,
    SlashCommandIntegerOption: () => SlashCommandIntegerOption,
    SlashCommandMentionableOption: () => SlashCommandMentionableOption,
    SlashCommandNumberOption: () => SlashCommandNumberOption,
    SlashCommandRoleOption: () => SlashCommandRoleOption,
    SlashCommandStringOption: () => SlashCommandStringOption,
    SlashCommandSubcommandBuilder: () => SlashCommandSubcommandBuilder,
    SlashCommandSubcommandGroupBuilder: () => SlashCommandSubcommandGroupBuilder,
    SlashCommandUserOption: () => SlashCommandUserOption,
    StringSelectMenuBuilder: () => StringSelectMenuBuilder,
    StringSelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
    TextDisplayBuilder: () => TextDisplayBuilder,
    TextInputAssertions: () => Assertions_exports3,
    TextInputBuilder: () => TextInputBuilder,
    ThumbnailBuilder: () => ThumbnailBuilder,
    UserSelectMenuBuilder: () => UserSelectMenuBuilder,
    createComponentBuilder: () => createComponentBuilder,
    disableValidators: () => disableValidators,
    embedLength: () => embedLength,
    enableValidators: () => enableValidators,
    isValidationEnabled: () => isValidationEnabled,
    normalizeArray: () => normalizeArray,
    resolveBuilder: () => resolveBuilder,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Assertions_exports = {};
  __export(Assertions_exports, {
    RGBPredicate: () => RGBPredicate,
    authorNamePredicate: () => authorNamePredicate,
    colorPredicate: () => colorPredicate,
    descriptionPredicate: () => descriptionPredicate,
    embedAuthorPredicate: () => embedAuthorPredicate,
    embedFieldPredicate: () => embedFieldPredicate,
    embedFieldsArrayPredicate: () => embedFieldsArrayPredicate,
    embedFooterPredicate: () => embedFooterPredicate,
    fieldInlinePredicate: () => fieldInlinePredicate,
    fieldLengthPredicate: () => fieldLengthPredicate,
    fieldNamePredicate: () => fieldNamePredicate,
    fieldValuePredicate: () => fieldValuePredicate,
    footerTextPredicate: () => footerTextPredicate,
    imageURLPredicate: () => imageURLPredicate,
    timestampPredicate: () => timestampPredicate,
    titlePredicate: () => titlePredicate,
    urlPredicate: () => urlPredicate,
    validateFieldLength: () => validateFieldLength
  });
  var import_shapeshift = require_cjs3();
  var validate = true;
  __name(enableValidators, "enableValidators");
  __name(disableValidators, "disableValidators");
  __name(isValidationEnabled, "isValidationEnabled");
  var fieldNamePredicate = import_shapeshift.s.string().lengthLessThanOrEqual(256).setValidationEnabled(isValidationEnabled);
  var fieldValuePredicate = import_shapeshift.s.string().lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
  var fieldInlinePredicate = import_shapeshift.s.boolean().optional();
  var embedFieldPredicate = import_shapeshift.s.object({
    name: fieldNamePredicate,
    value: fieldValuePredicate,
    inline: fieldInlinePredicate
  }).setValidationEnabled(isValidationEnabled);
  var embedFieldsArrayPredicate = embedFieldPredicate.array().setValidationEnabled(isValidationEnabled);
  var fieldLengthPredicate = import_shapeshift.s.number().lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateFieldLength, "validateFieldLength");
  var authorNamePredicate = fieldNamePredicate.lengthGreaterThanOrEqual(1).nullable().setValidationEnabled(isValidationEnabled);
  var imageURLPredicate = import_shapeshift.s.string().url({
    allowedProtocols: ["http:", "https:", "attachment:"]
  }).nullish().setValidationEnabled(isValidationEnabled);
  var urlPredicate = import_shapeshift.s.string().url({
    allowedProtocols: ["http:", "https:"]
  }).nullish().setValidationEnabled(isValidationEnabled);
  var embedAuthorPredicate = import_shapeshift.s.object({
    name: authorNamePredicate,
    iconURL: imageURLPredicate,
    url: urlPredicate
  }).setValidationEnabled(isValidationEnabled);
  var RGBPredicate = import_shapeshift.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(255).setValidationEnabled(isValidationEnabled);
  var colorPredicate = import_shapeshift.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(16777215).or(import_shapeshift.s.tuple([RGBPredicate, RGBPredicate, RGBPredicate])).nullable().setValidationEnabled(isValidationEnabled);
  var descriptionPredicate = import_shapeshift.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4096).nullable().setValidationEnabled(isValidationEnabled);
  var footerTextPredicate = import_shapeshift.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(2048).nullable().setValidationEnabled(isValidationEnabled);
  var embedFooterPredicate = import_shapeshift.s.object({
    text: footerTextPredicate,
    iconURL: imageURLPredicate
  }).setValidationEnabled(isValidationEnabled);
  var timestampPredicate = import_shapeshift.s.union([import_shapeshift.s.number(), import_shapeshift.s.date()]).nullable().setValidationEnabled(isValidationEnabled);
  var titlePredicate = fieldNamePredicate.lengthGreaterThanOrEqual(1).nullable().setValidationEnabled(isValidationEnabled);
  __name(normalizeArray, "normalizeArray");
  var EmbedBuilder = class {
    static {
      __name(this, "EmbedBuilder");
    }
    data;
    constructor(data = {}) {
      this.data = { ...data };
      if (data.timestamp)
        this.data.timestamp = new Date(data.timestamp).toISOString();
    }
    addFields(...fields) {
      const normalizedFields = normalizeArray(fields);
      validateFieldLength(normalizedFields.length, this.data.fields);
      embedFieldsArrayPredicate.parse(normalizedFields);
      if (this.data.fields)
        this.data.fields.push(...normalizedFields);
      else
        this.data.fields = normalizedFields;
      return this;
    }
    spliceFields(index, deleteCount, ...fields) {
      validateFieldLength(fields.length - deleteCount, this.data.fields);
      embedFieldsArrayPredicate.parse(fields);
      if (this.data.fields)
        this.data.fields.splice(index, deleteCount, ...fields);
      else
        this.data.fields = fields;
      return this;
    }
    setFields(...fields) {
      this.spliceFields(0, this.data.fields?.length ?? 0, ...normalizeArray(fields));
      return this;
    }
    setAuthor(options) {
      if (options === null) {
        this.data.author = undefined;
        return this;
      }
      embedAuthorPredicate.parse(options);
      this.data.author = { name: options.name, url: options.url, icon_url: options.iconURL };
      return this;
    }
    setColor(color) {
      colorPredicate.parse(color);
      if (Array.isArray(color)) {
        const [red, green, blue] = color;
        this.data.color = (red << 16) + (green << 8) + blue;
        return this;
      }
      this.data.color = color ?? undefined;
      return this;
    }
    setDescription(description) {
      descriptionPredicate.parse(description);
      this.data.description = description ?? undefined;
      return this;
    }
    setFooter(options) {
      if (options === null) {
        this.data.footer = undefined;
        return this;
      }
      embedFooterPredicate.parse(options);
      this.data.footer = { text: options.text, icon_url: options.iconURL };
      return this;
    }
    setImage(url) {
      imageURLPredicate.parse(url);
      this.data.image = url ? { url } : undefined;
      return this;
    }
    setThumbnail(url) {
      imageURLPredicate.parse(url);
      this.data.thumbnail = url ? { url } : undefined;
      return this;
    }
    setTimestamp(timestamp = Date.now()) {
      timestampPredicate.parse(timestamp);
      this.data.timestamp = timestamp ? new Date(timestamp).toISOString() : undefined;
      return this;
    }
    setTitle(title) {
      titlePredicate.parse(title);
      this.data.title = title ?? undefined;
      return this;
    }
    setURL(url) {
      urlPredicate.parse(url);
      this.data.url = url ?? undefined;
      return this;
    }
    toJSON() {
      return { ...this.data };
    }
  };
  __reExport(src_exports, require_dist7(), module.exports);
  var Assertions_exports2 = {};
  __export(Assertions_exports2, {
    buttonLabelValidator: () => buttonLabelValidator,
    buttonStyleValidator: () => buttonStyleValidator,
    channelTypesValidator: () => channelTypesValidator,
    customIdValidator: () => customIdValidator,
    defaultValidator: () => defaultValidator,
    disabledValidator: () => disabledValidator,
    emojiValidator: () => emojiValidator,
    idValidator: () => idValidator,
    jsonOptionValidator: () => jsonOptionValidator,
    labelValueDescriptionValidator: () => labelValueDescriptionValidator,
    minMaxValidator: () => minMaxValidator,
    optionValidator: () => optionValidator,
    optionsLengthValidator: () => optionsLengthValidator,
    optionsValidator: () => optionsValidator,
    placeholderValidator: () => placeholderValidator,
    urlValidator: () => urlValidator,
    validateRequiredButtonParameters: () => validateRequiredButtonParameters,
    validateRequiredSelectMenuOptionParameters: () => validateRequiredSelectMenuOptionParameters,
    validateRequiredSelectMenuParameters: () => validateRequiredSelectMenuParameters
  });
  var import_shapeshift2 = require_cjs3();
  var import_v10 = require_v106();
  var StringSelectMenuOptionBuilder = class {
    constructor(data = {}) {
      this.data = data;
    }
    static {
      __name(this, "StringSelectMenuOptionBuilder");
    }
    setLabel(label) {
      this.data.label = labelValueDescriptionValidator.parse(label);
      return this;
    }
    setValue(value) {
      this.data.value = labelValueDescriptionValidator.parse(value);
      return this;
    }
    setDescription(description) {
      this.data.description = labelValueDescriptionValidator.parse(description);
      return this;
    }
    setDefault(isDefault = true) {
      this.data.default = defaultValidator.parse(isDefault);
      return this;
    }
    setEmoji(emoji) {
      this.data.emoji = emojiValidator.parse(emoji);
      return this;
    }
    toJSON() {
      validateRequiredSelectMenuOptionParameters(this.data.label, this.data.value);
      return {
        ...this.data
      };
    }
  };
  var idValidator = import_shapeshift2.s.number().safeInt().greaterThanOrEqual(1).lessThan(4294967296).setValidationEnabled(isValidationEnabled);
  var customIdValidator = import_shapeshift2.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var emojiValidator = import_shapeshift2.s.object({
    id: import_shapeshift2.s.string(),
    name: import_shapeshift2.s.string(),
    animated: import_shapeshift2.s.boolean()
  }).partial().strict().setValidationEnabled(isValidationEnabled);
  var disabledValidator = import_shapeshift2.s.boolean();
  var buttonLabelValidator = import_shapeshift2.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(80).setValidationEnabled(isValidationEnabled);
  var buttonStyleValidator = import_shapeshift2.s.nativeEnum(import_v10.ButtonStyle);
  var placeholderValidator = import_shapeshift2.s.string().lengthLessThanOrEqual(150).setValidationEnabled(isValidationEnabled);
  var minMaxValidator = import_shapeshift2.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  var labelValueDescriptionValidator = import_shapeshift2.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var jsonOptionValidator = import_shapeshift2.s.object({
    label: labelValueDescriptionValidator,
    value: labelValueDescriptionValidator,
    description: labelValueDescriptionValidator.optional(),
    emoji: emojiValidator.optional(),
    default: import_shapeshift2.s.boolean().optional()
  }).setValidationEnabled(isValidationEnabled);
  var optionValidator = import_shapeshift2.s.instance(StringSelectMenuOptionBuilder).setValidationEnabled(isValidationEnabled);
  var optionsValidator = optionValidator.array().lengthGreaterThanOrEqual(0).setValidationEnabled(isValidationEnabled);
  var optionsLengthValidator = import_shapeshift2.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredSelectMenuParameters, "validateRequiredSelectMenuParameters");
  var defaultValidator = import_shapeshift2.s.boolean();
  __name(validateRequiredSelectMenuOptionParameters, "validateRequiredSelectMenuOptionParameters");
  var channelTypesValidator = import_shapeshift2.s.nativeEnum(import_v10.ChannelType).array().setValidationEnabled(isValidationEnabled);
  var urlValidator = import_shapeshift2.s.string().url({
    allowedProtocols: ["http:", "https:", "discord:"]
  }).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredButtonParameters, "validateRequiredButtonParameters");
  var import_v1019 = require_v106();
  var ComponentBuilder = class {
    static {
      __name(this, "ComponentBuilder");
    }
    data;
    constructor(data) {
      this.data = data;
    }
    setId(id) {
      this.data.id = idValidator.parse(id);
      return this;
    }
    clearId() {
      this.data.id = undefined;
      return this;
    }
  };
  var import_v1018 = require_v106();
  var import_v102 = require_v106();
  var ButtonBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ButtonBuilder");
    }
    constructor(data) {
      super({ type: import_v102.ComponentType.Button, ...data });
    }
    setStyle(style) {
      this.data.style = buttonStyleValidator.parse(style);
      return this;
    }
    setURL(url) {
      this.data.url = urlValidator.parse(url);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setSKUId(skuId) {
      this.data.sku_id = skuId;
      return this;
    }
    setEmoji(emoji) {
      this.data.emoji = emojiValidator.parse(emoji);
      return this;
    }
    setDisabled(disabled = true) {
      this.data.disabled = disabledValidator.parse(disabled);
      return this;
    }
    setLabel(label) {
      this.data.label = buttonLabelValidator.parse(label);
      return this;
    }
    toJSON() {
      validateRequiredButtonParameters(this.data.style, this.data.label, this.data.emoji, this.data.custom_id, this.data.sku_id, this.data.url);
      return {
        ...this.data
      };
    }
  };
  var import_v103 = require_v106();
  var BaseSelectMenuBuilder = class extends ComponentBuilder {
    static {
      __name(this, "BaseSelectMenuBuilder");
    }
    setPlaceholder(placeholder) {
      this.data.placeholder = placeholderValidator.parse(placeholder);
      return this;
    }
    setMinValues(minValues) {
      this.data.min_values = minMaxValidator.parse(minValues);
      return this;
    }
    setMaxValues(maxValues) {
      this.data.max_values = minMaxValidator.parse(maxValues);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setDisabled(disabled = true) {
      this.data.disabled = disabledValidator.parse(disabled);
      return this;
    }
    toJSON() {
      customIdValidator.parse(this.data.custom_id);
      return {
        ...this.data
      };
    }
  };
  var ChannelSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "ChannelSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v103.ComponentType.ChannelSelect });
    }
    addChannelTypes(...types) {
      const normalizedTypes = normalizeArray(types);
      this.data.channel_types ??= [];
      this.data.channel_types.push(...channelTypesValidator.parse(normalizedTypes));
      return this;
    }
    setChannelTypes(...types) {
      const normalizedTypes = normalizeArray(types);
      this.data.channel_types ??= [];
      this.data.channel_types.splice(0, this.data.channel_types.length, ...channelTypesValidator.parse(normalizedTypes));
      return this;
    }
    addDefaultChannels(...channels) {
      const normalizedValues = normalizeArray(channels);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v103.SelectMenuDefaultValueType.Channel
      })));
      return this;
    }
    setDefaultChannels(...channels) {
      const normalizedValues = normalizeArray(channels);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v103.SelectMenuDefaultValueType.Channel
      }));
      return this;
    }
    toJSON() {
      customIdValidator.parse(this.data.custom_id);
      return {
        ...this.data
      };
    }
  };
  var import_v104 = require_v106();
  var MentionableSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "MentionableSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v104.ComponentType.MentionableSelect });
    }
    addDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v104.SelectMenuDefaultValueType.Role
      })));
      return this;
    }
    addDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v104.SelectMenuDefaultValueType.User
      })));
      return this;
    }
    addDefaultValues(...values) {
      const normalizedValues = normalizeArray(values);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues);
      return this;
    }
    setDefaultValues(...values) {
      const normalizedValues = normalizeArray(values);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues;
      return this;
    }
  };
  var import_v105 = require_v106();
  var RoleSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "RoleSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v105.ComponentType.RoleSelect });
    }
    addDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v105.SelectMenuDefaultValueType.Role
      })));
      return this;
    }
    setDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v105.SelectMenuDefaultValueType.Role
      }));
      return this;
    }
  };
  var import_v106 = require_v106();
  var StringSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "StringSelectMenuBuilder");
    }
    options;
    constructor(data) {
      const { options, ...initData } = data ?? {};
      super({ ...initData, type: import_v106.ComponentType.StringSelect });
      this.options = options?.map((option) => new StringSelectMenuOptionBuilder(option)) ?? [];
    }
    addOptions(...options) {
      const normalizedOptions = normalizeArray(options);
      optionsLengthValidator.parse(this.options.length + normalizedOptions.length);
      this.options.push(...normalizedOptions.map((normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))));
      return this;
    }
    setOptions(...options) {
      return this.spliceOptions(0, this.options.length, ...options);
    }
    spliceOptions(index, deleteCount, ...options) {
      const normalizedOptions = normalizeArray(options);
      const clone = [...this.options];
      clone.splice(index, deleteCount, ...normalizedOptions.map((normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))));
      optionsLengthValidator.parse(clone.length);
      this.options.splice(0, this.options.length, ...clone);
      return this;
    }
    toJSON() {
      validateRequiredSelectMenuParameters(this.options, this.data.custom_id);
      return {
        ...this.data,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  var import_v107 = require_v106();
  var UserSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "UserSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v107.ComponentType.UserSelect });
    }
    addDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v107.SelectMenuDefaultValueType.User
      })));
      return this;
    }
    setDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v107.SelectMenuDefaultValueType.User
      }));
      return this;
    }
  };
  var import_util = require_dist();
  var import_v109 = require_v106();
  var import_fast_deep_equal = __toESM2(require_fast_deep_equal());
  var Assertions_exports3 = {};
  __export(Assertions_exports3, {
    labelValidator: () => labelValidator,
    maxLengthValidator: () => maxLengthValidator,
    minLengthValidator: () => minLengthValidator,
    placeholderValidator: () => placeholderValidator2,
    requiredValidator: () => requiredValidator,
    textInputStyleValidator: () => textInputStyleValidator,
    validateRequiredParameters: () => validateRequiredParameters,
    valueValidator: () => valueValidator
  });
  var import_shapeshift3 = require_cjs3();
  var import_v108 = require_v106();
  var textInputStyleValidator = import_shapeshift3.s.nativeEnum(import_v108.TextInputStyle);
  var minLengthValidator = import_shapeshift3.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var maxLengthValidator = import_shapeshift3.s.number().int().greaterThanOrEqual(1).lessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var requiredValidator = import_shapeshift3.s.boolean();
  var valueValidator = import_shapeshift3.s.string().lengthLessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var placeholderValidator2 = import_shapeshift3.s.string().lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var labelValidator = import_shapeshift3.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredParameters, "validateRequiredParameters");
  var TextInputBuilder = class extends ComponentBuilder {
    static {
      __name(this, "TextInputBuilder");
    }
    constructor(data) {
      super({ type: import_v109.ComponentType.TextInput, ...data });
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setLabel(label) {
      this.data.label = labelValidator.parse(label);
      return this;
    }
    setStyle(style) {
      this.data.style = textInputStyleValidator.parse(style);
      return this;
    }
    setMinLength(minLength) {
      this.data.min_length = minLengthValidator.parse(minLength);
      return this;
    }
    setMaxLength(maxLength) {
      this.data.max_length = maxLengthValidator.parse(maxLength);
      return this;
    }
    setPlaceholder(placeholder) {
      this.data.placeholder = placeholderValidator2.parse(placeholder);
      return this;
    }
    setValue(value) {
      this.data.value = valueValidator.parse(value);
      return this;
    }
    setRequired(required = true) {
      this.data.required = requiredValidator.parse(required);
      return this;
    }
    toJSON() {
      validateRequiredParameters(this.data.custom_id, this.data.style, this.data.label);
      return {
        ...this.data
      };
    }
    equals(other) {
      if ((0, import_util.isJSONEncodable)(other)) {
        return (0, import_fast_deep_equal.default)(other.toJSON(), this.data);
      }
      return (0, import_fast_deep_equal.default)(other, this.data);
    }
  };
  var import_v1015 = require_v106();
  var Assertions_exports4 = {};
  __export(Assertions_exports4, {
    accessoryPredicate: () => accessoryPredicate,
    assertReturnOfBuilder: () => assertReturnOfBuilder,
    containerColorPredicate: () => containerColorPredicate,
    descriptionPredicate: () => descriptionPredicate2,
    dividerPredicate: () => dividerPredicate,
    filePredicate: () => filePredicate,
    spacingPredicate: () => spacingPredicate,
    spoilerPredicate: () => spoilerPredicate,
    textDisplayContentPredicate: () => textDisplayContentPredicate,
    unfurledMediaItemPredicate: () => unfurledMediaItemPredicate,
    validateComponentArray: () => validateComponentArray
  });
  var import_shapeshift4 = require_cjs3();
  var import_v1011 = require_v106();
  var import_v1010 = require_v106();
  var ThumbnailBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ThumbnailBuilder");
    }
    constructor(data = {}) {
      super({
        type: import_v1010.ComponentType.Thumbnail,
        ...data,
        media: data.media ? { url: data.media.url } : undefined
      });
    }
    setDescription(description) {
      this.data.description = descriptionPredicate2.parse(description);
      return this;
    }
    clearDescription() {
      this.data.description = undefined;
      return this;
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    setURL(url) {
      this.data.media = unfurledMediaItemPredicate.parse({ url });
      return this;
    }
    toJSON() {
      unfurledMediaItemPredicate.parse(this.data.media);
      return { ...this.data };
    }
  };
  var unfurledMediaItemPredicate = import_shapeshift4.s.object({
    url: import_shapeshift4.s.string().url({ allowedProtocols: ["http:", "https:", "attachment:"] }, { message: "Invalid protocol for media URL. Must be http:, https:, or attachment:" })
  }).setValidationEnabled(isValidationEnabled);
  var descriptionPredicate2 = import_shapeshift4.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
  var filePredicate = import_shapeshift4.s.object({
    url: import_shapeshift4.s.string().url({ allowedProtocols: ["attachment:"] }, { message: "Invalid protocol for file URL. Must be attachment:" })
  }).setValidationEnabled(isValidationEnabled);
  var spoilerPredicate = import_shapeshift4.s.boolean();
  var dividerPredicate = import_shapeshift4.s.boolean();
  var spacingPredicate = import_shapeshift4.s.nativeEnum(import_v1011.SeparatorSpacingSize);
  var textDisplayContentPredicate = import_shapeshift4.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var accessoryPredicate = import_shapeshift4.s.instance(ButtonBuilder).or(import_shapeshift4.s.instance(ThumbnailBuilder)).setValidationEnabled(isValidationEnabled);
  var containerColorPredicate = colorPredicate.nullish();
  __name(assertReturnOfBuilder, "assertReturnOfBuilder");
  __name(validateComponentArray, "validateComponentArray");
  var import_v1012 = require_v106();
  var FileBuilder = class extends ComponentBuilder {
    static {
      __name(this, "FileBuilder");
    }
    constructor(data = {}) {
      super({ type: import_v1012.ComponentType.File, ...data, file: data.file ? { url: data.file.url } : undefined });
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    setURL(url) {
      this.data.file = filePredicate.parse({ url });
      return this;
    }
    toJSON() {
      filePredicate.parse(this.data.file);
      return { ...this.data, file: { ...this.data.file } };
    }
  };
  var import_v1013 = require_v106();
  var SeparatorBuilder = class extends ComponentBuilder {
    static {
      __name(this, "SeparatorBuilder");
    }
    constructor(data = {}) {
      super({
        type: import_v1013.ComponentType.Separator,
        ...data
      });
    }
    setDivider(divider = true) {
      this.data.divider = dividerPredicate.parse(divider);
      return this;
    }
    setSpacing(spacing) {
      this.data.spacing = spacingPredicate.parse(spacing);
      return this;
    }
    clearSpacing() {
      this.data.spacing = undefined;
      return this;
    }
    toJSON() {
      return { ...this.data };
    }
  };
  var import_v1014 = require_v106();
  var TextDisplayBuilder = class extends ComponentBuilder {
    static {
      __name(this, "TextDisplayBuilder");
    }
    constructor(data = {}) {
      super({
        type: import_v1014.ComponentType.TextDisplay,
        ...data
      });
    }
    setContent(content) {
      this.data.content = textDisplayContentPredicate.parse(content);
      return this;
    }
    toJSON() {
      textDisplayContentPredicate.parse(this.data.content);
      return { ...this.data };
    }
  };
  var ContainerBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ContainerBuilder");
    }
    components;
    constructor({ components, ...data } = {}) {
      super({ type: import_v1015.ComponentType.Container, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    setAccentColor(color) {
      containerColorPredicate.parse(color);
      if (Array.isArray(color)) {
        const [red, green, blue] = color;
        this.data.accent_color = (red << 16) + (green << 8) + blue;
        return this;
      }
      this.data.accent_color = color;
      return this;
    }
    clearAccentColor() {
      this.data.accent_color = undefined;
      return this;
    }
    addActionRowComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, ActionRowBuilder)));
      return this;
    }
    addFileComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, FileBuilder)));
      return this;
    }
    addMediaGalleryComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, MediaGalleryBuilder)));
      return this;
    }
    addSectionComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, SectionBuilder)));
      return this;
    }
    addSeparatorComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, SeparatorBuilder)));
      return this;
    }
    addTextDisplayComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, TextDisplayBuilder)));
      return this;
    }
    spliceComponents(index, deleteCount, ...components) {
      this.components.splice(index, deleteCount, ...normalizeArray(components).map((component) => component instanceof ComponentBuilder ? component : createComponentBuilder(component)));
      return this;
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    toJSON() {
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var import_v1016 = require_v106();
  var MediaGalleryItemBuilder = class {
    static {
      __name(this, "MediaGalleryItemBuilder");
    }
    data;
    constructor(data = {}) {
      this.data = data;
    }
    setDescription(description) {
      this.data.description = descriptionPredicate2.parse(description);
      return this;
    }
    clearDescription() {
      this.data.description = undefined;
      return this;
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    setURL(url) {
      this.data.media = unfurledMediaItemPredicate.parse({ url });
      return this;
    }
    toJSON() {
      unfurledMediaItemPredicate.parse(this.data.media);
      return { ...this.data };
    }
  };
  var MediaGalleryBuilder = class extends ComponentBuilder {
    static {
      __name(this, "MediaGalleryBuilder");
    }
    items;
    constructor({ items, ...data } = {}) {
      super({ type: import_v1016.ComponentType.MediaGallery, ...data });
      this.items = items?.map((item) => new MediaGalleryItemBuilder(item)) ?? [];
    }
    addItems(...items) {
      this.items.push(...normalizeArray(items).map((input) => {
        const result = resolveBuilder(input, MediaGalleryItemBuilder);
        assertReturnOfBuilder(result, MediaGalleryItemBuilder);
        return result;
      }));
      return this;
    }
    spliceItems(index, deleteCount, ...items) {
      this.items.splice(index, deleteCount, ...normalizeArray(items).map((input) => {
        const result = resolveBuilder(input, MediaGalleryItemBuilder);
        assertReturnOfBuilder(result, MediaGalleryItemBuilder);
        return result;
      }));
      return this;
    }
    toJSON() {
      validateComponentArray(this.items, 1, 10, MediaGalleryItemBuilder);
      return {
        ...this.data,
        items: this.items.map((item) => item.toJSON())
      };
    }
  };
  var import_v1017 = require_v106();
  var SectionBuilder = class extends ComponentBuilder {
    static {
      __name(this, "SectionBuilder");
    }
    components;
    accessory;
    constructor({ components, accessory, ...data } = {}) {
      super({ type: import_v1017.ComponentType.Section, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
      this.accessory = accessory ? createComponentBuilder(accessory) : undefined;
    }
    setButtonAccessory(accessory) {
      Reflect.set(this, "accessory", accessoryPredicate.parse(resolveBuilder(accessory, ButtonBuilder)));
      return this;
    }
    setThumbnailAccessory(accessory) {
      Reflect.set(this, "accessory", accessoryPredicate.parse(resolveBuilder(accessory, ThumbnailBuilder)));
      return this;
    }
    addTextDisplayComponents(...components) {
      this.components.push(...normalizeArray(components).map((input) => {
        const result = resolveBuilder(input, TextDisplayBuilder);
        assertReturnOfBuilder(result, TextDisplayBuilder);
        return result;
      }));
      return this;
    }
    spliceTextDisplayComponents(index, deleteCount, ...components) {
      this.components.splice(index, deleteCount, ...normalizeArray(components).map((input) => {
        const result = resolveBuilder(input, TextDisplayBuilder);
        assertReturnOfBuilder(result, TextDisplayBuilder);
        return result;
      }));
      return this;
    }
    toJSON() {
      validateComponentArray(this.components, 1, 3, TextDisplayBuilder);
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON()),
        accessory: accessoryPredicate.parse(this.accessory).toJSON()
      };
    }
  };
  __name(createComponentBuilder, "createComponentBuilder");
  __name(isBuilder, "isBuilder");
  __name(resolveBuilder, "resolveBuilder");
  var ActionRowBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ActionRowBuilder");
    }
    components;
    constructor({ components, ...data } = {}) {
      super({ type: import_v1019.ComponentType.ActionRow, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    addComponents(...components) {
      this.components.push(...normalizeArray(components));
      return this;
    }
    setComponents(...components) {
      this.components.splice(0, this.components.length, ...normalizeArray(components));
      return this;
    }
    toJSON() {
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var Assertions_exports5 = {};
  __export(Assertions_exports5, {
    componentsValidator: () => componentsValidator,
    titleValidator: () => titleValidator,
    validateRequiredParameters: () => validateRequiredParameters2
  });
  var import_shapeshift5 = require_cjs3();
  var titleValidator = import_shapeshift5.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
  var componentsValidator = import_shapeshift5.s.instance(ActionRowBuilder).array().lengthGreaterThanOrEqual(1).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredParameters2, "validateRequiredParameters");
  var ModalBuilder = class {
    static {
      __name(this, "ModalBuilder");
    }
    data;
    components = [];
    constructor({ components, ...data } = {}) {
      this.data = { ...data };
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    setTitle(title) {
      this.data.title = titleValidator.parse(title);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    addComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => component instanceof ActionRowBuilder ? component : new ActionRowBuilder(component)));
      return this;
    }
    setComponents(...components) {
      this.components.splice(0, this.components.length, ...normalizeArray(components));
      return this;
    }
    toJSON() {
      validateRequiredParameters2(this.data.custom_id, this.data.title, this.components);
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var Assertions_exports6 = {};
  __export(Assertions_exports6, {
    assertReturnOfBuilder: () => assertReturnOfBuilder2,
    contextsPredicate: () => contextsPredicate,
    integrationTypesPredicate: () => integrationTypesPredicate,
    localizationMapPredicate: () => localizationMapPredicate,
    validateChoicesLength: () => validateChoicesLength,
    validateDMPermission: () => validateDMPermission,
    validateDefaultMemberPermissions: () => validateDefaultMemberPermissions,
    validateDefaultPermission: () => validateDefaultPermission,
    validateDescription: () => validateDescription,
    validateLocale: () => validateLocale,
    validateLocalizationMap: () => validateLocalizationMap,
    validateMaxOptionsLength: () => validateMaxOptionsLength,
    validateNSFW: () => validateNSFW,
    validateName: () => validateName,
    validateRequired: () => validateRequired,
    validateRequiredParameters: () => validateRequiredParameters3
  });
  var import_shapeshift6 = require_cjs3();
  var import_v1020 = require_v106();
  var namePredicate = import_shapeshift6.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^[\p{Ll}\p{Lm}\p{Lo}\p{N}\p{sc=Devanagari}\p{sc=Thai}_-]+$/u).setValidationEnabled(isValidationEnabled);
  __name(validateName, "validateName");
  var descriptionPredicate3 = import_shapeshift6.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var localePredicate = import_shapeshift6.s.nativeEnum(import_v1020.Locale);
  __name(validateDescription, "validateDescription");
  var maxArrayLengthPredicate = import_shapeshift6.s.unknown().array().lengthLessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateLocale, "validateLocale");
  __name(validateMaxOptionsLength, "validateMaxOptionsLength");
  __name(validateRequiredParameters3, "validateRequiredParameters");
  var booleanPredicate = import_shapeshift6.s.boolean();
  __name(validateDefaultPermission, "validateDefaultPermission");
  __name(validateRequired, "validateRequired");
  var choicesLengthPredicate = import_shapeshift6.s.number().lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateChoicesLength, "validateChoicesLength");
  __name(assertReturnOfBuilder2, "assertReturnOfBuilder");
  var localizationMapPredicate = import_shapeshift6.s.object(Object.fromEntries(Object.values(import_v1020.Locale).map((locale) => [locale, import_shapeshift6.s.string().nullish()]))).strict().nullish().setValidationEnabled(isValidationEnabled);
  __name(validateLocalizationMap, "validateLocalizationMap");
  var dmPermissionPredicate = import_shapeshift6.s.boolean().nullish();
  __name(validateDMPermission, "validateDMPermission");
  var memberPermissionPredicate = import_shapeshift6.s.union([
    import_shapeshift6.s.bigint().transform((value) => value.toString()),
    import_shapeshift6.s.number().safeInt().transform((value) => value.toString()),
    import_shapeshift6.s.string().regex(/^\d+$/)
  ]).nullish();
  __name(validateDefaultMemberPermissions, "validateDefaultMemberPermissions");
  __name(validateNSFW, "validateNSFW");
  var contextsPredicate = import_shapeshift6.s.array(import_shapeshift6.s.nativeEnum(import_v1020.InteractionContextType).setValidationEnabled(isValidationEnabled));
  var integrationTypesPredicate = import_shapeshift6.s.array(import_shapeshift6.s.nativeEnum(import_v1020.ApplicationIntegrationType).setValidationEnabled(isValidationEnabled));
  var import_ts_mixer6 = require_cjs4();
  var SharedNameAndDescription = class {
    static {
      __name(this, "SharedNameAndDescription");
    }
    name;
    name_localizations;
    description;
    description_localizations;
    setName(name) {
      validateName(name);
      Reflect.set(this, "name", name);
      return this;
    }
    setDescription(description) {
      validateDescription(description);
      Reflect.set(this, "description", description);
      return this;
    }
    setNameLocalization(locale, localizedName) {
      if (!this.name_localizations) {
        Reflect.set(this, "name_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedName === null) {
        this.name_localizations[parsedLocale] = null;
        return this;
      }
      validateName(localizedName);
      this.name_localizations[parsedLocale] = localizedName;
      return this;
    }
    setNameLocalizations(localizedNames) {
      if (localizedNames === null) {
        Reflect.set(this, "name_localizations", null);
        return this;
      }
      Reflect.set(this, "name_localizations", {});
      for (const args of Object.entries(localizedNames)) {
        this.setNameLocalization(...args);
      }
      return this;
    }
    setDescriptionLocalization(locale, localizedDescription) {
      if (!this.description_localizations) {
        Reflect.set(this, "description_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedDescription === null) {
        this.description_localizations[parsedLocale] = null;
        return this;
      }
      validateDescription(localizedDescription);
      this.description_localizations[parsedLocale] = localizedDescription;
      return this;
    }
    setDescriptionLocalizations(localizedDescriptions) {
      if (localizedDescriptions === null) {
        Reflect.set(this, "description_localizations", null);
        return this;
      }
      Reflect.set(this, "description_localizations", {});
      for (const args of Object.entries(localizedDescriptions)) {
        this.setDescriptionLocalization(...args);
      }
      return this;
    }
  };
  var import_v1021 = require_v106();
  var SharedSlashCommand = class {
    static {
      __name(this, "SharedSlashCommand");
    }
    name = undefined;
    name_localizations;
    description = undefined;
    description_localizations;
    options = [];
    contexts;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    integration_types;
    nsfw = undefined;
    setContexts(...contexts) {
      Reflect.set(this, "contexts", contextsPredicate.parse(normalizeArray(contexts)));
      return this;
    }
    setIntegrationTypes(...integrationTypes) {
      Reflect.set(this, "integration_types", integrationTypesPredicate.parse(normalizeArray(integrationTypes)));
      return this;
    }
    setDefaultPermission(value) {
      validateDefaultPermission(value);
      Reflect.set(this, "default_permission", value);
      return this;
    }
    setDefaultMemberPermissions(permissions) {
      const permissionValue = validateDefaultMemberPermissions(permissions);
      Reflect.set(this, "default_member_permissions", permissionValue);
      return this;
    }
    setDMPermission(enabled) {
      validateDMPermission(enabled);
      Reflect.set(this, "dm_permission", enabled);
      return this;
    }
    setNSFW(nsfw = true) {
      validateNSFW(nsfw);
      Reflect.set(this, "nsfw", nsfw);
      return this;
    }
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      validateLocalizationMap(this.name_localizations);
      validateLocalizationMap(this.description_localizations);
      return {
        ...this,
        type: import_v1021.ApplicationCommandType.ChatInput,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  var import_v1022 = require_v106();
  var ApplicationCommandOptionBase = class extends SharedNameAndDescription {
    static {
      __name(this, "ApplicationCommandOptionBase");
    }
    required = false;
    setRequired(required) {
      validateRequired(required);
      Reflect.set(this, "required", required);
      return this;
    }
    runRequiredValidations() {
      validateRequiredParameters3(this.name, this.description, []);
      validateLocalizationMap(this.name_localizations);
      validateLocalizationMap(this.description_localizations);
      validateRequired(this.required);
    }
  };
  var SlashCommandAttachmentOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandAttachmentOption");
    }
    type = import_v1022.ApplicationCommandOptionType.Attachment;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_v1023 = require_v106();
  var SlashCommandBooleanOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandBooleanOption");
    }
    type = import_v1023.ApplicationCommandOptionType.Boolean;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_v1025 = require_v106();
  var import_ts_mixer = require_cjs4();
  var import_shapeshift7 = require_cjs3();
  var import_v1024 = require_v106();
  var allowedChannelTypes = [
    import_v1024.ChannelType.GuildText,
    import_v1024.ChannelType.GuildVoice,
    import_v1024.ChannelType.GuildCategory,
    import_v1024.ChannelType.GuildAnnouncement,
    import_v1024.ChannelType.AnnouncementThread,
    import_v1024.ChannelType.PublicThread,
    import_v1024.ChannelType.PrivateThread,
    import_v1024.ChannelType.GuildStageVoice,
    import_v1024.ChannelType.GuildForum,
    import_v1024.ChannelType.GuildMedia
  ];
  var channelTypesPredicate = import_shapeshift7.s.array(import_shapeshift7.s.union(allowedChannelTypes.map((type) => import_shapeshift7.s.literal(type))));
  var ApplicationCommandOptionChannelTypesMixin = class {
    static {
      __name(this, "ApplicationCommandOptionChannelTypesMixin");
    }
    channel_types;
    addChannelTypes(...channelTypes) {
      if (this.channel_types === undefined) {
        Reflect.set(this, "channel_types", []);
      }
      this.channel_types.push(...channelTypesPredicate.parse(normalizeArray(channelTypes)));
      return this;
    }
  };
  var SlashCommandChannelOption = class extends ApplicationCommandOptionBase {
    type = import_v1025.ApplicationCommandOptionType.Channel;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  __name(SlashCommandChannelOption, "SlashCommandChannelOption");
  SlashCommandChannelOption = __decorateClass([
    (0, import_ts_mixer.mix)(ApplicationCommandOptionChannelTypesMixin)
  ], SlashCommandChannelOption);
  var import_shapeshift10 = require_cjs3();
  var import_v1027 = require_v106();
  var import_ts_mixer2 = require_cjs4();
  var ApplicationCommandNumericOptionMinMaxValueMixin = class {
    static {
      __name(this, "ApplicationCommandNumericOptionMinMaxValueMixin");
    }
    max_value;
    min_value;
  };
  var import_shapeshift8 = require_cjs3();
  var booleanPredicate2 = import_shapeshift8.s.boolean();
  var ApplicationCommandOptionWithAutocompleteMixin = class {
    static {
      __name(this, "ApplicationCommandOptionWithAutocompleteMixin");
    }
    autocomplete;
    type;
    setAutocomplete(autocomplete) {
      booleanPredicate2.parse(autocomplete);
      if (autocomplete && "choices" in this && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      Reflect.set(this, "autocomplete", autocomplete);
      return this;
    }
  };
  var import_shapeshift9 = require_cjs3();
  var import_v1026 = require_v106();
  var stringPredicate = import_shapeshift9.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100);
  var numberPredicate = import_shapeshift9.s.number().greaterThan(Number.NEGATIVE_INFINITY).lessThan(Number.POSITIVE_INFINITY);
  var choicesPredicate = import_shapeshift9.s.object({
    name: stringPredicate,
    name_localizations: localizationMapPredicate,
    value: import_shapeshift9.s.union([stringPredicate, numberPredicate])
  }).array();
  var ApplicationCommandOptionWithChoicesMixin = class {
    static {
      __name(this, "ApplicationCommandOptionWithChoicesMixin");
    }
    choices;
    type;
    addChoices(...choices) {
      const normalizedChoices = normalizeArray(choices);
      if (normalizedChoices.length > 0 && "autocomplete" in this && this.autocomplete) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      choicesPredicate.parse(normalizedChoices);
      if (this.choices === undefined) {
        Reflect.set(this, "choices", []);
      }
      validateChoicesLength(normalizedChoices.length, this.choices);
      for (const { name, name_localizations, value } of normalizedChoices) {
        if (this.type === import_v1026.ApplicationCommandOptionType.String) {
          stringPredicate.parse(value);
        } else {
          numberPredicate.parse(value);
        }
        this.choices.push({ name, name_localizations, value });
      }
      return this;
    }
    setChoices(...choices) {
      const normalizedChoices = normalizeArray(choices);
      if (normalizedChoices.length > 0 && "autocomplete" in this && this.autocomplete) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      choicesPredicate.parse(normalizedChoices);
      Reflect.set(this, "choices", []);
      this.addChoices(normalizedChoices);
      return this;
    }
  };
  var numberValidator = import_shapeshift10.s.number().int();
  var SlashCommandIntegerOption = class extends ApplicationCommandOptionBase {
    type = import_v1027.ApplicationCommandOptionType.Integer;
    setMaxValue(max) {
      numberValidator.parse(max);
      Reflect.set(this, "max_value", max);
      return this;
    }
    setMinValue(min) {
      numberValidator.parse(min);
      Reflect.set(this, "min_value", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandIntegerOption, "SlashCommandIntegerOption");
  SlashCommandIntegerOption = __decorateClass([
    (0, import_ts_mixer2.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithAutocompleteMixin, ApplicationCommandOptionWithChoicesMixin)
  ], SlashCommandIntegerOption);
  var import_v1028 = require_v106();
  var SlashCommandMentionableOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandMentionableOption");
    }
    type = import_v1028.ApplicationCommandOptionType.Mentionable;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_shapeshift11 = require_cjs3();
  var import_v1029 = require_v106();
  var import_ts_mixer3 = require_cjs4();
  var numberValidator2 = import_shapeshift11.s.number();
  var SlashCommandNumberOption = class extends ApplicationCommandOptionBase {
    type = import_v1029.ApplicationCommandOptionType.Number;
    setMaxValue(max) {
      numberValidator2.parse(max);
      Reflect.set(this, "max_value", max);
      return this;
    }
    setMinValue(min) {
      numberValidator2.parse(min);
      Reflect.set(this, "min_value", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandNumberOption, "SlashCommandNumberOption");
  SlashCommandNumberOption = __decorateClass([
    (0, import_ts_mixer3.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithAutocompleteMixin, ApplicationCommandOptionWithChoicesMixin)
  ], SlashCommandNumberOption);
  var import_v1030 = require_v106();
  var SlashCommandRoleOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandRoleOption");
    }
    type = import_v1030.ApplicationCommandOptionType.Role;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_shapeshift12 = require_cjs3();
  var import_v1031 = require_v106();
  var import_ts_mixer4 = require_cjs4();
  var minLengthValidator2 = import_shapeshift12.s.number().greaterThanOrEqual(0).lessThanOrEqual(6000);
  var maxLengthValidator2 = import_shapeshift12.s.number().greaterThanOrEqual(1).lessThanOrEqual(6000);
  var SlashCommandStringOption = class extends ApplicationCommandOptionBase {
    type = import_v1031.ApplicationCommandOptionType.String;
    max_length;
    min_length;
    setMaxLength(max) {
      maxLengthValidator2.parse(max);
      Reflect.set(this, "max_length", max);
      return this;
    }
    setMinLength(min) {
      minLengthValidator2.parse(min);
      Reflect.set(this, "min_length", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandStringOption, "SlashCommandStringOption");
  SlashCommandStringOption = __decorateClass([
    (0, import_ts_mixer4.mix)(ApplicationCommandOptionWithAutocompleteMixin, ApplicationCommandOptionWithChoicesMixin)
  ], SlashCommandStringOption);
  var import_v1032 = require_v106();
  var SlashCommandUserOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandUserOption");
    }
    type = import_v1032.ApplicationCommandOptionType.User;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var SharedSlashCommandOptions = class {
    static {
      __name(this, "SharedSlashCommandOptions");
    }
    options;
    addBooleanOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandBooleanOption);
    }
    addUserOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandUserOption);
    }
    addChannelOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandChannelOption);
    }
    addRoleOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandRoleOption);
    }
    addAttachmentOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandAttachmentOption);
    }
    addMentionableOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandMentionableOption);
    }
    addStringOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandStringOption);
    }
    addIntegerOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandIntegerOption);
    }
    addNumberOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandNumberOption);
    }
    _sharedAddOptionMethod(input, Instance) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new Instance) : input;
      assertReturnOfBuilder2(result, Instance);
      options.push(result);
      return this;
    }
  };
  var import_v1033 = require_v106();
  var import_ts_mixer5 = require_cjs4();
  var SlashCommandSubcommandGroupBuilder = class {
    name = undefined;
    description = undefined;
    options = [];
    addSubcommand(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder) : input;
      assertReturnOfBuilder2(result, SlashCommandSubcommandBuilder);
      options.push(result);
      return this;
    }
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      return {
        type: import_v1033.ApplicationCommandOptionType.SubcommandGroup,
        name: this.name,
        name_localizations: this.name_localizations,
        description: this.description,
        description_localizations: this.description_localizations,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandSubcommandGroupBuilder, "SlashCommandSubcommandGroupBuilder");
  SlashCommandSubcommandGroupBuilder = __decorateClass([
    (0, import_ts_mixer5.mix)(SharedNameAndDescription)
  ], SlashCommandSubcommandGroupBuilder);
  var SlashCommandSubcommandBuilder = class {
    name = undefined;
    description = undefined;
    options = [];
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      return {
        type: import_v1033.ApplicationCommandOptionType.Subcommand,
        name: this.name,
        name_localizations: this.name_localizations,
        description: this.description,
        description_localizations: this.description_localizations,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandSubcommandBuilder, "SlashCommandSubcommandBuilder");
  SlashCommandSubcommandBuilder = __decorateClass([
    (0, import_ts_mixer5.mix)(SharedNameAndDescription, SharedSlashCommandOptions)
  ], SlashCommandSubcommandBuilder);
  var SharedSlashCommandSubcommands = class {
    static {
      __name(this, "SharedSlashCommandSubcommands");
    }
    options = [];
    addSubcommandGroup(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandGroupBuilder) : input;
      assertReturnOfBuilder2(result, SlashCommandSubcommandGroupBuilder);
      options.push(result);
      return this;
    }
    addSubcommand(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder) : input;
      assertReturnOfBuilder2(result, SlashCommandSubcommandBuilder);
      options.push(result);
      return this;
    }
  };
  var SlashCommandBuilder = class {
    name = undefined;
    name_localizations;
    description = undefined;
    description_localizations;
    options = [];
    contexts;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    integration_types;
    nsfw = undefined;
  };
  __name(SlashCommandBuilder, "SlashCommandBuilder");
  SlashCommandBuilder = __decorateClass([
    (0, import_ts_mixer6.mix)(SharedSlashCommandOptions, SharedNameAndDescription, SharedSlashCommandSubcommands, SharedSlashCommand)
  ], SlashCommandBuilder);
  var Assertions_exports7 = {};
  __export(Assertions_exports7, {
    contextsPredicate: () => contextsPredicate2,
    integrationTypesPredicate: () => integrationTypesPredicate2,
    validateDMPermission: () => validateDMPermission2,
    validateDefaultMemberPermissions: () => validateDefaultMemberPermissions2,
    validateDefaultPermission: () => validateDefaultPermission2,
    validateName: () => validateName2,
    validateRequiredParameters: () => validateRequiredParameters4,
    validateType: () => validateType
  });
  var import_shapeshift13 = require_cjs3();
  var import_v1034 = require_v106();
  var namePredicate2 = import_shapeshift13.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^( *[\p{P}\p{L}\p{N}\p{sc=Devanagari}\p{sc=Thai}]+ *)+$/u).setValidationEnabled(isValidationEnabled);
  var typePredicate = import_shapeshift13.s.union([import_shapeshift13.s.literal(import_v1034.ApplicationCommandType.User), import_shapeshift13.s.literal(import_v1034.ApplicationCommandType.Message)]).setValidationEnabled(isValidationEnabled);
  var booleanPredicate3 = import_shapeshift13.s.boolean();
  __name(validateDefaultPermission2, "validateDefaultPermission");
  __name(validateName2, "validateName");
  __name(validateType, "validateType");
  __name(validateRequiredParameters4, "validateRequiredParameters");
  var dmPermissionPredicate2 = import_shapeshift13.s.boolean().nullish();
  __name(validateDMPermission2, "validateDMPermission");
  var memberPermissionPredicate2 = import_shapeshift13.s.union([
    import_shapeshift13.s.bigint().transform((value) => value.toString()),
    import_shapeshift13.s.number().safeInt().transform((value) => value.toString()),
    import_shapeshift13.s.string().regex(/^\d+$/)
  ]).nullish();
  __name(validateDefaultMemberPermissions2, "validateDefaultMemberPermissions");
  var contextsPredicate2 = import_shapeshift13.s.array(import_shapeshift13.s.nativeEnum(import_v1034.InteractionContextType).setValidationEnabled(isValidationEnabled));
  var integrationTypesPredicate2 = import_shapeshift13.s.array(import_shapeshift13.s.nativeEnum(import_v1034.ApplicationIntegrationType).setValidationEnabled(isValidationEnabled));
  var ContextMenuCommandBuilder = class {
    static {
      __name(this, "ContextMenuCommandBuilder");
    }
    name = undefined;
    name_localizations;
    type = undefined;
    contexts;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    integration_types;
    setContexts(...contexts) {
      Reflect.set(this, "contexts", contextsPredicate2.parse(normalizeArray(contexts)));
      return this;
    }
    setIntegrationTypes(...integrationTypes) {
      Reflect.set(this, "integration_types", integrationTypesPredicate2.parse(normalizeArray(integrationTypes)));
      return this;
    }
    setName(name) {
      validateName2(name);
      Reflect.set(this, "name", name);
      return this;
    }
    setType(type) {
      validateType(type);
      Reflect.set(this, "type", type);
      return this;
    }
    setDefaultPermission(value) {
      validateDefaultPermission2(value);
      Reflect.set(this, "default_permission", value);
      return this;
    }
    setDefaultMemberPermissions(permissions) {
      const permissionValue = validateDefaultMemberPermissions2(permissions);
      Reflect.set(this, "default_member_permissions", permissionValue);
      return this;
    }
    setDMPermission(enabled) {
      validateDMPermission2(enabled);
      Reflect.set(this, "dm_permission", enabled);
      return this;
    }
    setNameLocalization(locale, localizedName) {
      if (!this.name_localizations) {
        Reflect.set(this, "name_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedName === null) {
        this.name_localizations[parsedLocale] = null;
        return this;
      }
      validateName2(localizedName);
      this.name_localizations[parsedLocale] = localizedName;
      return this;
    }
    setNameLocalizations(localizedNames) {
      if (localizedNames === null) {
        Reflect.set(this, "name_localizations", null);
        return this;
      }
      Reflect.set(this, "name_localizations", {});
      for (const args of Object.entries(localizedNames))
        this.setNameLocalization(...args);
      return this;
    }
    toJSON() {
      validateRequiredParameters4(this.name, this.type);
      validateLocalizationMap(this.name_localizations);
      return { ...this };
    }
  };
  __name(embedLength, "embedLength");
  var version = "1.11.2";
});

// node_modules/discord.js/src/structures/Embed.js
var require_Embed = __commonJS((exports, module) => {
  var { embedLength } = require_dist8();
  var isEqual = require_fast_deep_equal();

  class Embed {
    constructor(data) {
      this.data = { ...data };
    }
    get fields() {
      return this.data.fields ?? [];
    }
    get title() {
      return this.data.title ?? null;
    }
    get description() {
      return this.data.description ?? null;
    }
    get url() {
      return this.data.url ?? null;
    }
    get color() {
      return this.data.color ?? null;
    }
    get timestamp() {
      return this.data.timestamp ?? null;
    }
    get thumbnail() {
      if (!this.data.thumbnail)
        return null;
      return {
        url: this.data.thumbnail.url,
        proxyURL: this.data.thumbnail.proxy_url,
        height: this.data.thumbnail.height,
        width: this.data.thumbnail.width
      };
    }
    get image() {
      if (!this.data.image)
        return null;
      return {
        url: this.data.image.url,
        proxyURL: this.data.image.proxy_url,
        height: this.data.image.height,
        width: this.data.image.width
      };
    }
    get video() {
      if (!this.data.video)
        return null;
      return {
        url: this.data.video.url,
        proxyURL: this.data.video.proxy_url,
        height: this.data.video.height,
        width: this.data.video.width
      };
    }
    get author() {
      if (!this.data.author)
        return null;
      return {
        name: this.data.author.name,
        url: this.data.author.url,
        iconURL: this.data.author.icon_url,
        proxyIconURL: this.data.author.proxy_icon_url
      };
    }
    get provider() {
      return this.data.provider ?? null;
    }
    get footer() {
      if (!this.data.footer)
        return null;
      return {
        text: this.data.footer.text,
        iconURL: this.data.footer.icon_url,
        proxyIconURL: this.data.footer.proxy_icon_url
      };
    }
    get length() {
      return embedLength(this.data);
    }
    get hexColor() {
      return typeof this.data.color === "number" ? `#${this.data.color.toString(16).padStart(6, "0")}` : this.data.color ?? null;
    }
    toJSON() {
      return { ...this.data };
    }
    equals(other) {
      if (other instanceof Embed) {
        return isEqual(this.data, other.data);
      }
      return this.author?.iconURL === other.author?.icon_url && this.author?.name === other.author?.name && this.author?.url === other.author?.url && this.color === (other.color ?? null) && this.description === (other.description ?? null) && this.footer?.iconURL === other.footer?.icon_url && this.footer?.text === other.footer?.text && this.image?.url === other.image?.url && this.thumbnail?.url === other.thumbnail?.url && (this.timestamp && Date.parse(this.timestamp)) === (other.timestamp ? Date.parse(other.timestamp) : null) && this.title === (other.title ?? null) && this.url === (other.url ?? null) && this.video?.url === other.video?.url && isEqual(this.fields, other.fields?.map((field) => ({ ...field, inline: field.inline ?? false })) ?? []) && isEqual(this.provider, other.provider ?? null);
    }
  }
  module.exports = Embed;
});

// node_modules/discord.js/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { FormattingPatterns } = require_v106();
  var { flatten } = require_Util();

  class MessageMentions {
    static EveryonePattern = /@(?<mention>everyone|here)/;
    static UsersPattern = FormattingPatterns.UserWithOptionalNickname;
    static RolesPattern = FormattingPatterns.Role;
    static ChannelsPattern = FormattingPatterns.Channel;
    static GlobalChannelsPattern = new RegExp(this.ChannelsPattern.source, "g");
    static GlobalUsersPattern = new RegExp(this.UsersPattern.source, "g");
    constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {
      Object.defineProperty(this, "client", { value: message.client });
      Object.defineProperty(this, "guild", { value: message.guild });
      Object.defineProperty(this, "_content", { value: message.content });
      this.everyone = Boolean(everyone);
      if (users) {
        if (users instanceof Collection) {
          this.users = new Collection(users);
        } else {
          this.users = new Collection;
          for (const mention of users) {
            if (mention.member && message.guild) {
              message.guild.members._add(Object.assign(mention.member, { user: mention }));
            }
            const user = message.client.users._add(mention);
            this.users.set(user.id, user);
          }
        }
      } else {
        this.users = new Collection;
      }
      if (roles instanceof Collection) {
        this.roles = new Collection(roles);
      } else if (roles) {
        this.roles = new Collection;
        const guild = message.guild;
        if (guild) {
          for (const mention of roles) {
            const role = guild.roles.cache.get(mention);
            if (role)
              this.roles.set(role.id, role);
          }
        }
      } else {
        this.roles = new Collection;
      }
      this._members = null;
      this._channels = null;
      this._parsedUsers = null;
      if (crosspostedChannels) {
        if (crosspostedChannels instanceof Collection) {
          this.crosspostedChannels = new Collection(crosspostedChannels);
        } else {
          this.crosspostedChannels = new Collection;
          for (const crosspostedChannel of crosspostedChannels) {
            this.crosspostedChannels.set(crosspostedChannel.id, {
              channelId: crosspostedChannel.id,
              guildId: crosspostedChannel.guild_id,
              type: crosspostedChannel.type,
              name: crosspostedChannel.name
            });
          }
        }
      } else {
        this.crosspostedChannels = new Collection;
      }
      this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;
    }
    get members() {
      if (this._members)
        return this._members;
      if (!this.guild)
        return null;
      this._members = new Collection;
      this.users.forEach((user) => {
        const member = this.guild.members.resolve(user);
        if (member)
          this._members.set(member.user.id, member);
      });
      return this._members;
    }
    get channels() {
      if (this._channels)
        return this._channels;
      this._channels = new Collection;
      let matches;
      while ((matches = this.constructor.GlobalChannelsPattern.exec(this._content)) !== null) {
        const channel = this.client.channels.cache.get(matches.groups.id);
        if (channel)
          this._channels.set(channel.id, channel);
      }
      return this._channels;
    }
    get parsedUsers() {
      if (this._parsedUsers)
        return this._parsedUsers;
      this._parsedUsers = new Collection;
      let matches;
      while ((matches = this.constructor.GlobalUsersPattern.exec(this._content)) !== null) {
        const user = this.client.users.cache.get(matches[1]);
        if (user)
          this._parsedUsers.set(user.id, user);
      }
      return this._parsedUsers;
    }
    has(data, { ignoreDirect = false, ignoreRoles = false, ignoreRepliedUser = false, ignoreEveryone = false } = {}) {
      const user = this.client.users.resolve(data);
      if (!ignoreEveryone && user && this.everyone)
        return true;
      const userWasRepliedTo = user && this.repliedUser?.id === user.id;
      if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id))
        return true;
      if (!ignoreDirect) {
        if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id))
          return true;
        const role = this.guild?.roles.resolve(data);
        if (role && this.roles.has(role.id))
          return true;
        const channel = this.client.channels.resolve(data);
        if (channel && this.channels.has(channel.id))
          return true;
      }
      if (!ignoreRoles) {
        const member = this.guild?.members.resolve(data);
        if (member) {
          for (const mentionedRole of this.roles.values())
            if (member.roles.cache.has(mentionedRole.id))
              return true;
        }
      }
      return false;
    }
    toJSON() {
      return flatten(this, {
        members: true,
        channels: true
      });
    }
  }
  module.exports = MessageMentions;
});

// node_modules/discord.js/src/structures/PollAnswer.js
var require_PollAnswer = __commonJS((exports) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class PollAnswer extends Base {
    constructor(client, data, poll) {
      super(client);
      Object.defineProperty(this, "poll", { value: poll });
      this.id = data.answer_id;
      this.text = data.poll_media.text ?? null;
      Object.defineProperty(this, "_emoji", { value: data.poll_media.emoji ?? null });
      this._patch(data);
    }
    _patch(data) {
      if ("count" in data) {
        this.voteCount = data.count;
      } else {
        this.voteCount ??= 0;
      }
    }
    get emoji() {
      if (!this._emoji || !this._emoji.id && !this._emoji.name)
        return null;
      return this.client.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
    fetchVoters({ after, limit } = {}) {
      return this.poll.message.channel.messages.fetchPollAnswerVoters({
        messageId: this.poll.message.id,
        answerId: this.id,
        after,
        limit
      });
    }
  }
  exports.PollAnswer = PollAnswer;
});

// node_modules/discord.js/src/structures/Poll.js
var require_Poll = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { PollAnswer } = require_PollAnswer();
  var { DiscordjsError } = require_DJSError();
  var { ErrorCodes } = require_errors();

  class Poll extends Base {
    constructor(client, data, message) {
      super(client);
      Object.defineProperty(this, "message", { value: message });
      this.question = {
        text: data.question.text
      };
      this.answers = data.answers.reduce((acc, answer) => acc.set(answer.answer_id, new PollAnswer(this.client, answer, this)), new Collection);
      this.expiresTimestamp = Date.parse(data.expiry);
      this.allowMultiselect = data.allow_multiselect;
      this.layoutType = data.layout_type;
      this._patch(data);
    }
    _patch(data) {
      if (data.results) {
        this.resultsFinalized = data.results.is_finalized;
        for (const answerResult of data.results.answer_counts) {
          const answer = this.answers.get(answerResult.id);
          answer?._patch(answerResult);
        }
      } else {
        this.resultsFinalized ??= false;
      }
    }
    get expiresAt() {
      return new Date(this.expiresTimestamp);
    }
    async end() {
      if (Date.now() > this.expiresTimestamp) {
        throw new DiscordjsError(ErrorCodes.PollAlreadyExpired);
      }
      return this.message.channel.messages.endPoll(this.message.id);
    }
  }
  exports.Poll = Poll;
});

// node_modules/discord.js/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Collector = require_Collector();
  var Events = require_Events();

  class ReactionCollector extends Collector {
    constructor(message, options = {}) {
      super(message.client, options);
      this.message = message;
      this.users = new Collection;
      this.total = 0;
      this.empty = this.empty.bind(this);
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
      const bulkDeleteListener = (messages) => {
        if (messages.has(this.message.id))
          this.stop("messageDelete");
      };
      this.client.incrementMaxListeners();
      this.client.on(Events.MessageReactionAdd, this.handleCollect);
      this.client.on(Events.MessageReactionRemove, this.handleDispose);
      this.client.on(Events.MessageReactionRemoveAll, this.empty);
      this.client.on(Events.MessageDelete, this._handleMessageDeletion);
      this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
      this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events.MessageReactionAdd, this.handleCollect);
        this.client.removeListener(Events.MessageReactionRemove, this.handleDispose);
        this.client.removeListener(Events.MessageReactionRemoveAll, this.empty);
        this.client.removeListener(Events.MessageDelete, this._handleMessageDeletion);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (reaction, user) => {
        if (reaction.count === 1) {
          this.emit("create", reaction, user);
        }
        this.total++;
        this.users.set(user.id, user);
      });
      this.on("remove", (_reaction, user) => {
        this.total--;
        if (!this.collected.some((reaction) => reaction.users.cache.has(user.id)))
          this.users.delete(user.id);
      });
    }
    collect(reaction) {
      if (reaction.message.id !== this.message.id)
        return null;
      return ReactionCollector.key(reaction);
    }
    dispose(reaction, user) {
      if (reaction.message.id !== this.message.id)
        return null;
      if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {
        this.emit("remove", reaction, user);
      }
      return reaction.count ? null : ReactionCollector.key(reaction);
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    get endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis)
        return "emojiLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return super.endReason;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.message.id) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.message.channelId || channel.threads?.cache.has(this.message.channelId)) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.message.channelId) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.message.guild?.id) {
        this.stop("guildDelete");
      }
    }
    static key(reaction) {
      return reaction.emoji.id ?? reaction.emoji.name;
    }
  }
  module.exports = ReactionCollector;
});

// node_modules/discord.js/src/structures/Sticker.js
var require_Sticker = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var { Routes } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var { StickerFormatExtensionMap } = require_Constants();

  class Sticker extends Base {
    constructor(client, sticker) {
      super(client);
      this._patch(sticker);
    }
    _patch(sticker) {
      this.id = sticker.id;
      if ("description" in sticker) {
        this.description = sticker.description;
      } else {
        this.description ??= null;
      }
      if ("type" in sticker) {
        this.type = sticker.type;
      } else {
        this.type ??= null;
      }
      if ("format_type" in sticker) {
        this.format = sticker.format_type;
      }
      if ("name" in sticker) {
        this.name = sticker.name;
      }
      if ("pack_id" in sticker) {
        this.packId = sticker.pack_id;
      } else {
        this.packId ??= null;
      }
      if ("tags" in sticker) {
        this.tags = sticker.tags;
      } else {
        this.tags ??= null;
      }
      if ("available" in sticker) {
        this.available = sticker.available;
      } else {
        this.available ??= null;
      }
      if ("guild_id" in sticker) {
        this.guildId = sticker.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("user" in sticker) {
        this.user = this.client.users._add(sticker.user);
      } else {
        this.user ??= null;
      }
      if ("sort_value" in sticker) {
        this.sortValue = sticker.sort_value;
      } else {
        this.sortValue ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get partial() {
      return !this.type;
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return this.client.rest.cdn.sticker(this.id, StickerFormatExtensionMap[this.format]);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.sticker(this.id));
      this._patch(data);
      return this;
    }
    async fetchPack() {
      if (!this.packId)
        return null;
      return this.client.fetchStickerPacks({ packId: this.packId });
    }
    async fetchUser() {
      if (this.partial)
        await this.fetch();
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSticker);
      return this.guild.stickers.fetchUser(this);
    }
    edit(options) {
      return this.guild.stickers.edit(this, options);
    }
    async delete(reason) {
      await this.guild.stickers.delete(this, reason);
      return this;
    }
    equals(other) {
      if (other instanceof Sticker) {
        return other.id === this.id && other.description === this.description && other.type === this.type && other.format === this.format && other.name === this.name && other.packId === this.packId && other.tags === this.tags && other.available === this.available && other.guildId === this.guildId && other.sortValue === this.sortValue;
      } else {
        return other.id === this.id && other.description === this.description && other.name === this.name && other.tags === this.tags;
      }
    }
  }
  exports.Sticker = Sticker;
});

// node_modules/discord.js/src/structures/BaseGuildEmoji.js
var require_BaseGuildEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class BaseGuildEmoji extends Emoji {
    constructor(client, data, guild) {
      super(client, data);
      this.guild = guild;
      this.requiresColons = null;
      this.managed = null;
      this.available = null;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data)
        this.name = data.name;
      if ("require_colons" in data) {
        this.requiresColons = data.require_colons;
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("available" in data) {
        this.available = data.available;
      }
    }
  }
  module.exports = BaseGuildEmoji;
});

// node_modules/discord.js/src/managers/GuildEmojiRoleManager.js
var require_GuildEmojiRoleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var DataManager = require_DataManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { Role } = require_Role();

  class GuildEmojiRoleManager extends DataManager {
    constructor(emoji) {
      super(emoji.client, Role);
      this.emoji = emoji;
      this.guild = emoji.guild;
    }
    get cache() {
      return this.guild.roles.cache.filter((role) => this.emoji._roles.includes(role.id));
    }
    async add(roleOrRoles) {
      if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection))
        roleOrRoles = [roleOrRoles];
      const resolvedRoles = [];
      for (const role of roleOrRoles.values()) {
        const resolvedRole = this.guild.roles.resolveId(role);
        if (!resolvedRole) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
        }
        resolvedRoles.push(resolvedRole);
      }
      const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
      return this.set(newRoles);
    }
    async remove(roleOrRoles) {
      if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection))
        roleOrRoles = [roleOrRoles];
      const resolvedRoleIds = [];
      for (const role of roleOrRoles.values()) {
        const roleId = this.guild.roles.resolveId(role);
        if (!roleId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
        }
        resolvedRoleIds.push(roleId);
      }
      const newRoles = [...this.cache.keys()].filter((id) => !resolvedRoleIds.includes(id));
      return this.set(newRoles);
    }
    set(roles) {
      return this.emoji.edit({ roles });
    }
    clone() {
      const clone = new this.constructor(this.emoji);
      clone._patch([...this.cache.keys()]);
      return clone;
    }
    _patch(roles) {
      this.emoji._roles = roles;
    }
    valueOf() {
      return this.cache;
    }
  }
  module.exports = GuildEmojiRoleManager;
});

// node_modules/discord.js/src/structures/GuildEmoji.js
var require_GuildEmoji = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BaseGuildEmoji = require_BaseGuildEmoji();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var GuildEmojiRoleManager = require_GuildEmojiRoleManager();

  class GuildEmoji extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.author = null;
      Object.defineProperty(this, "_roles", { value: [], writable: true });
      this._patch(data);
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    _patch(data) {
      super._patch(data);
      if (data.user)
        this.author = this.client.users._add(data.user);
      if (data.roles)
        this._roles = data.roles;
    }
    get deletable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return !this.managed && this.guild.members.me.permissions.has(PermissionFlagsBits.ManageGuildExpressions);
    }
    get roles() {
      return new GuildEmojiRoleManager(this);
    }
    fetchAuthor() {
      return this.guild.emojis.fetchAuthor(this);
    }
    edit(options) {
      return this.guild.emojis.edit(this.id, options);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    async delete(reason) {
      await this.guild.emojis.delete(this.id, reason);
      return this;
    }
    equals(other) {
      if (other instanceof GuildEmoji) {
        return other.id === this.id && other.name === this.name && other.managed === this.managed && other.available === this.available && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every((role) => this.roles.cache.has(role.id));
      } else {
        return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every((role) => this.roles.cache.has(role));
      }
    }
  }
  module.exports = GuildEmoji;
});

// node_modules/discord.js/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();
  var { flatten } = require_Util();

  class ReactionEmoji extends Emoji {
    constructor(reaction, emoji) {
      super(reaction.message.client, emoji);
      this.reaction = reaction;
    }
    toJSON() {
      return flatten(this, { identifier: true });
    }
    valueOf() {
      return this.id;
    }
  }
  module.exports = ReactionEmoji;
});

// node_modules/discord.js/src/util/UserFlagsBitField.js
var require_UserFlagsBitField = __commonJS((exports, module) => {
  var { UserFlags } = require_v106();
  var BitField = require_BitField();

  class UserFlagsBitField extends BitField {
    static Flags = UserFlags;
  }
  module.exports = UserFlagsBitField;
});

// node_modules/discord.js/src/structures/User.js
var require_User = __commonJS((exports, module) => {
  var { userMention } = require_dist7();
  var { calculateUserDefaultAvatarIndex } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var TextBasedChannel = require_TextBasedChannel();
  var UserFlagsBitField = require_UserFlagsBitField();
  var { emitDeprecationWarningForUserFetchFlags } = require_Util();

  class User extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.bot = null;
      this.system = null;
      this.flags = null;
      this._patch(data);
    }
    _patch(data) {
      if ("username" in data) {
        this.username = data.username;
      } else {
        this.username ??= null;
      }
      if ("global_name" in data) {
        this.globalName = data.global_name;
      } else {
        this.globalName ??= null;
      }
      if ("bot" in data) {
        this.bot = Boolean(data.bot);
      } else if (!this.partial && typeof this.bot !== "boolean") {
        this.bot = false;
      }
      if ("discriminator" in data) {
        this.discriminator = data.discriminator;
      } else {
        this.discriminator ??= null;
      }
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else {
        this.avatar ??= null;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      } else if (this.banner !== null) {
        this.banner ??= undefined;
      }
      if ("accent_color" in data) {
        this.accentColor = data.accent_color;
      } else if (this.accentColor !== null) {
        this.accentColor ??= undefined;
      }
      if ("system" in data) {
        this.system = Boolean(data.system);
      } else if (!this.partial && typeof this.system !== "boolean") {
        this.system = false;
      }
      if ("public_flags" in data) {
        this.flags = new UserFlagsBitField(data.public_flags);
      }
      if ("avatar_decoration" in data) {
        this.avatarDecoration = data.avatar_decoration;
      } else {
        this.avatarDecoration ??= null;
      }
      if (data.avatar_decoration_data) {
        this.avatarDecorationData = {
          asset: data.avatar_decoration_data.asset,
          skuId: data.avatar_decoration_data.sku_id
        };
      } else {
        this.avatarDecorationData = null;
      }
    }
    get partial() {
      return typeof this.username !== "string";
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
    }
    avatarDecorationURL(options = {}) {
      if (this.avatarDecorationData) {
        return this.client.rest.cdn.avatarDecoration(this.avatarDecorationData.asset);
      }
      return this.avatarDecoration && this.client.rest.cdn.avatarDecoration(this.id, this.avatarDecoration, options);
    }
    get defaultAvatarURL() {
      const index = this.discriminator === "0" ? calculateUserDefaultAvatarIndex(this.id) : this.discriminator % 5;
      return this.client.rest.cdn.defaultAvatar(index);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) ?? this.defaultAvatarURL;
    }
    get hexAccentColor() {
      if (typeof this.accentColor !== "number")
        return this.accentColor;
      return `#${this.accentColor.toString(16).padStart(6, "0")}`;
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
    }
    get tag() {
      return typeof this.username === "string" ? this.discriminator === "0" ? this.username : `${this.username}#${this.discriminator}` : null;
    }
    get displayName() {
      return this.globalName ?? this.username;
    }
    get dmChannel() {
      return this.client.users.dmChannel(this.id);
    }
    createDM(force = false) {
      return this.client.users.createDM(this.id, { force });
    }
    deleteDM() {
      return this.client.users.deleteDM(this.id);
    }
    equals(user) {
      return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.globalName && this.avatar === user.avatar && this.flags?.bitfield === user.flags?.bitfield && this.banner === user.banner && this.accentColor === user.accentColor && this.avatarDecoration === user.avatarDecoration && this.avatarDecorationData?.asset === user.avatarDecorationData?.asset && this.avatarDecorationData?.skuId === user.avatarDecorationData?.skuId;
    }
    _equals(user) {
      return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.global_name && this.avatar === user.avatar && this.flags?.bitfield === user.public_flags && ("banner" in user ? this.banner === user.banner : true) && ("accent_color" in user ? this.accentColor === user.accent_color : true) && ("avatar_decoration" in user ? this.avatarDecoration === user.avatar_decoration : true) && ("avatar_decoration_data" in user ? this.avatarDecorationData?.asset === user.avatar_decoration_data?.asset && this.avatarDecorationData?.skuId === user.avatar_decoration_data?.sku_id : true);
    }
    fetchFlags(force = false) {
      emitDeprecationWarningForUserFetchFlags(this.constructor.name);
      return this.client.users.fetchFlags(this.id, { force });
    }
    fetch(force = true) {
      return this.client.users.fetch(this.id, { force });
    }
    toString() {
      return userMention(this.id);
    }
    toJSON(...props) {
      const json = super.toJSON({
        createdTimestamp: true,
        defaultAvatarURL: true,
        hexAccentColor: true,
        tag: true
      }, ...props);
      json.avatarURL = this.avatarURL();
      json.displayAvatarURL = this.displayAvatarURL();
      json.bannerURL = this.banner ? this.bannerURL() : this.banner;
      return json;
    }
  }
  TextBasedChannel.applyToClass(User);
  module.exports = User;
});

// node_modules/discord.js/src/managers/ReactionUserManager.js
var require_ReactionUserManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { ReactionType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var User = require_User();

  class ReactionUserManager extends CachedManager {
    constructor(reaction, iterable) {
      super(reaction.client, User, iterable);
      this.reaction = reaction;
    }
    async fetch({ type = ReactionType.Normal, limit = 100, after } = {}) {
      const message = this.reaction.message;
      const query = makeURLSearchParams({ limit, after, type });
      const data = await this.client.rest.get(Routes.channelMessageReaction(message.channelId, message.id, this.reaction.emoji.identifier), { query });
      const users = new Collection;
      for (const rawUser of data) {
        const user = this.client.users._add(rawUser);
        this.cache.set(user.id, user);
        users.set(user.id, user);
      }
      return users;
    }
    async remove(user = this.client.user) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        throw new DiscordjsError(ErrorCodes.ReactionResolveUser);
      const message = this.reaction.message;
      const route = userId === this.client.user.id ? Routes.channelMessageOwnReaction(message.channelId, message.id, this.reaction.emoji.identifier) : Routes.channelMessageUserReaction(message.channelId, message.id, this.reaction.emoji.identifier, userId);
      await this.client.rest.delete(route);
      return this.reaction;
    }
  }
  module.exports = ReactionUserManager;
});

// node_modules/discord.js/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var ApplicationEmoji = require_ApplicationEmoji();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var ReactionUserManager = require_ReactionUserManager();
  var { flatten } = require_Util();

  class MessageReaction {
    constructor(client, data, message) {
      Object.defineProperty(this, "client", { value: client });
      this.message = message;
      this.me = data.me;
      this.meBurst = Boolean(data.me_burst);
      this.users = new ReactionUserManager(this, this.me ? [client.user] : []);
      this._emoji = new ReactionEmoji(this, data.emoji);
      this.burstColors = null;
      this._patch(data);
    }
    _patch(data) {
      if (data.burst_colors) {
        this.burstColors = data.burst_colors;
      }
      if ("count" in data) {
        this.count ??= data.count;
      }
      if ("count_details" in data) {
        this.countDetails = {
          burst: data.count_details.burst,
          normal: data.count_details.normal
        };
      } else {
        this.countDetails ??= { burst: 0, normal: 0 };
      }
    }
    react() {
      return this.message.react(this.emoji);
    }
    async remove() {
      await this.client.rest.delete(Routes.channelMessageReaction(this.message.channelId, this.message.id, this._emoji.identifier));
      return this;
    }
    get emoji() {
      if (this._emoji instanceof GuildEmoji)
        return this._emoji;
      if (this._emoji instanceof ApplicationEmoji)
        return this._emoji;
      if (this._emoji.id) {
        const applicationEmojis = this.message.client.application.emojis.cache;
        if (applicationEmojis.has(this._emoji.id)) {
          const emoji = applicationEmojis.get(this._emoji.id);
          this._emoji = emoji;
          return emoji;
        }
        const emojis = this.message.client.emojis.cache;
        if (emojis.has(this._emoji.id)) {
          const emoji = emojis.get(this._emoji.id);
          this._emoji = emoji;
          return emoji;
        }
      }
      return this._emoji;
    }
    get partial() {
      return this.count === null;
    }
    async fetch() {
      const message = await this.message.fetch();
      const existing = message.reactions.cache.get(this.emoji.id ?? this.emoji.name);
      this._patch(existing ?? { count: 0 });
      return this;
    }
    toJSON() {
      return flatten(this, { emoji: "emojiId", message: "messageId" });
    }
    valueOf() {
      return this._emoji.id ?? this._emoji.name;
    }
    _add(user, burst) {
      if (this.partial)
        return;
      this.users.cache.set(user.id, user);
      if (!this.me || user.id !== this.message.client.user.id || this.count === 0) {
        this.count++;
        if (burst)
          this.countDetails.burst++;
        else
          this.countDetails.normal++;
      }
      if (user.id === this.message.client.user.id) {
        if (burst)
          this.meBurst = true;
        else
          this.me = true;
      }
    }
    _remove(user, burst) {
      if (this.partial)
        return;
      this.users.cache.delete(user.id);
      if (!this.me || user.id !== this.message.client.user.id) {
        this.count--;
        if (burst)
          this.countDetails.burst--;
        else
          this.countDetails.normal--;
      }
      if (user.id === this.message.client.user.id) {
        if (burst)
          this.meBurst = false;
        else
          this.me = false;
      }
      if (this.count <= 0 && this.users.cache.size === 0) {
        this.message.reactions.cache.delete(this.emoji.id ?? this.emoji.name);
      }
    }
  }
  module.exports = MessageReaction;
});

// node_modules/discord.js/src/managers/ReactionManager.js
var require_ReactionManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var MessageReaction = require_MessageReaction();

  class ReactionManager extends CachedManager {
    constructor(message, iterable) {
      super(message.client, MessageReaction, iterable);
      this.message = message;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.emoji.id ?? data.emoji.name, extras: [this.message] });
    }
    async removeAll() {
      await this.client.rest.delete(Routes.channelMessageAllReactions(this.message.channelId, this.message.id));
      return this.message;
    }
  }
  module.exports = ReactionManager;
});

// node_modules/discord.js/src/structures/Component.js
var require_Component = __commonJS((exports, module) => {
  var isEqual = require_fast_deep_equal();

  class Component {
    constructor(data) {
      this.data = data;
    }
    get id() {
      return this.data.id;
    }
    get type() {
      return this.data.type;
    }
    equals(other) {
      if (other instanceof Component) {
        return isEqual(other.data, this.data);
      }
      return isEqual(other, this.data);
    }
    toJSON() {
      return { ...this.data };
    }
  }
  module.exports = Component;
});

// node_modules/discord.js/src/structures/ActionRow.js
var require_ActionRow = __commonJS((exports, module) => {
  var { deprecate } = import.meta.require("util");
  var { isJSONEncodable } = require_dist();
  var Component = require_Component();
  var { createComponent } = require_Components();

  class ActionRow extends Component {
    constructor({ components, ...data }) {
      super(data);
      this.components = components.map((component) => createComponent(component));
    }
    static from = deprecate((other) => new this(isJSONEncodable(other) ? other.toJSON() : other), "ActionRow.from() is deprecated. Use ActionRowBuilder.from() instead.");
    toJSON() {
      return { ...this.data, components: this.components.map((component) => component.toJSON()) };
    }
  }
  module.exports = ActionRow;
});

// node_modules/discord.js/src/structures/ActionRowBuilder.js
var require_ActionRowBuilder = __commonJS((exports, module) => {
  var { ActionRowBuilder: BuildersActionRow } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { createComponentBuilder } = require_Components();
  var { toSnakeCase } = require_Transformers();

  class ActionRowBuilder extends BuildersActionRow {
    constructor({ components, ...data } = {}) {
      super({
        ...toSnakeCase(data),
        components: components?.map((component) => createComponentBuilder(component))
      });
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ActionRowBuilder;
});

// node_modules/discord.js/src/structures/ButtonBuilder.js
var require_ButtonBuilder = __commonJS((exports, module) => {
  var { ButtonBuilder: BuildersButton } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class ButtonBuilder extends BuildersButton {
    constructor({ emoji, ...data } = {}) {
      super(toSnakeCase({ ...data, emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji }));
    }
    setEmoji(emoji) {
      if (typeof emoji === "string") {
        return super.setEmoji(resolvePartialEmoji(emoji));
      }
      return super.setEmoji(emoji);
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ButtonBuilder;
});

// node_modules/discord.js/src/structures/ButtonComponent.js
var require_ButtonComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class ButtonComponent extends Component {
    get style() {
      return this.data.style;
    }
    get label() {
      return this.data.label ?? null;
    }
    get emoji() {
      return this.data.emoji ?? null;
    }
    get disabled() {
      return this.data.disabled ?? false;
    }
    get customId() {
      return this.data.custom_id ?? null;
    }
    get url() {
      return this.data.url ?? null;
    }
  }
  module.exports = ButtonComponent;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuBuilder.js
var require_ChannelSelectMenuBuilder = __commonJS((exports, module) => {
  var { ChannelSelectMenuBuilder: BuildersChannelSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class ChannelSelectMenuBuilder extends BuildersChannelSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ChannelSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/BaseSelectMenuComponent.js
var require_BaseSelectMenuComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class BaseSelectMenuComponent extends Component {
    get placeholder() {
      return this.data.placeholder ?? null;
    }
    get maxValues() {
      return this.data.max_values ?? null;
    }
    get minValues() {
      return this.data.min_values ?? null;
    }
    get customId() {
      return this.data.custom_id;
    }
    get disabled() {
      return this.data.disabled ?? false;
    }
  }
  module.exports = BaseSelectMenuComponent;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuComponent.js
var require_ChannelSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class ChannelSelectMenuComponent extends BaseSelectMenuComponent {
    get channelTypes() {
      return this.data.channel_types ?? null;
    }
  }
  module.exports = ChannelSelectMenuComponent;
});

// node_modules/discord.js/src/structures/ContainerComponent.js
var require_ContainerComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var { createComponent } = require_Components();

  class ContainerComponent extends Component {
    constructor({ components, ...data }) {
      super(data);
      this.components = components.map((component) => createComponent(component));
    }
    get accentColor() {
      return this.data.accent_color ?? null;
    }
    get hexAccentColor() {
      return typeof this.data.accent_color === "number" ? `#${this.data.accent_color.toString(16).padStart(6, "0")}` : this.data.accent_color ?? null;
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, components: this.components.map((component) => component.toJSON()) };
    }
  }
  module.exports = ContainerComponent;
});

// node_modules/discord.js/src/structures/UnfurledMediaItem.js
var require_UnfurledMediaItem = __commonJS((exports, module) => {
  class UnfurledMediaItem {
    constructor(data) {
      this.data = data;
    }
    get url() {
      return this.data.url;
    }
    toJSON() {
      return { ...this.data };
    }
  }
  module.exports = UnfurledMediaItem;
});

// node_modules/discord.js/src/structures/FileComponent.js
var require_FileComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var UnfurledMediaItem = require_UnfurledMediaItem();

  class FileComponent extends Component {
    constructor({ file, ...data }) {
      super(data);
      this.file = new UnfurledMediaItem(file);
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, file: this.file.toJSON() };
    }
  }
  module.exports = FileComponent;
});

// node_modules/discord.js/src/structures/MediaGalleryItem.js
var require_MediaGalleryItem = __commonJS((exports, module) => {
  var UnfurledMediaItem = require_UnfurledMediaItem();

  class MediaGalleryItem {
    constructor({ media, ...data }) {
      this.data = data;
      this.media = new UnfurledMediaItem(media);
    }
    get description() {
      return this.data.description ?? null;
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, media: this.media.toJSON() };
    }
  }
  module.exports = MediaGalleryItem;
});

// node_modules/discord.js/src/structures/MediaGalleryComponent.js
var require_MediaGalleryComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var MediaGalleryItem = require_MediaGalleryItem();

  class MediaGalleryComponent extends Component {
    constructor({ items, ...data }) {
      super(data);
      this.items = items.map((item) => new MediaGalleryItem(item));
    }
    toJSON() {
      return { ...this.data, items: this.items.map((item) => item.toJSON()) };
    }
  }
  module.exports = MediaGalleryComponent;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuBuilder.js
var require_MentionableSelectMenuBuilder = __commonJS((exports, module) => {
  var { MentionableSelectMenuBuilder: BuildersMentionableSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class MentionableSelectMenuBuilder extends BuildersMentionableSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = MentionableSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuComponent.js
var require_MentionableSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class MentionableSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = MentionableSelectMenuComponent;
});

// node_modules/discord.js/src/structures/RoleSelectMenuBuilder.js
var require_RoleSelectMenuBuilder = __commonJS((exports, module) => {
  var { RoleSelectMenuBuilder: BuildersRoleSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class RoleSelectMenuBuilder extends BuildersRoleSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = RoleSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/RoleSelectMenuComponent.js
var require_RoleSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class RoleSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = RoleSelectMenuComponent;
});

// node_modules/discord.js/src/structures/SectionComponent.js
var require_SectionComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var { createComponent } = require_Components();

  class SectionComponent extends Component {
    constructor({ accessory, components, ...data }) {
      super(data);
      this.components = components.map((component) => createComponent(component));
      this.accessory = createComponent(accessory);
    }
    toJSON() {
      return {
        ...this.data,
        accessory: this.accessory.toJSON(),
        components: this.components.map((component) => component.toJSON())
      };
    }
  }
  module.exports = SectionComponent;
});

// node_modules/discord.js/src/structures/SeparatorComponent.js
var require_SeparatorComponent = __commonJS((exports, module) => {
  var { SeparatorSpacingSize } = require_v106();
  var Component = require_Component();

  class SeparatorComponent extends Component {
    get spacing() {
      return this.data.spacing ?? SeparatorSpacingSize.Small;
    }
    get divider() {
      return this.data.divider ?? true;
    }
  }
  module.exports = SeparatorComponent;
});

// node_modules/discord.js/src/structures/StringSelectMenuBuilder.js
var require_StringSelectMenuBuilder = __commonJS((exports, module) => {
  var { SelectMenuBuilder: BuildersSelectMenu, normalizeArray } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class StringSelectMenuBuilder extends BuildersSelectMenu {
    constructor({ options, ...data } = {}) {
      super(toSnakeCase({
        ...data,
        options: options?.map(({ emoji, ...option }) => ({
          ...option,
          emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
        }))
      }));
    }
    static normalizeEmoji(selectMenuOption) {
      if (isJSONEncodable(selectMenuOption)) {
        return selectMenuOption;
      }
      const { emoji, ...option } = selectMenuOption;
      return {
        ...option,
        emoji: typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
      };
    }
    addOptions(...options) {
      return super.addOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
    }
    setOptions(...options) {
      return super.setOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
    }
    static from(other) {
      if (isJSONEncodable(other)) {
        return new this(other.toJSON());
      }
      return new this(other);
    }
  }
  module.exports = StringSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/StringSelectMenuComponent.js
var require_StringSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class StringSelectMenuComponent extends BaseSelectMenuComponent {
    get options() {
      return this.data.options;
    }
  }
  module.exports = StringSelectMenuComponent;
});

// node_modules/discord.js/src/structures/TextDisplayComponent.js
var require_TextDisplayComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class TextDisplayComponent extends Component {
    get content() {
      return this.data.content;
    }
  }
  module.exports = TextDisplayComponent;
});

// node_modules/discord.js/src/structures/TextInputBuilder.js
var require_TextInputBuilder = __commonJS((exports, module) => {
  var { TextInputBuilder: BuildersTextInput } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class TextInputBuilder extends BuildersTextInput {
    constructor(data) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = TextInputBuilder;
});

// node_modules/discord.js/src/structures/TextInputComponent.js
var require_TextInputComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class TextInputComponent extends Component {
    get customId() {
      return this.data.custom_id;
    }
    get value() {
      return this.data.value;
    }
  }
  module.exports = TextInputComponent;
});

// node_modules/discord.js/src/structures/ThumbnailComponent.js
var require_ThumbnailComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var UnfurledMediaItem = require_UnfurledMediaItem();

  class ThumbnailComponent extends Component {
    constructor({ media, ...data }) {
      super(data);
      this.media = new UnfurledMediaItem(media);
    }
    get description() {
      return this.data.description ?? null;
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, media: this.media.toJSON() };
    }
  }
  module.exports = ThumbnailComponent;
});

// node_modules/discord.js/src/structures/UserSelectMenuBuilder.js
var require_UserSelectMenuBuilder = __commonJS((exports, module) => {
  var { UserSelectMenuBuilder: BuildersUserSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class UserSelectMenuBuilder extends BuildersUserSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = UserSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/UserSelectMenuComponent.js
var require_UserSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class UserSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = UserSelectMenuComponent;
});

// node_modules/discord.js/src/util/Components.js
var require_Components = __commonJS((exports, module) => {
  var createComponent = function(data) {
    if (data instanceof Component) {
      return data;
    }
    switch (data.type) {
      case ComponentType.ActionRow:
        return new ActionRow(data);
      case ComponentType.Button:
        return new ButtonComponent(data);
      case ComponentType.StringSelect:
        return new StringSelectMenuComponent(data);
      case ComponentType.TextInput:
        return new TextInputComponent(data);
      case ComponentType.UserSelect:
        return new UserSelectMenuComponent(data);
      case ComponentType.RoleSelect:
        return new RoleSelectMenuComponent(data);
      case ComponentType.MentionableSelect:
        return new MentionableSelectMenuComponent(data);
      case ComponentType.ChannelSelect:
        return new ChannelSelectMenuComponent(data);
      case ComponentType.Container:
        return new ContainerComponent(data);
      case ComponentType.TextDisplay:
        return new TextDisplayComponent(data);
      case ComponentType.File:
        return new FileComponent(data);
      case ComponentType.MediaGallery:
        return new MediaGalleryComponent(data);
      case ComponentType.Section:
        return new SectionComponent(data);
      case ComponentType.Separator:
        return new SeparatorComponent(data);
      case ComponentType.Thumbnail:
        return new ThumbnailComponent(data);
      default:
        return new Component(data);
    }
  };
  var createComponentBuilder = function(data) {
    if (data instanceof ComponentBuilder) {
      return data;
    }
    switch (data.type) {
      case ComponentType.ActionRow:
        return new ActionRowBuilder(data);
      case ComponentType.Button:
        return new ButtonBuilder(data);
      case ComponentType.StringSelect:
        return new StringSelectMenuBuilder(data);
      case ComponentType.TextInput:
        return new TextInputBuilder(data);
      case ComponentType.UserSelect:
        return new UserSelectMenuBuilder(data);
      case ComponentType.RoleSelect:
        return new RoleSelectMenuBuilder(data);
      case ComponentType.MentionableSelect:
        return new MentionableSelectMenuBuilder(data);
      case ComponentType.ChannelSelect:
        return new ChannelSelectMenuBuilder(data);
      default:
        return new ComponentBuilder(data);
    }
  };
  var extractInteractiveComponents = function(component) {
    switch (component.type) {
      case ComponentType.ActionRow:
        return component.components;
      case ComponentType.Section:
        return [...component.components, component.accessory];
      case ComponentType.Container:
        return component.components.flatMap(extractInteractiveComponents);
      default:
        return [component];
    }
  };
  var findComponentByCustomId = function(components, customId) {
    return components.flatMap(extractInteractiveComponents).find((component) => (component.customId ?? component.custom_id) === customId) ?? null;
  };
  var { ComponentBuilder } = require_dist8();
  var { ComponentType } = require_v106();
  module.exports = { createComponent, createComponentBuilder, findComponentByCustomId };
  var ActionRow = require_ActionRow();
  var ActionRowBuilder = require_ActionRowBuilder();
  var ButtonBuilder = require_ButtonBuilder();
  var ButtonComponent = require_ButtonComponent();
  var ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
  var ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
  var Component = require_Component();
  var ContainerComponent = require_ContainerComponent();
  var FileComponent = require_FileComponent();
  var MediaGalleryComponent = require_MediaGalleryComponent();
  var MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
  var MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
  var RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
  var RoleSelectMenuComponent = require_RoleSelectMenuComponent();
  var SectionComponent = require_SectionComponent();
  var SeparatorComponent = require_SeparatorComponent();
  var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  var StringSelectMenuComponent = require_StringSelectMenuComponent();
  var TextDisplayComponent = require_TextDisplayComponent();
  var TextInputBuilder = require_TextInputBuilder();
  var TextInputComponent = require_TextInputComponent();
  var ThumbnailComponent = require_ThumbnailComponent();
  var UserSelectMenuBuilder = require_UserSelectMenuBuilder();
  var UserSelectMenuComponent = require_UserSelectMenuComponent();
});

// node_modules/discord.js/src/structures/Message.js
var require_Message = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { messageLink } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var {
    InteractionType,
    ChannelType,
    MessageType,
    MessageFlags,
    PermissionFlagsBits,
    MessageReferenceType
  } = require_v106();
  var Attachment = require_Attachment();
  var Base = require_Base();
  var ClientApplication = require_ClientApplication();
  var Embed = require_Embed();
  var InteractionCollector = require_InteractionCollector();
  var Mentions = require_MessageMentions();
  var MessagePayload = require_MessagePayload();
  var { Poll } = require_Poll();
  var ReactionCollector = require_ReactionCollector();
  var { Sticker } = require_Sticker();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var ReactionManager = require_ReactionManager();
  var { createComponent, findComponentByCustomId } = require_Components();
  var { NonSystemMessageTypes, MaxBulkDeletableMessageAge, UndeletableMessageTypes } = require_Constants();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();
  var { _transformAPIMessageInteractionMetadata } = require_Transformers();
  var { cleanContent, resolvePartialEmoji, transformResolved } = require_Util();

  class Message extends Base {
    constructor(client, data) {
      super(client);
      this.channelId = data.channel_id;
      this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);
      if ("type" in data) {
        this.type = data.type;
        this.system = !NonSystemMessageTypes.includes(this.type);
      } else {
        this.system ??= null;
        this.type ??= null;
      }
      if ("content" in data) {
        this.content = data.content;
      } else {
        this.content ??= null;
      }
      if ("author" in data) {
        this.author = this.client.users._add(data.author, !data.webhook_id);
      } else {
        this.author ??= null;
      }
      if ("pinned" in data) {
        this.pinned = Boolean(data.pinned);
      } else {
        this.pinned ??= null;
      }
      if ("tts" in data) {
        this.tts = data.tts;
      } else {
        this.tts ??= null;
      }
      if ("nonce" in data) {
        this.nonce = data.nonce;
      } else {
        this.nonce ??= null;
      }
      if ("embeds" in data) {
        this.embeds = data.embeds.map((embed) => new Embed(embed));
      } else {
        this.embeds = this.embeds?.slice() ?? [];
      }
      if ("components" in data) {
        this.components = data.components.map((component) => createComponent(component));
      } else {
        this.components = this.components?.slice() ?? [];
      }
      if ("attachments" in data) {
        this.attachments = new Collection;
        if (data.attachments) {
          for (const attachment of data.attachments) {
            this.attachments.set(attachment.id, new Attachment(attachment));
          }
        }
      } else {
        this.attachments = new Collection(this.attachments);
      }
      if ("sticker_items" in data || "stickers" in data) {
        this.stickers = new Collection((data.sticker_items ?? data.stickers)?.map((sticker) => [sticker.id, new Sticker(this.client, sticker)]));
      } else {
        this.stickers = new Collection(this.stickers);
      }
      if ("position" in data) {
        this.position = data.position;
      } else {
        this.position ??= null;
      }
      if ("role_subscription_data" in data) {
        this.roleSubscriptionData = {
          roleSubscriptionListingId: data.role_subscription_data.role_subscription_listing_id,
          tierName: data.role_subscription_data.tier_name,
          totalMonthsSubscribed: data.role_subscription_data.total_months_subscribed,
          isRenewal: data.role_subscription_data.is_renewal
        };
      } else {
        this.roleSubscriptionData ??= null;
      }
      if ("resolved" in data) {
        this.resolved = transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.resolved);
      } else {
        this.resolved ??= null;
      }
      if (data.edited_timestamp) {
        this.editedTimestamp = Date.parse(data.edited_timestamp);
      } else {
        this.editedTimestamp ??= null;
      }
      if ("reactions" in data) {
        this.reactions = new ReactionManager(this);
        if (data.reactions?.length > 0) {
          for (const reaction of data.reactions) {
            this.reactions._add(reaction);
          }
        }
      } else {
        this.reactions ??= new ReactionManager(this);
      }
      if (!this.mentions) {
        this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels, data.referenced_message?.author);
      } else {
        this.mentions = new Mentions(this, data.mentions ?? this.mentions.users, data.mention_roles ?? this.mentions.roles, data.mention_everyone ?? this.mentions.everyone, data.mention_channels ?? this.mentions.crosspostedChannels, data.referenced_message?.author ?? this.mentions.repliedUser);
      }
      if ("webhook_id" in data) {
        this.webhookId = data.webhook_id;
      } else {
        this.webhookId ??= null;
      }
      if ("application" in data) {
        this.groupActivityApplication = new ClientApplication(this.client, data.application);
      } else {
        this.groupActivityApplication ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      } else {
        this.applicationId ??= null;
      }
      if ("activity" in data) {
        this.activity = {
          partyId: data.activity.party_id,
          type: data.activity.type
        };
      } else {
        this.activity ??= null;
      }
      if ("thread" in data) {
        this.client.channels._add(data.thread, this.guild);
      }
      if (this.member && data.member) {
        this.member._patch(data.member);
      } else if (data.member && this.guild && this.author) {
        this.guild.members._add(Object.assign(data.member, { user: this.author }));
      }
      if ("flags" in data) {
        this.flags = new MessageFlagsBitField(data.flags).freeze();
      } else {
        this.flags = new MessageFlagsBitField(this.flags).freeze();
      }
      if ("message_reference" in data) {
        this.reference = {
          channelId: data.message_reference.channel_id,
          guildId: data.message_reference.guild_id,
          messageId: data.message_reference.message_id,
          type: data.message_reference.type
        };
      } else {
        this.reference ??= null;
      }
      if (data.referenced_message) {
        this.channel?.messages._add({ guild_id: data.message_reference?.guild_id, ...data.referenced_message });
      }
      if (data.interaction_metadata) {
        this.interactionMetadata = _transformAPIMessageInteractionMetadata(this.client, data.interaction_metadata);
      } else {
        this.interactionMetadata ??= null;
      }
      if (data.interaction) {
        this.interaction = {
          id: data.interaction.id,
          type: data.interaction.type,
          commandName: data.interaction.name,
          user: this.client.users._add(data.interaction.user)
        };
      } else {
        this.interaction ??= null;
      }
      if (data.poll) {
        this.poll = new Poll(this.client, data.poll, this);
      } else {
        this.poll ??= null;
      }
      if (data.message_snapshots) {
        this.messageSnapshots = data.message_snapshots.reduce((coll, snapshot) => {
          const channel = this.client.channels.resolve(this.reference.channelId);
          const snapshotData = {
            ...snapshot.message,
            id: this.reference.messageId,
            channel_id: this.reference.channelId,
            guild_id: this.reference.guildId
          };
          return coll.set(this.reference.messageId, channel ? channel.messages._add(snapshotData) : new this.constructor(this.client, snapshotData));
        }, new Collection);
      } else {
        this.messageSnapshots ??= new Collection;
      }
      if (data.call) {
        this.call = {
          endedTimestamp: data.call.ended_timestamp ? Date.parse(data.call.ended_timestamp) : null,
          participants: data.call.participants,
          get endedAt() {
            return this.endedTimestamp && new Date(this.endedTimestamp);
          }
        };
      } else {
        this.call ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get partial() {
      return typeof this.content !== "string" || !this.author;
    }
    get member() {
      return this.guild?.members.resolve(this.author) ?? null;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get editedAt() {
      return this.editedTimestamp && new Date(this.editedTimestamp);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;
    }
    get hasThread() {
      return this.flags.has(MessageFlags.HasThread);
    }
    get thread() {
      return this.channel?.threads?.cache.get(this.id) ?? null;
    }
    get url() {
      return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);
    }
    get cleanContent() {
      return this.content != null && this.channel ? cleanContent(this.content, this.channel) : null;
    }
    createReactionCollector(options = {}) {
      return new ReactionCollector(this, options);
    }
    awaitReactions(options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createReactionCollector(options);
        collector.once("end", (reactions, reason) => {
          if (options.errors?.includes(reason))
            reject(reactions);
          else
            resolve(reactions);
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionType: InteractionType.MessageComponent,
        message: this
      });
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    get editable() {
      const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable) && this.reference?.type !== MessageReferenceType.Forward);
      if (this.channel?.isThread()) {
        if (this.channel.archived)
          return false;
        if (this.channel.locked) {
          const permissions = this.channel.permissionsFor(this.client.user);
          if (!permissions?.has(PermissionFlagsBits.ManageThreads, true))
            return false;
        }
      }
      return precheck;
    }
    get deletable() {
      if (UndeletableMessageTypes.includes(this.type))
        return false;
      if (!this.guild) {
        return this.author.id === this.client.user.id;
      }
      if (!this.channel?.viewable) {
        return false;
      }
      const permissions = this.channel?.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.type !== MessageType.AutoModerationAction && this.author.id === this.client.user.id || permissions.has(PermissionFlagsBits.ManageMessages, false) && !this.guild.members.me.isCommunicationDisabled();
    }
    get bulkDeletable() {
      return (this.inGuild() && Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge && this.deletable && this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageMessages, false)) ?? false;
    }
    get pinnable() {
      const { channel } = this;
      return Boolean(!this.system && (!this.guild || channel?.viewable && channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false)));
    }
    async fetchReference() {
      if (!this.reference)
        throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);
      const { channelId, messageId } = this.reference;
      if (!messageId)
        throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);
      const channel = this.client.channels.resolve(channelId);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      const message = await channel.messages.fetch(messageId);
      return message;
    }
    get crosspostable() {
      const bitfield = PermissionFlagsBits.SendMessages | (this.author.id === this.client.user.id ? PermissionsBitField.DefaultBit : PermissionFlagsBits.ManageMessages);
      const { channel } = this;
      return Boolean(channel?.type === ChannelType.GuildAnnouncement && !this.flags.has(MessageFlags.Crossposted) && this.type === MessageType.Default && !this.poll && channel.viewable && channel.permissionsFor(this.client.user)?.has(bitfield, false));
    }
    async edit(options) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      return this.channel.messages.edit(this, options);
    }
    async crosspost() {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      return this.channel.messages.crosspost(this.id);
    }
    async pin(reason) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.pin(this.id, reason);
      return this;
    }
    async unpin(reason) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.unpin(this.id, reason);
      return this;
    }
    async react(emoji) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.react(this.id, emoji);
      return this.client.actions.MessageReactionAdd.handle({
        [this.client.actions.injectedUser]: this.client.user,
        [this.client.actions.injectedChannel]: this.channel,
        [this.client.actions.injectedMessage]: this,
        emoji: resolvePartialEmoji(emoji)
      }, true).reaction;
    }
    async delete() {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.delete(this.id);
      return this;
    }
    async reply(options) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      let data;
      if (options instanceof MessagePayload) {
        data = options;
      } else {
        data = MessagePayload.create(this, options, {
          reply: {
            messageReference: this,
            failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists
          }
        });
      }
      return this.channel.send(data);
    }
    forward(channel) {
      const resolvedChannel = this.client.channels.resolve(channel);
      if (!resolvedChannel)
        throw new DiscordjsError(ErrorCodes.InvalidType, "channel", "TextBasedChannelResolvable");
      return resolvedChannel.send({
        forward: {
          message: this.id,
          channel: this.channelId,
          guild: this.guildId
        }
      });
    }
    async startThread(options = {}) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {
        throw new DiscordjsError(ErrorCodes.MessageThreadParent);
      }
      if (this.hasThread)
        throw new DiscordjsError(ErrorCodes.MessageExistingThread);
      return this.channel.threads.create({ ...options, startMessage: this });
    }
    async fetch(force = true) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      return this.channel.messages.fetch({ message: this.id, force });
    }
    async fetchWebhook() {
      if (!this.webhookId)
        throw new DiscordjsError(ErrorCodes.WebhookMessage);
      if (this.webhookId === this.applicationId)
        throw new DiscordjsError(ErrorCodes.WebhookApplication);
      return this.client.fetchWebhook(this.webhookId);
    }
    suppressEmbeds(suppress = true) {
      const flags = new MessageFlagsBitField(this.flags.bitfield);
      if (suppress) {
        flags.add(MessageFlags.SuppressEmbeds);
      } else {
        flags.remove(MessageFlags.SuppressEmbeds);
      }
      return this.edit({ flags });
    }
    removeAttachments() {
      return this.edit({ attachments: [] });
    }
    resolveComponent(customId) {
      return findComponentByCustomId(this.components, customId);
    }
    equals(message, rawData) {
      if (!message)
        return false;
      const embedUpdate = !message.author && !message.attachments;
      if (embedUpdate)
        return this.id === message.id && this.embeds.length === message.embeds.length;
      let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.nonce === message.nonce && this.tts === message.tts && this.attachments.size === message.attachments.size && this.embeds.length === message.embeds.length && this.attachments.every((attachment) => message.attachments.has(attachment.id)) && this.embeds.every((embed, index) => embed.equals(message.embeds[index]));
      if (equal && rawData) {
        equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === Date.parse(rawData.timestamp) && this.editedTimestamp === Date.parse(rawData.edited_timestamp);
      }
      return equal;
    }
    inGuild() {
      return Boolean(this.guildId);
    }
    toString() {
      return this.content;
    }
    toJSON() {
      return super.toJSON({
        channel: "channelId",
        author: "authorId",
        groupActivityApplication: "groupActivityApplicationId",
        guild: "guildId",
        cleanContent: true,
        member: false,
        reactions: false
      });
    }
  }
  exports.Message = Message;
});

// node_modules/discord.js/src/structures/Webhook.js
var require_Webhook = __commonJS((exports, module) => {
  var { makeURLSearchParams } = require_dist5();
  var { lazy } = require_dist();
  var { DiscordSnowflake } = require_cjs();
  var { Routes, WebhookType } = require_v106();
  var MessagePayload = require_MessagePayload();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var { resolveImage } = require_DataResolver();
  var getMessage = lazy(() => require_Message().Message);

  class Webhook {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      Object.defineProperty(this, "token", {
        value: data.token ?? null,
        writable: true,
        configurable: true
      });
      if ("avatar" in data) {
        this.avatar = data.avatar;
      }
      this.id = data.id;
      if ("type" in data) {
        this.type = data.type;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("user" in data) {
        this.owner = this.client.users?._add(data.user) ?? data.user;
      } else {
        this.owner ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      } else {
        this.applicationId ??= null;
      }
      if ("source_guild" in data) {
        this.sourceGuild = this.client.guilds?.cache.get(data.source_guild.id) ?? data.source_guild;
      } else {
        this.sourceGuild ??= null;
      }
      if ("source_channel" in data) {
        this.sourceChannel = this.client.channels?.cache.get(data.source_channel?.id) ?? data.source_channel;
      } else {
        this.sourceChannel ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    async send(options) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      let messagePayload;
      if (options instanceof MessagePayload) {
        messagePayload = options.resolveBody();
      } else {
        messagePayload = MessagePayload.create(this, options).resolveBody();
      }
      const { body, files } = await messagePayload.resolveFiles();
      const query = makeURLSearchParams({
        wait: true,
        thread_id: messagePayload.options.threadId,
        with_components: messagePayload.options.withComponents
      });
      const d = await this.client.rest.post(Routes.webhook(this.id, this.token), {
        body,
        files,
        query,
        auth: false
      });
      if (!this.client.channels)
        return d;
      return this.client.channels.cache.get(d.channel_id)?.messages._add(d, false) ?? new (getMessage())(this.client, d);
    }
    async sendSlackMessage(body) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      const data = await this.client.rest.post(Routes.webhookPlatform(this.id, this.token, "slack"), {
        query: makeURLSearchParams({ wait: true }),
        auth: false,
        body
      });
      return data.toString() === "ok";
    }
    async edit({ name = this.name, avatar, channel, reason }) {
      if (avatar && !(typeof avatar === "string" && avatar.startsWith("data:"))) {
        avatar = await resolveImage(avatar);
      }
      channel &&= channel.id ?? channel;
      const data = await this.client.rest.patch(Routes.webhook(this.id, channel ? undefined : this.token), {
        body: { name, avatar, channel_id: channel },
        reason,
        auth: !this.token || Boolean(channel)
      });
      this.name = data.name;
      this.avatar = data.avatar;
      this.channelId = data.channel_id;
      return this;
    }
    async fetchMessage(message, { threadId } = {}) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      const data = await this.client.rest.get(Routes.webhookMessage(this.id, this.token, message), {
        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,
        auth: false
      });
      if (!this.client.channels)
        return data;
      return this.client.channels.cache.get(data.channel_id)?.messages._add(data, false) ?? new (getMessage())(this.client, data);
    }
    async editMessage(message, options) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body, files } = await messagePayload.resolveBody().resolveFiles();
      const query = makeURLSearchParams({
        thread_id: messagePayload.options.threadId,
        with_components: messagePayload.options.withComponents
      });
      const d = await this.client.rest.patch(Routes.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id), {
        body,
        files,
        query,
        auth: false
      });
      const channelManager = this.client.channels;
      if (!channelManager)
        return d;
      const messageManager = channelManager.cache.get(d.channel_id)?.messages;
      if (!messageManager)
        return new (getMessage())(this.client, d);
      const existing = messageManager.cache.get(d.id);
      if (!existing)
        return messageManager._add(d);
      const clone = existing._clone();
      clone._patch(d);
      return clone;
    }
    delete(reason) {
      return this.client.deleteWebhook(this.id, { token: this.token, reason });
    }
    async deleteMessage(message, threadId) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      await this.client.rest.delete(Routes.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id), {
        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,
        auth: false
      });
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.client.options.rest.api + Routes.webhook(this.id, this.token);
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
    }
    isUserCreated() {
      return Boolean(this.type === WebhookType.Incoming && this.owner && !this.owner.bot);
    }
    isApplicationCreated() {
      return this.type === WebhookType.Application;
    }
    isChannelFollower() {
      return this.type === WebhookType.ChannelFollower;
    }
    isIncoming() {
      return this.type === WebhookType.Incoming;
    }
    static applyToClass(structure, ignore = []) {
      for (const prop of [
        "send",
        "sendSlackMessage",
        "fetchMessage",
        "edit",
        "editMessage",
        "delete",
        "deleteMessage",
        "createdTimestamp",
        "createdAt",
        "url"
      ]) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));
      }
    }
  }
  module.exports = Webhook;
});

// node_modules/discord.js/src/client/WebhookClient.js
var require_WebhookClient = __commonJS((exports, module) => {
  var BaseClient = require_BaseClient();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var Webhook = require_Webhook();
  var { parseWebhookURL } = require_Util();

  class WebhookClient extends BaseClient {
    constructor(data, options) {
      super(options);
      Object.defineProperty(this, "client", { value: this });
      let { id, token } = data;
      if ("url" in data) {
        const parsed = parseWebhookURL(data.url);
        if (!parsed) {
          throw new DiscordjsError(ErrorCodes.WebhookURLInvalid);
        }
        ({ id, token } = parsed);
      }
      this.id = id;
      Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
    }
    send() {
    }
    fetchMessage() {
    }
    editMessage() {
    }
    sendSlackMessage() {
    }
    edit() {
    }
    delete() {
    }
    deleteMessage() {
    }
    get createdTimestamp() {
    }
    get createdAt() {
    }
    get url() {
    }
  }
  Webhook.applyToClass(WebhookClient);
  module.exports = WebhookClient;
});

// node_modules/discord.js/src/structures/VoiceState.js
var require_VoiceState = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();

  class VoiceState extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.id = data.user_id;
      this._patch(data);
    }
    _patch(data) {
      if ("deaf" in data) {
        this.serverDeaf = data.deaf;
      } else {
        this.serverDeaf ??= null;
      }
      if ("mute" in data) {
        this.serverMute = data.mute;
      } else {
        this.serverMute ??= null;
      }
      if ("self_deaf" in data) {
        this.selfDeaf = data.self_deaf;
      } else {
        this.selfDeaf ??= null;
      }
      if ("self_mute" in data) {
        this.selfMute = data.self_mute;
      } else {
        this.selfMute ??= null;
      }
      if ("self_video" in data) {
        this.selfVideo = data.self_video;
      } else {
        this.selfVideo ??= null;
      }
      if ("session_id" in data) {
        this.sessionId = data.session_id;
      } else {
        this.sessionId ??= null;
      }
      if ("self_video" in data) {
        this.streaming = data.self_stream ?? false;
      } else {
        this.streaming ??= null;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      } else {
        this.channelId ??= null;
      }
      if ("suppress" in data) {
        this.suppress = data.suppress;
      } else {
        this.suppress ??= null;
      }
      if ("request_to_speak_timestamp" in data) {
        this.requestToSpeakTimestamp = data.request_to_speak_timestamp && Date.parse(data.request_to_speak_timestamp);
      } else {
        this.requestToSpeakTimestamp ??= null;
      }
      return this;
    }
    get member() {
      return this.guild.members.cache.get(this.id) ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get deaf() {
      return this.serverDeaf || this.selfDeaf;
    }
    get mute() {
      return this.serverMute || this.selfMute;
    }
    setMute(mute = true, reason) {
      return this.guild.members.edit(this.id, { mute, reason });
    }
    setDeaf(deaf = true, reason) {
      return this.guild.members.edit(this.id, { deaf, reason });
    }
    disconnect(reason) {
      return this.setChannel(null, reason);
    }
    setChannel(channel, reason) {
      return this.guild.members.edit(this.id, { channel, reason });
    }
    async edit(options) {
      if (this.channel?.type !== ChannelType.GuildStageVoice)
        throw new DiscordjsError(ErrorCodes.VoiceNotStageChannel);
      const target = this.client.user.id === this.id ? "@me" : this.id;
      if (target !== "@me" && options.requestToSpeak !== undefined) {
        throw new DiscordjsError(ErrorCodes.VoiceStateNotOwn);
      }
      if (!["boolean", "undefined"].includes(typeof options.requestToSpeak)) {
        throw new DiscordjsTypeError(ErrorCodes.VoiceStateInvalidType, "requestToSpeak");
      }
      if (!["boolean", "undefined"].includes(typeof options.suppressed)) {
        throw new DiscordjsTypeError(ErrorCodes.VoiceStateInvalidType, "suppressed");
      }
      await this.client.rest.patch(Routes.guildVoiceState(this.guild.id, target), {
        body: {
          channel_id: this.channelId,
          request_to_speak_timestamp: options.requestToSpeak ? new Date().toISOString() : options.requestToSpeak === false ? null : undefined,
          suppress: options.suppressed
        }
      });
      return this;
    }
    fetch(force = true) {
      return this.guild.voiceStates.fetch(this.id, { force });
    }
    setRequestToSpeak(requestToSpeak = true) {
      return this.edit({ requestToSpeak });
    }
    setSuppressed(suppressed = true) {
      return this.edit({ suppressed });
    }
    toJSON() {
      return super.toJSON({
        id: true,
        serverDeaf: true,
        serverMute: true,
        selfDeaf: true,
        selfMute: true,
        sessionId: true,
        channelId: "channel"
      });
    }
  }
  module.exports = VoiceState;
});

// node_modules/discord.js/src/managers/GuildMemberRoleManager.js
var require_GuildMemberRoleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var DataManager = require_DataManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { Role } = require_Role();

  class GuildMemberRoleManager extends DataManager {
    constructor(member) {
      super(member.client, Role);
      this.member = member;
      this.guild = member.guild;
    }
    get cache() {
      const everyone = this.guild.roles.everyone;
      return this.guild.roles.cache.filter((role) => this.member._roles.includes(role.id)).set(everyone.id, everyone);
    }
    get hoist() {
      const hoistedRoles = this.cache.filter((role) => role.hoist);
      if (!hoistedRoles.size)
        return null;
      return hoistedRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get icon() {
      const iconRoles = this.cache.filter((role) => role.icon || role.unicodeEmoji);
      if (!iconRoles.size)
        return null;
      return iconRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get color() {
      const coloredRoles = this.cache.filter((role) => role.color);
      if (!coloredRoles.size)
        return null;
      return coloredRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
    get premiumSubscriberRole() {
      return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
    }
    get botRole() {
      if (!this.member.user.bot)
        return null;
      return this.cache.find((role) => role.tags?.botId === this.member.user.id) ?? null;
    }
    async add(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
        if (roleOrRoles === null) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.rest.put(Routes.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
        const clone = this.member._clone();
        clone._roles = [...this.cache.keys(), roleOrRoles];
        return clone;
      }
    }
    async remove(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = this.cache.filter((role) => !resolvedRoles.includes(role.id));
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
        if (roleOrRoles === null) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
        const clone = this.member._clone();
        const newRoles = this.cache.filter((role) => role.id !== roleOrRoles);
        clone._roles = [...newRoles.keys()];
        return clone;
      }
    }
    set(roles, reason) {
      return this.member.edit({ roles, reason });
    }
    clone() {
      const clone = new this.constructor(this.member);
      clone.member._roles = [...this.cache.keys()];
      return clone;
    }
  }
  module.exports = GuildMemberRoleManager;
});

// node_modules/discord.js/src/util/GuildMemberFlagsBitField.js
var require_GuildMemberFlagsBitField = __commonJS((exports) => {
  var { GuildMemberFlags } = require_v106();
  var BitField = require_BitField();

  class GuildMemberFlagsBitField extends BitField {
    static Flags = GuildMemberFlags;
  }
  exports.GuildMemberFlagsBitField = GuildMemberFlagsBitField;
});

// node_modules/discord.js/src/structures/GuildMember.js
var require_GuildMember = __commonJS((exports) => {
  var { PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var VoiceState = require_VoiceState();
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var GuildMemberRoleManager = require_GuildMemberRoleManager();
  var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();

  class GuildMember extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.joinedTimestamp = null;
      this.premiumSinceTimestamp = null;
      this.nickname = null;
      this.pending = null;
      this.communicationDisabledUntilTimestamp = null;
      Object.defineProperty(this, "_roles", { value: [], writable: true });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users._add(data.user, true);
      }
      if ("nick" in data)
        this.nickname = data.nick;
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else if (typeof this.avatar !== "string") {
        this.avatar = null;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      } else {
        this.banner ??= null;
      }
      if ("joined_at" in data)
        this.joinedTimestamp = Date.parse(data.joined_at);
      if ("premium_since" in data) {
        this.premiumSinceTimestamp = data.premium_since ? Date.parse(data.premium_since) : null;
      }
      if ("roles" in data)
        this._roles = data.roles;
      if ("pending" in data) {
        this.pending = data.pending;
      } else if (!this.partial) {
        this.pending ??= false;
      }
      if ("communication_disabled_until" in data) {
        this.communicationDisabledUntilTimestamp = data.communication_disabled_until && Date.parse(data.communication_disabled_until);
      }
      if ("flags" in data) {
        this.flags = new GuildMemberFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new GuildMemberFlagsBitField().freeze();
      }
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    get partial() {
      return this.joinedTimestamp === null;
    }
    get roles() {
      return new GuildMemberRoleManager(this);
    }
    get voice() {
      return this.guild.voiceStates.cache.get(this.id) ?? new VoiceState(this.guild, { user_id: this.id });
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.guildMemberAvatar(this.guild.id, this.id, this.avatar, options);
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.guildMemberBanner(this.guild.id, this.id, this.banner, options);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) ?? this.user.displayAvatarURL(options);
    }
    displayBannerURL(options) {
      return this.bannerURL(options) ?? this.user.bannerURL(options);
    }
    get joinedAt() {
      return this.joinedTimestamp && new Date(this.joinedTimestamp);
    }
    get communicationDisabledUntil() {
      return this.communicationDisabledUntilTimestamp && new Date(this.communicationDisabledUntilTimestamp);
    }
    get premiumSince() {
      return this.premiumSinceTimestamp && new Date(this.premiumSinceTimestamp);
    }
    get presence() {
      return this.guild.presences.cache.get(this.id) ?? null;
    }
    get displayColor() {
      return this.roles.color?.color ?? 0;
    }
    get displayHexColor() {
      return this.roles.color?.hexColor ?? "#000000";
    }
    get id() {
      return this.user.id;
    }
    get dmChannel() {
      return this.client.users.dmChannel(this.id);
    }
    get displayName() {
      return this.nickname ?? this.user.displayName;
    }
    get permissions() {
      if (this.user.id === this.guild.ownerId)
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      return new PermissionsBitField(this.roles.cache.map((role) => role.permissions)).freeze();
    }
    get manageable() {
      if (this.user.id === this.guild.ownerId)
        return false;
      if (this.user.id === this.client.user.id)
        return false;
      if (this.client.user.id === this.guild.ownerId)
        return true;
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.guild.members.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
    }
    get kickable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.KickMembers);
    }
    get bannable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.BanMembers);
    }
    get moderatable() {
      return !this.permissions.has(PermissionFlagsBits.Administrator) && this.manageable && (this.guild.members.me?.permissions.has(PermissionFlagsBits.ModerateMembers) ?? false);
    }
    isCommunicationDisabled() {
      return this.communicationDisabledUntilTimestamp > Date.now();
    }
    permissionsIn(channel) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      return channel.permissionsFor(this);
    }
    edit(options) {
      return this.guild.members.edit(this, options);
    }
    setFlags(flags, reason) {
      return this.edit({ flags, reason });
    }
    setNickname(nick, reason) {
      return this.edit({ nick, reason });
    }
    createDM(force = false) {
      return this.user.createDM(force);
    }
    deleteDM() {
      return this.user.deleteDM();
    }
    kick(reason) {
      return this.guild.members.kick(this, reason);
    }
    ban(options) {
      return this.guild.bans.create(this, options);
    }
    disableCommunicationUntil(communicationDisabledUntil, reason) {
      return this.edit({ communicationDisabledUntil, reason });
    }
    timeout(timeout, reason) {
      return this.disableCommunicationUntil(timeout && Date.now() + timeout, reason);
    }
    fetch(force = true) {
      return this.guild.members.fetch({ user: this.id, cache: true, force });
    }
    equals(member) {
      return member instanceof this.constructor && this.id === member.id && this.partial === member.partial && this.guild.id === member.guild.id && this.joinedTimestamp === member.joinedTimestamp && this.nickname === member.nickname && this.avatar === member.avatar && this.banner === member.banner && this.pending === member.pending && this.communicationDisabledUntilTimestamp === member.communicationDisabledUntilTimestamp && this.flags.bitfield === member.flags.bitfield && (this._roles === member._roles || this._roles.length === member._roles.length && this._roles.every((role, i) => role === member._roles[i]));
    }
    toString() {
      return this.user.toString();
    }
    toJSON() {
      const json = super.toJSON({
        guild: "guildId",
        user: "userId",
        displayName: true,
        roles: true
      });
      json.avatarURL = this.avatarURL();
      json.bannerURL = this.bannerURL();
      json.displayAvatarURL = this.displayAvatarURL();
      json.displayBannerURL = this.displayBannerURL();
      return json;
    }
  }
  TextBasedChannel.applyToClass(GuildMember);
  exports.GuildMember = GuildMember;
});

// node_modules/discord.js/src/managers/MessageManager.js
var require_MessageManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { Message } = require_Message();
  var MessagePayload = require_MessagePayload();
  var { MakeCacheOverrideSymbol } = require_Symbols();
  var { resolvePartialEmoji } = require_Util();

  class MessageManager extends CachedManager {
    static [MakeCacheOverrideSymbol] = MessageManager;
    constructor(channel, iterable) {
      super(channel.client, Message, iterable);
      this.channel = channel;
    }
    _add(data, cache) {
      return super._add(data, cache);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { message, cache, force } = options;
      const resolvedMessage = this.resolveId(message ?? options);
      if (resolvedMessage)
        return this._fetchSingle({ message: resolvedMessage, cache, force });
      return this._fetchMany(options);
    }
    async _fetchSingle({ message, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(message);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.channelMessage(this.channel.id, message));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.channelMessages(this.channel.id), {
        query: makeURLSearchParams(options)
      });
      return data.reduce((_data, message) => _data.set(message.id, this._add(message, options.cache)), new Collection);
    }
    async fetchPinned(cache = true) {
      const data = await this.client.rest.get(Routes.channelPins(this.channel.id));
      const messages = new Collection;
      for (const message of data)
        messages.set(message.id, this._add(message, cache));
      return messages;
    }
    async edit(message, options) {
      const messageId = this.resolveId(message);
      if (!messageId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      const { body, files } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveBody().resolveFiles();
      const d = await this.client.rest.patch(Routes.channelMessage(this.channel.id, messageId), { body, files });
      const existing = this.cache.get(messageId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      return this._add(d);
    }
    async crosspost(message) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      const data = await this.client.rest.post(Routes.channelMessageCrosspost(this.channel.id, message));
      return this.cache.get(data.id) ?? this._add(data);
    }
    async pin(message, reason) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.put(Routes.channelPin(this.channel.id, message), { reason });
    }
    async unpin(message, reason) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.delete(Routes.channelPin(this.channel.id, message), { reason });
    }
    async react(message, emoji) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      emoji = resolvePartialEmoji(emoji);
      if (!emoji)
        throw new DiscordjsTypeError(ErrorCodes.EmojiType, "emoji", "EmojiIdentifierResolvable");
      const emojiId = emoji.id ? `${emoji.animated ? "a:" : ""}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name);
      await this.client.rest.put(Routes.channelMessageOwnReaction(this.channel.id, message, emojiId));
    }
    async delete(message) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.delete(Routes.channelMessage(this.channel.id, message));
    }
    async endPoll(messageId) {
      const message = await this.client.rest.post(Routes.expirePoll(this.channel.id, messageId));
      return this._add(message, false);
    }
    async fetchPollAnswerVoters({ messageId, answerId, after, limit }) {
      const voters = await this.client.rest.get(Routes.pollAnswerVoters(this.channel.id, messageId, answerId), {
        query: makeURLSearchParams({ limit, after })
      });
      return voters.users.reduce((acc, user) => acc.set(user.id, this.client.users._add(user, false)), new Collection);
    }
  }
  module.exports = MessageManager;
});

// node_modules/discord.js/src/structures/InteractionWebhook.js
var require_InteractionWebhook = __commonJS((exports, module) => {
  var Webhook = require_Webhook();

  class InteractionWebhook {
    constructor(client, id, token) {
      Object.defineProperty(this, "client", { value: client });
      this.id = id;
      Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
    }
    send() {
    }
    fetchMessage() {
    }
    editMessage() {
    }
    deleteMessage() {
    }
    get url() {
    }
  }
  Webhook.applyToClass(InteractionWebhook, ["sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt"]);
  module.exports = InteractionWebhook;
});

// node_modules/discord.js/src/structures/MessagePayload.js
var require_MessagePayload = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = import.meta.require("buffer");
  var { lazy, isJSONEncodable } = require_dist();
  var { DiscordSnowflake } = require_cjs();
  var { MessageFlags, MessageReferenceType } = require_v106();
  var { DiscordjsError, DiscordjsRangeError, ErrorCodes } = require_errors();
  var { resolveFile } = require_DataResolver();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var { basename, verifyString, resolvePartialEmoji } = require_Util();
  var getBaseInteraction = lazy(() => require_BaseInteraction());

  class MessagePayload {
    constructor(target, options) {
      this.target = target;
      this.options = options;
      this.body = null;
      this.files = null;
    }
    get isWebhook() {
      const Webhook = require_Webhook();
      const WebhookClient = require_WebhookClient();
      return this.target instanceof Webhook || this.target instanceof WebhookClient;
    }
    get isUser() {
      const User = require_User();
      const { GuildMember } = require_GuildMember();
      return this.target instanceof User || this.target instanceof GuildMember;
    }
    get isMessage() {
      const { Message } = require_Message();
      return this.target instanceof Message;
    }
    get isMessageManager() {
      const MessageManager = require_MessageManager();
      return this.target instanceof MessageManager;
    }
    get isInteraction() {
      const BaseInteraction = getBaseInteraction();
      const InteractionWebhook = require_InteractionWebhook();
      return this.target instanceof BaseInteraction || this.target instanceof InteractionWebhook;
    }
    makeContent() {
      let content;
      if (this.options.content === null) {
        content = "";
      } else if (this.options.content !== undefined) {
        content = verifyString(this.options.content, DiscordjsRangeError, ErrorCodes.MessageContentType, true);
      }
      return content;
    }
    resolveBody() {
      if (this.body)
        return this;
      const isInteraction = this.isInteraction;
      const isWebhook = this.isWebhook;
      const content = this.makeContent();
      const tts = Boolean(this.options.tts);
      let nonce;
      if (this.options.nonce !== undefined) {
        nonce = this.options.nonce;
        if (typeof nonce === "number" ? !Number.isInteger(nonce) : typeof nonce !== "string") {
          throw new DiscordjsRangeError(ErrorCodes.MessageNonceType);
        }
      }
      let enforce_nonce = Boolean(this.options.enforceNonce);
      if (nonce === undefined) {
        if (this.options.enforceNonce !== false && this.target.client.options.enforceNonce) {
          nonce = DiscordSnowflake.generate().toString();
          enforce_nonce = true;
        } else if (enforce_nonce) {
          throw new DiscordjsError(ErrorCodes.MessageNonceRequired);
        }
      }
      const components = this.options.components?.map((component) => isJSONEncodable(component) ? component.toJSON() : this.target.client.options.jsonTransformer(component));
      let username;
      let avatarURL;
      let threadName;
      let appliedTags;
      if (isWebhook) {
        username = this.options.username ?? this.target.name;
        if (this.options.avatarURL)
          avatarURL = this.options.avatarURL;
        if (this.options.threadName)
          threadName = this.options.threadName;
        if (this.options.appliedTags)
          appliedTags = this.options.appliedTags;
      }
      let flags;
      if (this.options.flags != null) {
        flags = new MessageFlagsBitField(this.options.flags).bitfield;
      }
      if (isInteraction && this.options.ephemeral) {
        flags |= MessageFlags.Ephemeral;
      }
      let allowedMentions = this.options.allowedMentions === undefined ? this.target.client.options.allowedMentions : this.options.allowedMentions;
      if (allowedMentions?.repliedUser !== undefined) {
        allowedMentions = { ...allowedMentions, replied_user: allowedMentions.repliedUser };
        delete allowedMentions.repliedUser;
      }
      let message_reference;
      if (typeof this.options.reply === "object") {
        const reference = this.options.reply.messageReference;
        const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);
        if (message_id) {
          message_reference = {
            message_id,
            fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists
          };
        }
      }
      if (typeof this.options.forward === "object") {
        const reference = this.options.forward.message;
        const channel_id = reference.channelId ?? this.target.client.channels.resolveId(this.options.forward.channel);
        const guild_id = reference.guildId ?? this.target.client.guilds.resolveId(this.options.forward.guild);
        const message_id = this.target.messages.resolveId(reference);
        if (message_id) {
          if (!channel_id)
            throw new DiscordjsError(ErrorCodes.InvalidType, "channelId", "TextBasedChannelResolvable");
          message_reference = {
            type: MessageReferenceType.Forward,
            message_id,
            channel_id,
            guild_id: guild_id ?? undefined
          };
        }
      }
      const attachments = this.options.files?.map((file, index) => ({
        id: index.toString(),
        description: file.description
      }));
      if (Array.isArray(this.options.attachments)) {
        this.options.attachments.push(...attachments ?? []);
      } else {
        this.options.attachments = attachments;
      }
      let poll;
      if (this.options.poll) {
        poll = {
          question: {
            text: this.options.poll.question.text
          },
          answers: this.options.poll.answers.map((answer) => ({
            poll_media: { text: answer.text, emoji: resolvePartialEmoji(answer.emoji) }
          })),
          duration: this.options.poll.duration,
          allow_multiselect: this.options.poll.allowMultiselect,
          layout_type: this.options.poll.layoutType
        };
      }
      this.body = {
        content,
        tts,
        nonce,
        enforce_nonce,
        embeds: this.options.embeds?.map((embed) => isJSONEncodable(embed) ? embed.toJSON() : this.target.client.options.jsonTransformer(embed)),
        components,
        username,
        avatar_url: avatarURL,
        allowed_mentions: this.isMessage && message_reference === undefined && this.target.author.id !== this.target.client.user.id ? undefined : allowedMentions,
        flags,
        message_reference,
        attachments: this.options.attachments,
        sticker_ids: this.options.stickers?.map((sticker) => sticker.id ?? sticker),
        thread_name: threadName,
        applied_tags: appliedTags,
        poll
      };
      return this;
    }
    async resolveFiles() {
      if (this.files)
        return this;
      this.files = await Promise.all(this.options.files?.map((file) => this.constructor.resolveFile(file)) ?? []);
      return this;
    }
    static async resolveFile(fileLike) {
      let attachment;
      let name;
      const findName = (thing) => {
        if (typeof thing === "string") {
          return basename(thing);
        }
        if (thing.path) {
          return basename(thing.path);
        }
        return "file.jpg";
      };
      const ownAttachment = typeof fileLike === "string" || fileLike instanceof Buffer2 || typeof fileLike.pipe === "function";
      if (ownAttachment) {
        attachment = fileLike;
        name = findName(attachment);
      } else {
        attachment = fileLike.attachment;
        name = fileLike.name ?? findName(attachment);
      }
      const { data, contentType } = await resolveFile(attachment);
      return { data, name, contentType };
    }
    static create(target, options, extra = {}) {
      return new this(target, typeof options !== "object" || options === null ? { content: options, ...extra } : { ...options, ...extra });
    }
  }
  module.exports = MessagePayload;
});

// node_modules/discord.js/src/managers/GuildMessageManager.js
var require_GuildMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class GuildMessageManager extends MessageManager {
  }
  module.exports = GuildMessageManager;
});

// node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var { InteractionType, Routes } = require_v106();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors();
  var { MaxBulkDeletableMessageAge } = require_Constants();
  var InteractionCollector = require_InteractionCollector();
  var MessageCollector = require_MessageCollector();
  var MessagePayload = require_MessagePayload();

  class TextBasedChannel {
    constructor() {
      this.messages = new GuildMessageManager(this);
      this.lastMessageId = null;
      this.lastPinTimestamp = null;
    }
    get lastMessage() {
      return this.messages.resolve(this.lastMessageId);
    }
    get lastPinAt() {
      return this.lastPinTimestamp && new Date(this.lastPinTimestamp);
    }
    async send(options) {
      const User = require_User();
      const { GuildMember } = require_GuildMember();
      if (this instanceof User || this instanceof GuildMember) {
        const dm = await this.createDM();
        return dm.send(options);
      }
      let messagePayload;
      if (options instanceof MessagePayload) {
        messagePayload = options.resolveBody();
      } else {
        messagePayload = MessagePayload.create(this, options).resolveBody();
      }
      const { body, files } = await messagePayload.resolveFiles();
      const d = await this.client.rest.post(Routes.channelMessages(this.id), { body, files });
      return this.messages.cache.get(d.id) ?? this.messages._add(d);
    }
    async sendTyping() {
      await this.client.rest.post(Routes.channelTyping(this.id));
    }
    createMessageCollector(options = {}) {
      return new MessageCollector(this, options);
    }
    awaitMessages(options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createMessageCollector(options);
        collector.once("end", (collection, reason) => {
          if (options.errors?.includes(reason)) {
            reject(collection);
          } else {
            resolve(collection);
          }
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionType: InteractionType.MessageComponent,
        channel: this
      });
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    async bulkDelete(messages, filterOld = false) {
      if (Array.isArray(messages) || messages instanceof Collection) {
        let messageIds = messages instanceof Collection ? [...messages.keys()] : messages.map((message) => message.id ?? message);
        if (filterOld) {
          messageIds = messageIds.filter((id) => Date.now() - DiscordSnowflake.timestampFrom(id) < MaxBulkDeletableMessageAge);
        }
        if (messageIds.length === 0)
          return new Collection;
        if (messageIds.length === 1) {
          const message = this.client.actions.MessageDelete.getMessage({
            message_id: messageIds[0]
          }, this);
          await this.client.rest.delete(Routes.channelMessage(this.id, messageIds[0]));
          return message ? new Collection([[message.id, message]]) : new Collection;
        }
        await this.client.rest.post(Routes.channelBulkDelete(this.id), { body: { messages: messageIds } });
        return messageIds.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({
          message_id: id
        }, this)), new Collection);
      }
      if (!isNaN(messages)) {
        const msgs = await this.messages.fetch({ limit: messages });
        return this.bulkDelete(msgs, filterOld);
      }
      throw new DiscordjsTypeError(ErrorCodes.MessageBulkDeleteType);
    }
    fetchWebhooks() {
      return this.guild.channels.fetchWebhooks(this.id);
    }
    createWebhook(options) {
      return this.guild.channels.createWebhook({ channel: this.id, ...options });
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
    setNSFW(nsfw = true, reason) {
      return this.edit({ nsfw, reason });
    }
    static applyToClass(structure, full = false, ignore = []) {
      const props = ["send"];
      if (full) {
        props.push("lastMessage", "lastPinAt", "bulkDelete", "sendTyping", "createMessageCollector", "awaitMessages", "createMessageComponentCollector", "awaitMessageComponent", "fetchWebhooks", "createWebhook", "setRateLimitPerUser", "setNSFW");
      }
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));
      }
    }
  }
  module.exports = TextBasedChannel;
  var GuildMessageManager = require_GuildMessageManager();
});

// node_modules/discord.js/src/managers/DMMessageManager.js
var require_DMMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class DMMessageManager extends MessageManager {
  }
  module.exports = DMMessageManager;
});

// node_modules/discord.js/src/structures/DMChannel.js
var require_DMChannel = __commonJS((exports, module) => {
  var { userMention } = require_dist7();
  var { ChannelType } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var DMMessageManager = require_DMMessageManager();
  var Partials = require_Partials();

  class DMChannel extends BaseChannel {
    constructor(client, data) {
      super(client, data);
      this.type = ChannelType.DM;
      this.messages = new DMMessageManager(this);
    }
    _patch(data) {
      super._patch(data);
      if (data.recipients) {
        const recipient = data.recipients[0];
        this.recipientId = recipient.id;
        if ("username" in recipient || this.client.options.partials.includes(Partials.User)) {
          this.client.users._add(recipient);
        }
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = Date.parse(data.last_pin_timestamp);
      } else {
        this.lastPinTimestamp ??= null;
      }
    }
    get partial() {
      return this.lastMessageId === undefined;
    }
    get recipient() {
      return this.client.users.resolve(this.recipientId);
    }
    fetch(force = true) {
      return this.client.users.createDM(this.recipientId, { force });
    }
    toString() {
      return userMention(this.recipientId);
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
  }
  TextBasedChannel.applyToClass(DMChannel, true, [
    "bulkDelete",
    "fetchWebhooks",
    "createWebhook",
    "setRateLimitPerUser",
    "setNSFW"
  ]);
  module.exports = DMChannel;
});

// node_modules/discord.js/src/managers/GuildForumThreadManager.js
var require_GuildForumThreadManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var ThreadManager = require_ThreadManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var MessagePayload = require_MessagePayload();

  class GuildForumThreadManager extends ThreadManager {
    async create({
      name,
      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
      message,
      reason,
      rateLimitPerUser,
      appliedTags
    } = {}) {
      if (!message) {
        throw new DiscordjsTypeError(ErrorCodes.GuildForumMessageRequired);
      }
      const { body, files } = await (message instanceof MessagePayload ? message : MessagePayload.create(this, message)).resolveBody().resolveFiles();
      const data = await this.client.rest.post(Routes.threads(this.channel.id), {
        body: {
          name,
          auto_archive_duration: autoArchiveDuration,
          rate_limit_per_user: rateLimitPerUser,
          applied_tags: appliedTags,
          message: body
        },
        files,
        reason
      });
      return this.client.actions.ThreadCreate.handle(data).thread;
    }
  }
  module.exports = GuildForumThreadManager;
});

// node_modules/discord.js/src/structures/ThreadOnlyChannel.js
var require_ThreadOnlyChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildForumThreadManager = require_GuildForumThreadManager();
  var { transformAPIGuildForumTag, transformAPIGuildDefaultReaction } = require_Channels();

  class ThreadOnlyChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.threads = new GuildForumThreadManager(this);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("available_tags" in data) {
        this.availableTags = data.available_tags.map((tag) => transformAPIGuildForumTag(tag));
      } else {
        this.availableTags ??= [];
      }
      if ("default_reaction_emoji" in data) {
        this.defaultReactionEmoji = data.default_reaction_emoji ? transformAPIGuildDefaultReaction(data.default_reaction_emoji) : null;
      } else {
        this.defaultReactionEmoji ??= null;
      }
      if ("default_thread_rate_limit_per_user" in data) {
        this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
      } else {
        this.defaultThreadRateLimitPerUser ??= null;
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      } else {
        this.rateLimitPerUser ??= null;
      }
      if ("default_auto_archive_duration" in data) {
        this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
      } else {
        this.defaultAutoArchiveDuration ??= null;
      }
      if ("nsfw" in data) {
        this.nsfw = data.nsfw;
      } else {
        this.nsfw ??= false;
      }
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("default_sort_order" in data) {
        this.defaultSortOrder = data.default_sort_order;
      } else {
        this.defaultSortOrder ??= null;
      }
    }
    setAvailableTags(availableTags, reason) {
      return this.edit({ availableTags, reason });
    }
    setDefaultReactionEmoji(defaultReactionEmoji, reason) {
      return this.edit({ defaultReactionEmoji, reason });
    }
    setDefaultThreadRateLimitPerUser(defaultThreadRateLimitPerUser, reason) {
      return this.edit({ defaultThreadRateLimitPerUser, reason });
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
      return this.edit({ defaultAutoArchiveDuration, reason });
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
    setDefaultSortOrder(defaultSortOrder, reason) {
      return this.edit({ defaultSortOrder, reason });
    }
    createWebhook() {
    }
    fetchWebhooks() {
    }
    setNSFW() {
    }
    setRateLimitPerUser() {
    }
  }
  TextBasedChannel.applyToClass(ThreadOnlyChannel, true, [
    "send",
    "lastMessage",
    "lastPinAt",
    "bulkDelete",
    "sendTyping",
    "createMessageCollector",
    "awaitMessages",
    "createMessageComponentCollector",
    "awaitMessageComponent"
  ]);
  module.exports = ThreadOnlyChannel;
});

// node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js
var require_ThreadMemberFlagsBitField = __commonJS((exports, module) => {
  var BitField = require_BitField();

  class ThreadMemberFlagsBitField extends BitField {
    static Flags = {};
  }
  module.exports = ThreadMemberFlagsBitField;
});

// node_modules/discord.js/src/structures/ThreadMember.js
var require_ThreadMember = __commonJS((exports, module) => {
  var Base = require_Base();
  var ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
  var { emitDeprecationWarningForRemoveThreadMember } = require_Util();

  class ThreadMember extends Base {
    constructor(thread, data, extra = {}) {
      super(thread.client);
      this.thread = thread;
      this.joinedTimestamp = null;
      this.flags = null;
      this.id = data.user_id;
      this._patch(data, extra);
    }
    _patch(data, extra = {}) {
      if ("join_timestamp" in data)
        this.joinedTimestamp = Date.parse(data.join_timestamp);
      if ("flags" in data)
        this.flags = new ThreadMemberFlagsBitField(data.flags).freeze();
      if ("member" in data) {
        this.member = this.thread.guild.members._add(data.member, extra.cache);
      } else {
        this.member ??= null;
      }
    }
    get partial() {
      return this.flags === null;
    }
    get guildMember() {
      return this.member ?? this.thread.guild.members.cache.get(this.id) ?? null;
    }
    get joinedAt() {
      return this.joinedTimestamp && new Date(this.joinedTimestamp);
    }
    get user() {
      return this.client.users.cache.get(this.id) ?? null;
    }
    get manageable() {
      return !this.thread.archived && this.thread.editable;
    }
    async remove(reason) {
      if (reason !== undefined) {
        emitDeprecationWarningForRemoveThreadMember(this.constructor.name);
      }
      await this.thread.members.remove(this.id, reason);
      return this;
    }
  }
  module.exports = ThreadMember;
});

// node_modules/discord.js/src/managers/ThreadMemberManager.js
var require_ThreadMemberManager = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var ThreadMember = require_ThreadMember();
  var { emitDeprecationWarningForRemoveThreadMember } = require_Util();
  var deprecationEmittedForAdd = false;

  class ThreadMemberManager extends CachedManager {
    constructor(thread, iterable) {
      super(thread.client, ThreadMember, iterable);
      this.thread = thread;
    }
    _add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (cache)
        existing?._patch(data, { cache });
      if (existing)
        return existing;
      const member = new ThreadMember(this.thread, data, { cache });
      if (cache)
        this.cache.set(data.user_id, member);
      return member;
    }
    fetchMe(options) {
      return this.fetch({ ...options, member: this.client.user.id });
    }
    get me() {
      return this.cache.get(this.client.user.id) ?? null;
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userId = this.client.users.resolveId(member);
      if (userId)
        return super.cache.get(userId) ?? null;
      return null;
    }
    resolveId(member) {
      const memberResolvable = super.resolveId(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
    async add(member, reason) {
      if (reason !== undefined && !deprecationEmittedForAdd) {
        process2.emitWarning("The reason parameter of ThreadMemberManager#add() is deprecated as Discord does not parse them. It will be removed in the next major version.", "DeprecationWarning");
        deprecationEmittedForAdd = true;
      }
      const id = member === "@me" ? member : this.client.users.resolveId(member);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "member", "UserResolvable");
      await this.client.rest.put(Routes.threadMembers(this.thread.id, id), { reason });
      return id;
    }
    async remove(member, reason) {
      if (reason !== undefined) {
        emitDeprecationWarningForRemoveThreadMember(this.constructor.name);
      }
      const id = member === "@me" ? member : this.client.users.resolveId(member);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "member", "UserResolvable");
      await this.client.rest.delete(Routes.threadMembers(this.thread.id, id), { reason });
      return id;
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { member, withMember, cache, force } = options;
      const resolvedMember = this.resolveId(member ?? options);
      if (resolvedMember)
        return this._fetchSingle({ member: resolvedMember, withMember, cache, force });
      return this._fetchMany(options);
    }
    async _fetchSingle({ member, withMember, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(member);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.threadMembers(this.thread.id, member), {
        query: makeURLSearchParams({ with_member: withMember })
      });
      return this._add(data, cache);
    }
    async _fetchMany({ withMember, after, limit, cache } = {}) {
      const data = await this.client.rest.get(Routes.threadMembers(this.thread.id), {
        query: makeURLSearchParams({ with_member: withMember, after, limit })
      });
      return data.reduce((col, member) => col.set(member.user_id, this._add(member, cache)), new Collection);
    }
  }
  module.exports = ThreadMemberManager;
});

// node_modules/discord.js/src/structures/ThreadChannel.js
var require_ThreadChannel = __commonJS((exports, module) => {
  var { DiscordAPIError } = require_dist5();
  var { lazy } = require_dist();
  var { RESTJSONErrorCodes, ChannelFlags, ChannelType, PermissionFlagsBits, Routes } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var getThreadOnlyChannel = lazy(() => require_ThreadOnlyChannel());
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsRangeError, ErrorCodes } = require_errors();
  var GuildMessageManager = require_GuildMessageManager();
  var ThreadMemberManager = require_ThreadMemberManager();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();

  class ThreadChannel extends BaseChannel {
    constructor(guild, data, client) {
      super(guild?.client ?? client, data, false);
      this.guild = guild;
      this.guildId = guild?.id ?? data.guild_id;
      this.ownerId = data.owner_id;
      this.messages = new GuildMessageManager(this);
      this.members = new ThreadMemberManager(this);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("message" in data)
        this.messages._add(data.message);
      if ("name" in data) {
        this.name = data.name;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("parent_id" in data) {
        this.parentId = data.parent_id;
      } else {
        this.parentId ??= null;
      }
      if ("thread_metadata" in data) {
        this.locked = data.thread_metadata.locked ?? false;
        this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;
        this.archived = data.thread_metadata.archived;
        this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;
        this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);
        if ("create_timestamp" in data.thread_metadata) {
          this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);
        }
      } else {
        this.locked ??= null;
        this.archived ??= null;
        this.autoArchiveDuration ??= null;
        this.archiveTimestamp ??= null;
        this.invitable ??= null;
      }
      this._createdTimestamp ??= this.type === ChannelType.PrivateThread ? super.createdTimestamp : null;
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      } else {
        this.lastMessageId ??= null;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      } else {
        this.lastPinTimestamp ??= null;
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user ?? 0;
      } else {
        this.rateLimitPerUser ??= null;
      }
      if ("message_count" in data) {
        this.messageCount = data.message_count;
      } else {
        this.messageCount ??= null;
      }
      if ("member_count" in data) {
        this.memberCount = data.member_count;
      } else {
        this.memberCount ??= null;
      }
      if ("total_message_sent" in data) {
        this.totalMessageSent = data.total_message_sent;
      } else {
        this.totalMessageSent ??= null;
      }
      if (data.member && this.client.user)
        this.members._add({ user_id: this.client.user.id, ...data.member });
      if (data.messages)
        for (const message of data.messages)
          this.messages._add(message);
      if ("applied_tags" in data) {
        this.appliedTags = data.applied_tags;
      } else {
        this.appliedTags ??= [];
      }
    }
    get createdTimestamp() {
      return this._createdTimestamp;
    }
    get guildMembers() {
      return this.members.cache.mapValues((member) => member.guildMember);
    }
    get archivedAt() {
      return this.archiveTimestamp && new Date(this.archiveTimestamp);
    }
    get createdAt() {
      return this.createdTimestamp && new Date(this.createdTimestamp);
    }
    get parent() {
      return this.guild.channels.resolve(this.parentId);
    }
    async join() {
      await this.members.add("@me");
      return this;
    }
    async leave() {
      await this.members.remove("@me");
      return this;
    }
    permissionsFor(memberOrRole, checkAdmin) {
      return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;
    }
    async fetchOwner(options) {
      const member = await this.members._fetchSingle({ ...options, member: this.ownerId }).catch((error) => {
        if (error instanceof DiscordAPIError && error.code === RESTJSONErrorCodes.UnknownMember) {
          return null;
        }
        throw error;
      });
      return member;
    }
    async fetchStarterMessage(options) {
      const channel = this.parent instanceof getThreadOnlyChannel() ? this : this.parent;
      return channel?.messages.fetch({ message: this.id, ...options }) ?? null;
    }
    async edit(options) {
      const newData = await this.client.rest.patch(Routes.channel(this.id), {
        body: {
          name: (options.name ?? this.name).trim(),
          archived: options.archived,
          auto_archive_duration: options.autoArchiveDuration,
          rate_limit_per_user: options.rateLimitPerUser,
          locked: options.locked,
          invitable: this.type === ChannelType.PrivateThread ? options.invitable : undefined,
          applied_tags: options.appliedTags,
          flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : undefined
        },
        reason: options.reason
      });
      return this.client.actions.ChannelUpdate.handle(newData).updated;
    }
    setArchived(archived = true, reason) {
      return this.edit({ archived, reason });
    }
    setAutoArchiveDuration(autoArchiveDuration, reason) {
      return this.edit({ autoArchiveDuration, reason });
    }
    async setInvitable(invitable = true, reason) {
      if (this.type !== ChannelType.PrivateThread) {
        throw new DiscordjsRangeError(ErrorCodes.ThreadInvitableType, this.type);
      }
      return this.edit({ invitable, reason });
    }
    setLocked(locked = true, reason) {
      return this.edit({ locked, reason });
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
    setAppliedTags(appliedTags, reason) {
      return this.edit({ appliedTags, reason });
    }
    pin(reason) {
      return this.edit({ flags: this.flags.add(ChannelFlags.Pinned), reason });
    }
    unpin(reason) {
      return this.edit({ flags: this.flags.remove(ChannelFlags.Pinned), reason });
    }
    get joined() {
      return this.members.cache.has(this.client.user?.id);
    }
    get editable() {
      return this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined) || this.manageable;
    }
    get joinable() {
      return !this.archived && !this.joined && this.permissionsFor(this.client.user)?.has(this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel, false);
    }
    get manageable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.ManageThreads, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(PermissionFlagsBits.ViewChannel, false);
    }
    get sendable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return !(this.archived && this.locked && !this.manageable) && (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) && permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();
    }
    get unarchivable() {
      return this.archived && this.sendable && (!this.locked || this.manageable);
    }
    async delete(reason) {
      await this.guild.channels.delete(this.id, reason);
      return this;
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
    bulkDelete() {
    }
  }
  TextBasedChannel.applyToClass(ThreadChannel, true, ["fetchWebhooks", "setRateLimitPerUser", "setNSFW"]);
  module.exports = ThreadChannel;
});

// node_modules/discord.js/src/managers/ThreadManager.js
var require_ThreadManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var ThreadChannel = require_ThreadChannel();
  var { MakeCacheOverrideSymbol } = require_Symbols();

  class ThreadManager extends CachedManager {
    static [MakeCacheOverrideSymbol] = ThreadManager;
    constructor(channel, iterable) {
      super(channel.client, ThreadChannel, iterable);
      this.channel = channel;
    }
    _add(thread) {
      const existing = this.cache.get(thread.id);
      if (existing)
        return existing;
      this.cache.set(thread.id, thread);
      return thread;
    }
    fetch(options, { cache, force } = {}) {
      if (!options)
        return this.fetchActive(cache);
      const channel = this.client.channels.resolveId(options);
      if (channel)
        return this.client.channels.fetch(channel, { cache, force });
      if (options.archived) {
        return this.fetchArchived(options.archived, cache);
      }
      return this.fetchActive(cache);
    }
    async fetchArchived({ type = "public", fetchAll = false, before, limit } = {}, cache = true) {
      let path = Routes.channelThreads(this.channel.id, type);
      if (type === "private" && !fetchAll) {
        path = Routes.channelJoinedArchivedThreads(this.channel.id);
      }
      let timestamp;
      let id;
      const query = makeURLSearchParams({ limit });
      if (before !== undefined) {
        if (before instanceof ThreadChannel || /^\d{17,19}$/.test(String(before))) {
          id = this.resolveId(before);
          timestamp = this.resolve(before)?.archivedAt?.toISOString();
          const toUse = type === "private" && !fetchAll ? id : timestamp;
          if (toUse) {
            query.set("before", toUse);
          }
        } else {
          try {
            timestamp = new Date(before).toISOString();
            if (type === "public" || fetchAll) {
              query.set("before", timestamp);
            }
          } catch {
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, "before", "DateResolvable or ThreadChannelResolvable");
          }
        }
      }
      const raw = await this.client.rest.get(path, { query });
      return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });
    }
    async fetchActive(cache = true) {
      const data = await this.channel.guild.channels.rawFetchGuildActiveThreads();
      return this.constructor._mapThreads(data, this.client, { parent: this.channel, cache });
    }
    static _mapThreads(rawThreads, client, { parent, guild, cache }) {
      const threads = rawThreads.threads.reduce((coll, raw) => {
        const thread = client.channels._add(raw, guild ?? parent?.guild, { cache });
        if (parent && thread.parentId !== parent.id)
          return coll;
        return coll.set(thread.id, thread);
      }, new Collection);
      const threadMembers = rawThreads.members.reduce((coll, raw) => {
        const thread = threads.get(raw.id);
        return thread ? coll.set(raw.user_id, thread.members._add(raw)) : coll;
      }, new Collection);
      const response = { threads, members: threadMembers };
      if ("has_more" in rawThreads)
        response.hasMore = rawThreads.has_more;
      return response;
    }
  }
  module.exports = ThreadManager;
});

// node_modules/discord.js/src/managers/GuildTextThreadManager.js
var require_GuildTextThreadManager = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var ThreadManager = require_ThreadManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class GuildTextThreadManager extends ThreadManager {
    async create({
      name,
      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
      startMessage,
      type,
      invitable,
      reason,
      rateLimitPerUser
    } = {}) {
      let resolvedType = this.channel.type === ChannelType.GuildAnnouncement ? ChannelType.AnnouncementThread : ChannelType.PublicThread;
      let startMessageId;
      if (startMessage) {
        startMessageId = this.channel.messages.resolveId(startMessage);
        if (!startMessageId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "startMessage", "MessageResolvable");
      } else if (this.channel.type !== ChannelType.GuildAnnouncement) {
        resolvedType = type ?? resolvedType;
      }
      const data = await this.client.rest.post(Routes.threads(this.channel.id, startMessageId), {
        body: {
          name,
          auto_archive_duration: autoArchiveDuration,
          type: resolvedType,
          invitable: resolvedType === ChannelType.PrivateThread ? invitable : undefined,
          rate_limit_per_user: rateLimitPerUser
        },
        reason
      });
      return this.client.actions.ThreadCreate.handle(data).thread;
    }
  }
  module.exports = GuildTextThreadManager;
});

// node_modules/discord.js/src/structures/BaseGuildTextChannel.js
var require_BaseGuildTextChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildMessageManager = require_GuildMessageManager();
  var GuildTextThreadManager = require_GuildTextThreadManager();

  class BaseGuildTextChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.messages = new GuildMessageManager(this);
      this.threads = new GuildTextThreadManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("nsfw" in data) {
        this.nsfw = Boolean(data.nsfw);
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      }
      if ("default_auto_archive_duration" in data) {
        this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
      }
      if ("default_thread_rate_limit_per_user" in data) {
        this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
      } else {
        this.defaultThreadRateLimitPerUser ??= null;
      }
      if ("messages" in data) {
        for (const message of data.messages)
          this.messages._add(message);
      }
    }
    setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
      return this.edit({ defaultAutoArchiveDuration, reason });
    }
    setType(type, reason) {
      return this.edit({ type, reason });
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache = true) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
    bulkDelete() {
    }
    fetchWebhooks() {
    }
    createWebhook() {
    }
    setRateLimitPerUser() {
    }
    setNSFW() {
    }
  }
  TextBasedChannel.applyToClass(BaseGuildTextChannel, true);
  module.exports = BaseGuildTextChannel;
});

// node_modules/discord.js/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var BaseGuildTextChannel = require_BaseGuildTextChannel();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class NewsChannel extends BaseGuildTextChannel {
    async addFollower(channel, reason) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      await this.client.rest.post(Routes.channelFollowers(this.id), { body: { webhook_channel_id: channelId }, reason });
      return this;
    }
  }
  module.exports = NewsChannel;
});

// node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js
var require_BaseGuildVoiceChannel = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { PermissionFlagsBits } = require_v106();
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildMessageManager = require_GuildMessageManager();

  class BaseGuildVoiceChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.messages = new GuildMessageManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("rtc_region" in data) {
        this.rtcRegion = data.rtc_region;
      }
      if ("bitrate" in data) {
        this.bitrate = data.bitrate;
      }
      if ("user_limit" in data) {
        this.userLimit = data.user_limit;
      }
      if ("video_quality_mode" in data) {
        this.videoQualityMode = data.video_quality_mode;
      } else {
        this.videoQualityMode ??= null;
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("messages" in data) {
        for (const message of data.messages)
          this.messages._add(message);
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      }
      if ("nsfw" in data) {
        this.nsfw = data.nsfw;
      }
    }
    get members() {
      const coll = new Collection;
      for (const state of this.guild.voiceStates.cache.values()) {
        if (state.channelId === this.id && state.member) {
          coll.set(state.id, state.member);
        }
      }
      return coll;
    }
    get full() {
      return this.userLimit > 0 && this.members.size >= this.userLimit;
    }
    get joinable() {
      if (!this.viewable)
        return false;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Connect, false);
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache = true) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    setBitrate(bitrate, reason) {
      return this.edit({ bitrate, reason });
    }
    setRTCRegion(rtcRegion, reason) {
      return this.edit({ rtcRegion, reason });
    }
    setUserLimit(userLimit, reason) {
      return this.edit({ userLimit, reason });
    }
    setVideoQualityMode(videoQualityMode, reason) {
      return this.edit({ videoQualityMode, reason });
    }
    get lastMessage() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
    bulkDelete() {
    }
    fetchWebhooks() {
    }
    createWebhook() {
    }
    setRateLimitPerUser() {
    }
    setNSFW() {
    }
  }
  TextBasedChannel.applyToClass(BaseGuildVoiceChannel, true, ["lastPinAt"]);
  module.exports = BaseGuildVoiceChannel;
});

// node_modules/discord.js/src/structures/StageChannel.js
var require_StageChannel = __commonJS((exports, module) => {
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();

  class StageChannel extends BaseGuildVoiceChannel {
    _patch(data) {
      super._patch(data);
      if ("topic" in data) {
        this.topic = data.topic;
      }
    }
    get stageInstance() {
      return this.guild.stageInstances.cache.find((stageInstance) => stageInstance.channelId === this.id) ?? null;
    }
    createStageInstance(options) {
      return this.guild.stageInstances.create(this.id, options);
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
  }
  module.exports = StageChannel;
});

// node_modules/discord.js/src/structures/TextChannel.js
var require_TextChannel = __commonJS((exports, module) => {
  var BaseGuildTextChannel = require_BaseGuildTextChannel();

  class TextChannel extends BaseGuildTextChannel {
    _patch(data) {
      super._patch(data);
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      }
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
  }
  module.exports = TextChannel;
});

// node_modules/discord.js/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS((exports, module) => {
  var { PermissionFlagsBits, Routes } = require_v106();
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();

  class VoiceChannel extends BaseGuildVoiceChannel {
    get joinable() {
      if (!super.joinable)
        return false;
      if (this.full && !this.permissionsFor(this.client.user).has(PermissionFlagsBits.MoveMembers, false))
        return false;
      return true;
    }
    get speakable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Speak, false);
    }
    async sendSoundboardSound(sound) {
      await this.client.rest.post(Routes.sendSoundboardSound(this.id), {
        body: {
          sound_id: sound.soundId,
          source_guild_id: sound.guildId ?? undefined
        }
      });
    }
  }
  module.exports = VoiceChannel;
});

// node_modules/discord.js/src/structures/DirectoryChannel.js
var require_DirectoryChannel = __commonJS((exports, module) => {
  var { BaseChannel } = require_BaseChannel();

  class DirectoryChannel extends BaseChannel {
    constructor(guild, data, client) {
      super(client, data);
      this.guild = guild;
      this.guildId = guild.id;
    }
    _patch(data) {
      super._patch(data);
      this.name = data.name;
    }
  }
  module.exports = DirectoryChannel;
});

// node_modules/discord.js/src/managers/PartialGroupDMMessageManager.js
var require_PartialGroupDMMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class PartialGroupDMMessageManager extends MessageManager {
  }
  module.exports = PartialGroupDMMessageManager;
});

// node_modules/discord.js/src/structures/PartialGroupDMChannel.js
var require_PartialGroupDMChannel = __commonJS((exports, module) => {
  var { BaseChannel } = require_BaseChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var PartialGroupDMMessageManager = require_PartialGroupDMMessageManager();

  class PartialGroupDMChannel extends BaseChannel {
    constructor(client, data) {
      super(client, data);
      this.flags = null;
      this.name = data.name;
      this.icon = data.icon;
      this.recipients = data.recipients;
      this.messages = new PartialGroupDMMessageManager(this);
      if ("owner_id" in data) {
        this.ownerId = data.owner_id;
      } else {
        this.ownerId ??= null;
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      } else {
        this.lastMessageId ??= null;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      } else {
        this.lastPinTimestamp ??= null;
      }
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.channelIcon(this.id, this.icon, options);
    }
    async fetchOwner(options) {
      if (!this.ownerId) {
        throw new DiscordjsError(ErrorCodes.FetchOwnerId, "group DM");
      }
      return this.client.users.fetch(this.ownerId, options);
    }
    async delete() {
      throw new DiscordjsError(ErrorCodes.DeleteGroupDMChannel);
    }
    async fetch() {
      throw new DiscordjsError(ErrorCodes.FetchGroupDMChannel);
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
  }
  TextBasedChannel.applyToClass(PartialGroupDMChannel, true, [
    "bulkDelete",
    "send",
    "sendTyping",
    "createMessageCollector",
    "awaitMessages",
    "fetchWebhooks",
    "createWebhook",
    "setRateLimitPerUser",
    "setNSFW"
  ]);
  module.exports = PartialGroupDMChannel;
});

// node_modules/discord.js/src/structures/ForumChannel.js
var require_ForumChannel = __commonJS((exports, module) => {
  var ThreadOnlyChannel = require_ThreadOnlyChannel();

  class ForumChannel extends ThreadOnlyChannel {
    _patch(data) {
      super._patch(data);
      this.defaultForumLayout = data.default_forum_layout;
    }
    setDefaultForumLayout(defaultForumLayout, reason) {
      return this.edit({ defaultForumLayout, reason });
    }
  }
  module.exports = ForumChannel;
});

// node_modules/discord.js/src/structures/MediaChannel.js
var require_MediaChannel = __commonJS((exports, module) => {
  var ThreadOnlyChannel = require_ThreadOnlyChannel();

  class MediaChannel extends ThreadOnlyChannel {
  }
  module.exports = MediaChannel;
});

// node_modules/discord.js/src/util/Channels.js
var require_Channels = __commonJS((exports, module) => {
  var createChannel = function(client, data, guild, { allowUnknownGuild } = {}) {
    let channel;
    if (!data.guild_id && !guild) {
      if (data.recipients && data.type !== ChannelType.GroupDM || data.type === ChannelType.DM) {
        channel = new (getDMChannel())(client, data);
      } else if (data.type === ChannelType.GroupDM) {
        channel = new (getPartialGroupDMChannel())(client, data);
      }
    } else {
      guild ??= client.guilds.cache.get(data.guild_id);
      if (guild || allowUnknownGuild) {
        switch (data.type) {
          case ChannelType.GuildText: {
            channel = new (getTextChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildVoice: {
            channel = new (getVoiceChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildCategory: {
            channel = new (getCategoryChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildAnnouncement: {
            channel = new (getNewsChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildStageVoice: {
            channel = new (getStageChannel())(guild, data, client);
            break;
          }
          case ChannelType.AnnouncementThread:
          case ChannelType.PublicThread:
          case ChannelType.PrivateThread: {
            channel = new (getThreadChannel())(guild, data, client);
            if (!allowUnknownGuild)
              channel.parent?.threads.cache.set(channel.id, channel);
            break;
          }
          case ChannelType.GuildDirectory:
            channel = new (getDirectoryChannel())(guild, data, client);
            break;
          case ChannelType.GuildForum:
            channel = new (getForumChannel())(guild, data, client);
            break;
          case ChannelType.GuildMedia:
            channel = new (getMediaChannel())(guild, data, client);
            break;
        }
        if (channel && !allowUnknownGuild)
          guild.channels?.cache.set(channel.id, channel);
      }
    }
    return channel;
  };
  var transformAPIGuildForumTag = function(tag) {
    return {
      id: tag.id,
      name: tag.name,
      moderated: tag.moderated,
      emoji: tag.emoji_id ?? tag.emoji_name ? {
        id: tag.emoji_id,
        name: tag.emoji_name
      } : null
    };
  };
  var transformGuildForumTag = function(tag) {
    return {
      id: tag.id,
      name: tag.name,
      moderated: tag.moderated,
      emoji_id: tag.emoji?.id ?? null,
      emoji_name: tag.emoji?.name ?? null
    };
  };
  var transformAPIGuildDefaultReaction = function(defaultReaction) {
    return {
      id: defaultReaction.emoji_id,
      name: defaultReaction.emoji_name
    };
  };
  var transformGuildDefaultReaction = function(defaultReaction) {
    return {
      emoji_id: defaultReaction.id,
      emoji_name: defaultReaction.name
    };
  };
  var { lazy } = require_dist();
  var { ChannelType } = require_v106();
  var getCategoryChannel = lazy(() => require_CategoryChannel());
  var getDMChannel = lazy(() => require_DMChannel());
  var getNewsChannel = lazy(() => require_NewsChannel());
  var getStageChannel = lazy(() => require_StageChannel());
  var getTextChannel = lazy(() => require_TextChannel());
  var getThreadChannel = lazy(() => require_ThreadChannel());
  var getVoiceChannel = lazy(() => require_VoiceChannel());
  var getDirectoryChannel = lazy(() => require_DirectoryChannel());
  var getPartialGroupDMChannel = lazy(() => require_PartialGroupDMChannel());
  var getForumChannel = lazy(() => require_ForumChannel());
  var getMediaChannel = lazy(() => require_MediaChannel());
  module.exports = {
    createChannel,
    transformAPIGuildForumTag,
    transformGuildForumTag,
    transformAPIGuildDefaultReaction,
    transformGuildDefaultReaction
  };
});

// node_modules/discord.js/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var { createChannel } = require_Channels();

  class ChannelUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      let channel = client.channels.cache.get(data.id);
      if (channel) {
        const old = channel._update(data);
        if (channel.type !== data.type) {
          const newChannel = createChannel(this.client, data, channel.guild);
          if (!newChannel) {
            this.client.channels.cache.delete(channel.id);
            return {};
          }
          if (channel.isTextBased() && newChannel.isTextBased()) {
            for (const [id, message] of channel.messages.cache)
              newChannel.messages.cache.set(id, message);
          }
          channel = newChannel;
          this.client.channels.cache.set(channel.id, channel);
        }
        return {
          old,
          updated: channel
        };
      } else {
        client.channels._add(data);
      }
      return {};
    }
  }
  module.exports = ChannelUpdateAction;
});

// node_modules/discord.js/src/client/actions/EntitlementCreate.js
var require_EntitlementCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class EntitlementCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const entitlement = client.application.entitlements._add(data);
      client.emit(Events.EntitlementCreate, entitlement);
      return {};
    }
  }
  module.exports = EntitlementCreateAction;
});

// node_modules/discord.js/src/client/actions/EntitlementDelete.js
var require_EntitlementDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class EntitlementDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const entitlement = client.application.entitlements._add(data, false);
      client.application.entitlements.cache.delete(entitlement.id);
      client.emit(Events.EntitlementDelete, entitlement);
      return {};
    }
  }
  module.exports = EntitlementDeleteAction;
});

// node_modules/discord.js/src/client/actions/EntitlementUpdate.js
var require_EntitlementUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class EntitlementUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const oldEntitlement = client.application.entitlements.cache.get(data.id)?._clone() ?? null;
      const newEntitlement = client.application.entitlements._add(data);
      client.emit(Events.EntitlementUpdate, oldEntitlement, newEntitlement);
      return {};
    }
  }
  module.exports = EntitlementUpdateAction;
});

// node_modules/discord.js/src/structures/AutoModerationRule.js
var require_AutoModerationRule = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { _transformAPIAutoModerationAction } = require_Transformers();

  class AutoModerationRule extends Base {
    constructor(client, data, guild) {
      super(client);
      this.id = data.id;
      this.guild = guild;
      this.creatorId = data.creator_id;
      this.triggerType = data.trigger_type;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      if ("event_type" in data) {
        this.eventType = data.event_type;
      }
      if ("trigger_metadata" in data) {
        this.triggerMetadata = {
          keywordFilter: data.trigger_metadata.keyword_filter ?? [],
          regexPatterns: data.trigger_metadata.regex_patterns ?? [],
          presets: data.trigger_metadata.presets ?? [],
          allowList: data.trigger_metadata.allow_list ?? [],
          mentionTotalLimit: data.trigger_metadata.mention_total_limit ?? null,
          mentionRaidProtectionEnabled: data.trigger_metadata.mention_raid_protection_enabled ?? false
        };
      }
      if ("actions" in data) {
        this.actions = data.actions.map((action) => _transformAPIAutoModerationAction(action));
      }
      if ("enabled" in data) {
        this.enabled = data.enabled;
      }
      if ("exempt_roles" in data) {
        this.exemptRoles = new Collection(data.exempt_roles.map((exemptRole) => [exemptRole, this.guild.roles.cache.get(exemptRole)]));
      }
      if ("exempt_channels" in data) {
        this.exemptChannels = new Collection(data.exempt_channels.map((exemptChannel) => [exemptChannel, this.guild.channels.cache.get(exemptChannel)]));
      }
    }
    edit(options) {
      return this.guild.autoModerationRules.edit(this.id, options);
    }
    delete(reason) {
      return this.guild.autoModerationRules.delete(this.id, reason);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setEventType(eventType, reason) {
      return this.edit({ eventType, reason });
    }
    setKeywordFilter(keywordFilter, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, keywordFilter }, reason });
    }
    setRegexPatterns(regexPatterns, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, regexPatterns }, reason });
    }
    setPresets(presets, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, presets }, reason });
    }
    setAllowList(allowList, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, allowList }, reason });
    }
    setMentionTotalLimit(mentionTotalLimit, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionTotalLimit }, reason });
    }
    setMentionRaidProtectionEnabled(mentionRaidProtectionEnabled, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionRaidProtectionEnabled }, reason });
    }
    setActions(actions, reason) {
      return this.edit({ actions, reason });
    }
    setEnabled(enabled = true, reason) {
      return this.edit({ enabled, reason });
    }
    setExemptRoles(exemptRoles, reason) {
      return this.edit({ exemptRoles, reason });
    }
    setExemptChannels(exemptChannels, reason) {
      return this.edit({ exemptChannels, reason });
    }
  }
  module.exports = AutoModerationRule;
});

// node_modules/discord.js/src/structures/GuildOnboardingPromptOption.js
var require_GuildOnboardingPromptOption = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class GuildOnboardingPromptOption extends Base {
    constructor(client, data, guildId) {
      super(client);
      this.guildId = guildId;
      const guild = this.guild;
      this.id = data.id;
      this.channels = data.channel_ids.reduce((channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)), new Collection);
      this.roles = data.role_ids.reduce((roles, roleId) => roles.set(roleId, guild.roles.cache.get(roleId)), new Collection);
      this._emoji = data.emoji;
      this.title = data.title;
      this.description = data.description;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
    get emoji() {
      if (!this._emoji.id && !this._emoji.name)
        return null;
      return this.client.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
  }
  exports.GuildOnboardingPromptOption = GuildOnboardingPromptOption;
});

// node_modules/discord.js/src/structures/GuildOnboardingPrompt.js
var require_GuildOnboardingPrompt = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { GuildOnboardingPromptOption } = require_GuildOnboardingPromptOption();

  class GuildOnboardingPrompt extends Base {
    constructor(client, data, guildId) {
      super(client);
      this.guildId = guildId;
      this.id = data.id;
      this.options = data.options.reduce((options, option) => options.set(option.id, new GuildOnboardingPromptOption(client, option, guildId)), new Collection);
      this.title = data.title;
      this.singleSelect = data.single_select;
      this.required = data.required;
      this.inOnboarding = data.in_onboarding;
      this.type = data.type;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboardingPrompt = GuildOnboardingPrompt;
});

// node_modules/discord.js/src/structures/Integration.js
var require_Integration = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var Base = require_Base();
  var IntegrationApplication = require_IntegrationApplication();

  class Integration extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.id = data.id;
      this.name = data.name;
      this.type = data.type;
      this.enabled = data.enabled ?? null;
      if ("syncing" in data) {
        this.syncing = data.syncing;
      } else {
        this.syncing ??= null;
      }
      this.role = this.guild.roles.resolve(data.role_id);
      if ("enable_emoticons" in data) {
        this.enableEmoticons = data.enable_emoticons;
      } else {
        this.enableEmoticons ??= null;
      }
      if (data.user) {
        this.user = this.client.users._add(data.user);
      } else {
        this.user ??= null;
      }
      this.account = data.account;
      if ("synced_at" in data) {
        this.syncedTimestamp = Date.parse(data.synced_at);
      } else {
        this.syncedTimestamp ??= null;
      }
      if ("subscriber_count" in data) {
        this.subscriberCount = data.subscriber_count;
      } else {
        this.subscriberCount ??= null;
      }
      if ("revoked" in data) {
        this.revoked = data.revoked;
      } else {
        this.revoked ??= null;
      }
      this._patch(data);
    }
    get syncedAt() {
      return this.syncedTimestamp && new Date(this.syncedTimestamp);
    }
    get roles() {
      const roles = this.guild.roles.cache;
      return roles.filter((role) => role.tags?.integrationId === this.id);
    }
    _patch(data) {
      if ("expire_behavior" in data) {
        this.expireBehavior = data.expire_behavior;
      } else {
        this.expireBehavior ??= null;
      }
      if ("expire_grace_period" in data) {
        this.expireGracePeriod = data.expire_grace_period;
      } else {
        this.expireGracePeriod ??= null;
      }
      if ("application" in data) {
        if (this.application) {
          this.application._patch(data.application);
        } else {
          this.application = new IntegrationApplication(this.client, data.application);
        }
      } else {
        this.application ??= null;
      }
      if ("scopes" in data) {
        this.scopes = data.scopes;
      } else {
        this.scopes ??= [];
      }
    }
    async delete(reason) {
      await this.client.rest.delete(Routes.guildIntegration(this.guild.id, this.id), { reason });
      return this;
    }
    toJSON() {
      return super.toJSON({
        role: "roleId",
        guild: "guildId",
        user: "userId"
      });
    }
  }
  module.exports = Integration;
});

// node_modules/discord.js/src/structures/StageInstance.js
var require_StageInstance = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();

  class StageInstance extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this._patch(data);
    }
    _patch(data) {
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("privacy_level" in data) {
        this.privacyLevel = data.privacy_level;
      }
      if ("discoverable_disabled" in data) {
        this.discoverableDisabled = data.discoverable_disabled;
      } else {
        this.discoverableDisabled ??= null;
      }
      if ("guild_scheduled_event_id" in data) {
        this.guildScheduledEventId = data.guild_scheduled_event_id;
      } else {
        this.guildScheduledEventId ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get guildScheduledEvent() {
      return this.guild?.scheduledEvents.resolve(this.guildScheduledEventId) ?? null;
    }
    edit(options) {
      return this.guild.stageInstances.edit(this.channelId, options);
    }
    async delete() {
      await this.guild.stageInstances.delete(this.channelId);
      const clone = this._clone();
      return clone;
    }
    setTopic(topic) {
      return this.guild.stageInstances.edit(this.channelId, { topic });
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
  }
  exports.StageInstance = StageInstance;
});

// node_modules/discord.js/src/structures/GuildAuditLogsEntry.js
var require_GuildAuditLogsEntry = __commonJS((exports, module) => {
  var changesReduce = function(changes, initialData = {}) {
    return changes.reduce((accumulator, change) => {
      accumulator[change.key] = change.new ?? change.old;
      return accumulator;
    }, initialData);
  };
  var { DiscordSnowflake } = require_cjs();
  var { AuditLogOptionsType, AuditLogEvent } = require_v106();
  var AutoModerationRule = require_AutoModerationRule();
  var { GuildOnboardingPrompt } = require_GuildOnboardingPrompt();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var Integration = require_Integration();
  var Invite = require_Invite();
  var { StageInstance } = require_StageInstance();
  var { Sticker } = require_Sticker();
  var Webhook = require_Webhook();
  var Partials = require_Partials();
  var { flatten } = require_Util();
  var Targets = {
    All: "All",
    Guild: "Guild",
    GuildScheduledEvent: "GuildScheduledEvent",
    Channel: "Channel",
    User: "User",
    Role: "Role",
    Invite: "Invite",
    Webhook: "Webhook",
    Emoji: "Emoji",
    Message: "Message",
    Integration: "Integration",
    StageInstance: "StageInstance",
    Sticker: "Sticker",
    Thread: "Thread",
    ApplicationCommand: "ApplicationCommand",
    AutoModeration: "AutoModeration",
    GuildOnboarding: "GuildOnboarding",
    GuildOnboardingPrompt: "GuildOnboardingPrompt",
    SoundboardSound: "SoundboardSound",
    Unknown: "Unknown"
  };

  class GuildAuditLogsEntry {
    static Targets = Targets;
    constructor(guild, data, logs) {
      this.targetType = GuildAuditLogsEntry.targetType(data.action_type);
      const targetType = this.targetType;
      this.actionType = GuildAuditLogsEntry.actionType(data.action_type);
      this.action = data.action_type;
      this.reason = data.reason ?? null;
      this.executorId = data.user_id;
      this.executor = data.user_id ? guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.user_id }) : guild.client.users.cache.get(data.user_id) ?? null : null;
      this.changes = data.changes?.map((change) => ({
        key: change.key,
        ..."old_value" in change ? { old: change.old_value } : {},
        ..."new_value" in change ? { new: change.new_value } : {}
      })) ?? [];
      this.id = data.id;
      this.extra = null;
      switch (data.action_type) {
        case AuditLogEvent.MemberPrune:
          this.extra = {
            removed: Number(data.options.members_removed),
            days: Number(data.options.delete_member_days)
          };
          break;
        case AuditLogEvent.MemberMove:
        case AuditLogEvent.MessageDelete:
          this.extra = {
            channel: guild.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
            count: Number(data.options.count)
          };
          break;
        case AuditLogEvent.MessagePin:
        case AuditLogEvent.MessageUnpin:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
            messageId: data.options.message_id
          };
          break;
        case AuditLogEvent.MessageBulkDelete:
        case AuditLogEvent.MemberDisconnect:
          this.extra = {
            count: Number(data.options.count)
          };
          break;
        case AuditLogEvent.ChannelOverwriteCreate:
        case AuditLogEvent.ChannelOverwriteUpdate:
        case AuditLogEvent.ChannelOverwriteDelete:
          switch (data.options.type) {
            case AuditLogOptionsType.Role:
              this.extra = guild.roles.cache.get(data.options.id) ?? {
                id: data.options.id,
                name: data.options.role_name,
                type: AuditLogOptionsType.Role
              };
              break;
            case AuditLogOptionsType.Member:
              this.extra = guild.members.cache.get(data.options.id) ?? {
                id: data.options.id,
                type: AuditLogOptionsType.Member
              };
              break;
            default:
              break;
          }
          break;
        case AuditLogEvent.StageInstanceCreate:
        case AuditLogEvent.StageInstanceDelete:
        case AuditLogEvent.StageInstanceUpdate:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
          };
          break;
        case AuditLogEvent.ApplicationCommandPermissionUpdate:
          this.extra = {
            applicationId: data.options.application_id
          };
          break;
        case AuditLogEvent.AutoModerationBlockMessage:
        case AuditLogEvent.AutoModerationFlagToChannel:
        case AuditLogEvent.AutoModerationUserCommunicationDisabled:
          this.extra = {
            autoModerationRuleName: data.options.auto_moderation_rule_name,
            autoModerationRuleTriggerType: data.options.auto_moderation_rule_trigger_type,
            channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
          };
          break;
        case AuditLogEvent.MemberKick:
        case AuditLogEvent.MemberRoleUpdate: {
          if (data.integration_type) {
            this.extra = {
              integrationType: data.integration_type
            };
          }
          break;
        }
        default:
          break;
      }
      this.targetId = data.target_id;
      this.target = null;
      if (targetType === Targets.Unknown) {
        this.target = changesReduce(this.changes);
        this.target.id = data.target_id;
      } else if (targetType === Targets.User && data.target_id) {
        this.target = guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.target_id }) : guild.client.users.cache.get(data.target_id) ?? null;
      } else if (targetType === Targets.Guild) {
        this.target = guild.client.guilds.cache.get(data.target_id);
      } else if (targetType === Targets.Webhook) {
        this.target = logs?.webhooks.get(data.target_id) ?? new Webhook(guild.client, changesReduce(this.changes, {
          id: data.target_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.Invite) {
        const inviteChange = this.changes.find(({ key }) => key === "code");
        this.target = guild.invites.cache.get(inviteChange.new ?? inviteChange.old) ?? new Invite(guild.client, changesReduce(this.changes, { guild }));
      } else if (targetType === Targets.Message) {
        this.target = data.action_type === AuditLogEvent.MessageBulkDelete ? guild.channels.cache.get(data.target_id) ?? { id: data.target_id } : guild.client.users.cache.get(data.target_id) ?? null;
      } else if (targetType === Targets.Integration) {
        this.target = logs?.integrations.get(data.target_id) ?? new Integration(guild.client, changesReduce(this.changes, { id: data.target_id }), guild);
      } else if (targetType === Targets.Channel || targetType === Targets.Thread) {
        this.target = guild.channels.cache.get(data.target_id) ?? changesReduce(this.changes, { id: data.target_id });
      } else if (targetType === Targets.StageInstance) {
        this.target = guild.stageInstances.cache.get(data.target_id) ?? new StageInstance(guild.client, changesReduce(this.changes, {
          id: data.target_id,
          channel_id: data.options?.channel_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.Sticker) {
        this.target = guild.stickers.cache.get(data.target_id) ?? new Sticker(guild.client, changesReduce(this.changes, { id: data.target_id }));
      } else if (targetType === Targets.GuildScheduledEvent) {
        this.target = guild.scheduledEvents.cache.get(data.target_id) ?? new GuildScheduledEvent(guild.client, changesReduce(this.changes, { id: data.target_id, guild_id: guild.id }));
      } else if (targetType === Targets.ApplicationCommand) {
        this.target = logs?.applicationCommands.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.AutoModeration) {
        this.target = guild.autoModerationRules.cache.get(data.target_id) ?? new AutoModerationRule(guild.client, changesReduce(this.changes, { id: data.target_id, guild_id: guild.id }), guild);
      } else if (targetType === Targets.GuildOnboardingPrompt) {
        this.target = data.action_type === AuditLogEvent.OnboardingPromptCreate ? new GuildOnboardingPrompt(guild.client, changesReduce(this.changes, { id: data.target_id }), guild.id) : changesReduce(this.changes, { id: data.target_id });
      } else if (targetType === Targets.Role) {
        this.target = guild.roles.cache.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.Emoji) {
        this.target = guild.emojis.cache.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.SoundboardSound) {
        this.target = guild.soundboardSounds.cache.get(data.target_id) ?? { id: data.target_id };
      } else if (data.target_id) {
        this.target = { id: data.target_id };
      }
    }
    static targetType(target) {
      if (target < 10)
        return Targets.Guild;
      if (target < 20)
        return Targets.Channel;
      if (target < 30)
        return Targets.User;
      if (target < 40)
        return Targets.Role;
      if (target < 50)
        return Targets.Invite;
      if (target < 60)
        return Targets.Webhook;
      if (target < 70)
        return Targets.Emoji;
      if (target < 80)
        return Targets.Message;
      if (target < 83)
        return Targets.Integration;
      if (target < 86)
        return Targets.StageInstance;
      if (target < 100)
        return Targets.Sticker;
      if (target < 110)
        return Targets.GuildScheduledEvent;
      if (target < 120)
        return Targets.Thread;
      if (target < 130)
        return Targets.ApplicationCommand;
      if (target < 140)
        return Targets.SoundboardSound;
      if (target < 143)
        return Targets.AutoModeration;
      if (target < 146)
        return Targets.User;
      if (target >= 163 && target <= 165)
        return Targets.GuildOnboardingPrompt;
      if (target >= 160 && target < 170)
        return Targets.GuildOnboarding;
      return Targets.Unknown;
    }
    static actionType(action) {
      if ([
        AuditLogEvent.ChannelCreate,
        AuditLogEvent.ChannelOverwriteCreate,
        AuditLogEvent.MemberBanRemove,
        AuditLogEvent.BotAdd,
        AuditLogEvent.RoleCreate,
        AuditLogEvent.InviteCreate,
        AuditLogEvent.WebhookCreate,
        AuditLogEvent.EmojiCreate,
        AuditLogEvent.MessagePin,
        AuditLogEvent.IntegrationCreate,
        AuditLogEvent.StageInstanceCreate,
        AuditLogEvent.StickerCreate,
        AuditLogEvent.GuildScheduledEventCreate,
        AuditLogEvent.ThreadCreate,
        AuditLogEvent.SoundboardSoundCreate,
        AuditLogEvent.AutoModerationRuleCreate,
        AuditLogEvent.AutoModerationBlockMessage,
        AuditLogEvent.OnboardingPromptCreate,
        AuditLogEvent.OnboardingCreate
      ].includes(action)) {
        return "Create";
      }
      if ([
        AuditLogEvent.ChannelDelete,
        AuditLogEvent.ChannelOverwriteDelete,
        AuditLogEvent.MemberKick,
        AuditLogEvent.MemberPrune,
        AuditLogEvent.MemberBanAdd,
        AuditLogEvent.MemberDisconnect,
        AuditLogEvent.RoleDelete,
        AuditLogEvent.InviteDelete,
        AuditLogEvent.WebhookDelete,
        AuditLogEvent.EmojiDelete,
        AuditLogEvent.MessageDelete,
        AuditLogEvent.MessageBulkDelete,
        AuditLogEvent.MessageUnpin,
        AuditLogEvent.IntegrationDelete,
        AuditLogEvent.StageInstanceDelete,
        AuditLogEvent.StickerDelete,
        AuditLogEvent.GuildScheduledEventDelete,
        AuditLogEvent.ThreadDelete,
        AuditLogEvent.SoundboardSoundDelete,
        AuditLogEvent.AutoModerationRuleDelete,
        AuditLogEvent.OnboardingPromptDelete
      ].includes(action)) {
        return "Delete";
      }
      if ([
        AuditLogEvent.GuildUpdate,
        AuditLogEvent.ChannelUpdate,
        AuditLogEvent.ChannelOverwriteUpdate,
        AuditLogEvent.MemberUpdate,
        AuditLogEvent.MemberRoleUpdate,
        AuditLogEvent.MemberMove,
        AuditLogEvent.RoleUpdate,
        AuditLogEvent.InviteUpdate,
        AuditLogEvent.WebhookUpdate,
        AuditLogEvent.EmojiUpdate,
        AuditLogEvent.IntegrationUpdate,
        AuditLogEvent.StageInstanceUpdate,
        AuditLogEvent.StickerUpdate,
        AuditLogEvent.GuildScheduledEventUpdate,
        AuditLogEvent.ThreadUpdate,
        AuditLogEvent.SoundboardSoundUpdate,
        AuditLogEvent.ApplicationCommandPermissionUpdate,
        AuditLogEvent.AutoModerationRuleUpdate,
        AuditLogEvent.AutoModerationBlockMessage,
        AuditLogEvent.AutoModerationFlagToChannel,
        AuditLogEvent.AutoModerationUserCommunicationDisabled,
        AuditLogEvent.OnboardingPromptUpdate,
        AuditLogEvent.OnboardingUpdate
      ].includes(action)) {
        return "Update";
      }
      return "All";
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toJSON() {
      return flatten(this, { createdTimestamp: true });
    }
  }
  module.exports = GuildAuditLogsEntry;
});

// node_modules/discord.js/src/client/actions/GuildAuditLogEntryCreate.js
var require_GuildAuditLogEntryCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  var Events = require_Events();

  class GuildAuditLogEntryCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let auditLogEntry;
      if (guild) {
        auditLogEntry = new GuildAuditLogsEntry(guild, data);
        client.emit(Events.GuildAuditLogEntryCreate, auditLogEntry, guild);
      }
      return { auditLogEntry };
    }
  }
  module.exports = GuildAuditLogEntryCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildBanAdd.js
var require_GuildBanAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildBanAdd extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events.GuildBanAdd, guild.bans._add(data));
    }
  }
  module.exports = GuildBanAdd;
});

// node_modules/discord.js/src/structures/GuildBan.js
var require_GuildBan = __commonJS((exports, module) => {
  var Base = require_Base();

  class GuildBan extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users._add(data.user, true);
      }
      if ("reason" in data) {
        this.reason = data.reason;
      }
    }
    get partial() {
      return !("reason" in this);
    }
    fetch(force = true) {
      return this.guild.bans.fetch({ user: this.user, cache: true, force });
    }
  }
  module.exports = GuildBan;
});

// node_modules/discord.js/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var GuildBan = require_GuildBan();
  var Events = require_Events();

  class GuildBanRemove extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const ban = guild.bans.cache.get(data.user.id) ?? new GuildBan(client, data, guild);
        guild.bans.cache.delete(ban.user.id);
        client.emit(Events.GuildBanRemove, ban);
      }
    }
  }
  module.exports = GuildBanRemove;
});

// node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildChannelsPositionUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialChannel of data.channels) {
          const channel = guild.channels.cache.get(partialChannel.id);
          if (channel)
            channel.rawPosition = partialChannel.position;
        }
      }
      return { guild };
    }
  }
  module.exports = GuildChannelsPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildDelete.js
var require_GuildDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      let guild = client.guilds.cache.get(data.id);
      if (guild) {
        if (data.unavailable) {
          guild.available = false;
          client.emit(Events.GuildUnavailable, guild);
          return;
        }
        for (const channel of guild.channels.cache.values())
          this.client.channels._remove(channel.id);
        client.voice.adapters.get(data.id)?.destroy();
        client.guilds.cache.delete(guild.id);
        client.emit(Events.GuildDelete, guild);
      }
    }
  }
  module.exports = GuildDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiCreateAction extends Action {
    handle(guild, createdEmoji) {
      const already = guild.emojis.cache.has(createdEmoji.id);
      const emoji = guild.emojis._add(createdEmoji);
      if (!already)
        this.client.emit(Events.GuildEmojiCreate, emoji);
      return { emoji };
    }
  }
  module.exports = GuildEmojiCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiDeleteAction extends Action {
    handle(emoji) {
      emoji.guild.emojis.cache.delete(emoji.id);
      this.client.emit(Events.GuildEmojiDelete, emoji);
      return { emoji };
    }
  }
  module.exports = GuildEmojiDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiUpdateAction extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events.GuildEmojiUpdate, old, current);
      return { emoji: current };
    }
  }
  module.exports = GuildEmojiUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildEmojisUpdateAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild?.emojis)
        return;
      const deletions = new Map(guild.emojis.cache);
      for (const emoji of data.emojis) {
        const cachedEmoji = guild.emojis.cache.get(emoji.id);
        if (cachedEmoji) {
          deletions.delete(emoji.id);
          if (!cachedEmoji.equals(emoji)) {
            this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
          }
        } else {
          this.client.actions.GuildEmojiCreate.handle(guild, emoji);
        }
      }
      for (const emoji of deletions.values()) {
        this.client.actions.GuildEmojiDelete.handle(emoji);
      }
    }
  }
  module.exports = GuildEmojisUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildIntegrationsUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events.GuildIntegrationsUpdate, guild);
    }
  }
  module.exports = GuildIntegrationsUpdate;
});

// node_modules/discord.js/src/util/Status.js
var require_Status = __commonJS((exports, module) => {
  var { createEnum } = require_Enums();
  module.exports = createEnum([
    "Ready",
    "Connecting",
    "Reconnecting",
    "Idle",
    "Nearly",
    "Disconnected",
    "WaitingForGuilds",
    "Identifying",
    "Resuming"
  ]);
});

// node_modules/discord.js/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Status = require_Status();

  class GuildMemberRemoveAction extends Action {
    handle(data, shard) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let member = null;
      if (guild) {
        member = this.getMember({ user: data.user }, guild);
        guild.memberCount--;
        if (member) {
          guild.members.cache.delete(member.id);
          if (shard.status === Status.Ready)
            client.emit(Events.GuildMemberRemove, member);
        }
        guild.presences.cache.delete(data.user.id);
        guild.voiceStates.cache.delete(data.user.id);
      }
      return { guild, member };
    }
  }
  module.exports = GuildMemberRemoveAction;
});

// node_modules/discord.js/src/client/actions/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Status = require_Status();

  class GuildMemberUpdateAction extends Action {
    handle(data, shard) {
      const { client } = this;
      if (data.user.username) {
        const user = client.users.cache.get(data.user.id);
        if (!user) {
          client.users._add(data.user);
        } else if (!user._equals(data.user)) {
          client.actions.UserUpdate.handle(data.user);
        }
      }
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const member = this.getMember({ user: data.user }, guild);
        if (member) {
          const old = member._update(data);
          if (shard.status === Status.Ready && !member.equals(old))
            client.emit(Events.GuildMemberUpdate, old, member);
        } else {
          const newMember = guild.members._add(data);
          this.client.emit(Events.GuildMemberAvailable, newMember);
        }
      }
    }
  }
  module.exports = GuildMemberUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleCreate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        const already = guild.roles.cache.has(data.role.id);
        role = guild.roles._add(data.role);
        if (!already)
          client.emit(Events.GuildRoleCreate, role);
      }
      return { role };
    }
  }
  module.exports = GuildRoleCreate;
});

// node_modules/discord.js/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        role = guild.roles.cache.get(data.role_id);
        if (role) {
          guild.roles.cache.delete(data.role_id);
          client.emit(Events.GuildRoleDelete, role);
        }
      }
      return { role };
    }
  }
  module.exports = GuildRoleDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        let old = null;
        const role = guild.roles.cache.get(data.role.id);
        if (role) {
          old = role._update(data.role);
          client.emit(Events.GuildRoleUpdate, old, role);
        }
        return {
          old,
          updated: role
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = GuildRoleUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildRolesPositionUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialRole of data.roles) {
          const role = guild.roles.cache.get(partialRole.id);
          if (role)
            role.rawPosition = partialRole.position;
        }
      }
      return { guild };
    }
  }
  module.exports = GuildRolesPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js
var require_GuildScheduledEventCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = guild.scheduledEvents._add(data);
        client.emit(Events.GuildScheduledEventCreate, guildScheduledEvent);
        return { guildScheduledEvent };
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js
var require_GuildScheduledEventDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        if (guildScheduledEvent) {
          guild.scheduledEvents.cache.delete(guildScheduledEvent.id);
          client.emit(Events.GuildScheduledEventDelete, guildScheduledEvent);
          return { guildScheduledEvent };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js
var require_GuildScheduledEventUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldGuildScheduledEvent = guild.scheduledEvents.cache.get(data.id)?._clone() ?? null;
        const newGuildScheduledEvent = guild.scheduledEvents._add(data);
        client.emit(Events.GuildScheduledEventUpdate, oldGuildScheduledEvent, newGuildScheduledEvent);
        return { oldGuildScheduledEvent, newGuildScheduledEvent };
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js
var require_GuildScheduledEventUserAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUserAddAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        const user = this.getUser(data);
        if (guildScheduledEvent && user) {
          client.emit(Events.GuildScheduledEventUserAdd, guildScheduledEvent, user);
          return { guildScheduledEvent, user };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUserAddAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js
var require_GuildScheduledEventUserRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUserRemoveAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        const user = this.getUser(data);
        if (guildScheduledEvent && user) {
          client.emit(Events.GuildScheduledEventUserRemove, guildScheduledEvent, user);
          return { guildScheduledEvent, user };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUserRemoveAction;
});

// node_modules/discord.js/src/client/actions/GuildSoundboardSoundDelete.js
var require_GuildSoundboardSoundDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildSoundboardSoundDeleteAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild)
        return {};
      const soundboardSound = this.getSoundboardSound(data, guild);
      if (soundboardSound) {
        guild.soundboardSounds.cache.delete(soundboardSound.soundId);
        this.client.emit(Events.GuildSoundboardSoundDelete, soundboardSound);
      }
      return { soundboardSound };
    }
  }
  module.exports = GuildSoundboardSoundDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerCreate.js
var require_GuildStickerCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerCreateAction extends Action {
    handle(guild, createdSticker) {
      const already = guild.stickers.cache.has(createdSticker.id);
      const sticker = guild.stickers._add(createdSticker);
      if (!already)
        this.client.emit(Events.GuildStickerCreate, sticker);
      return { sticker };
    }
  }
  module.exports = GuildStickerCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerDelete.js
var require_GuildStickerDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerDeleteAction extends Action {
    handle(sticker) {
      sticker.guild.stickers.cache.delete(sticker.id);
      this.client.emit(Events.GuildStickerDelete, sticker);
      return { sticker };
    }
  }
  module.exports = GuildStickerDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerUpdate.js
var require_GuildStickerUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerUpdateAction extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events.GuildStickerUpdate, old, current);
      return { sticker: current };
    }
  }
  module.exports = GuildStickerUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildStickersUpdate.js
var require_GuildStickersUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildStickersUpdateAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild?.stickers)
        return;
      const deletions = new Map(guild.stickers.cache);
      for (const sticker of data.stickers) {
        const cachedSticker = guild.stickers.cache.get(sticker.id);
        if (cachedSticker) {
          deletions.delete(sticker.id);
          if (!cachedSticker.equals(sticker)) {
            this.client.actions.GuildStickerUpdate.handle(cachedSticker, sticker);
          }
        } else {
          this.client.actions.GuildStickerCreate.handle(guild, sticker);
        }
      }
      for (const sticker of deletions.values()) {
        this.client.actions.GuildStickerDelete.handle(sticker);
      }
    }
  }
  module.exports = GuildStickersUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildUpdate.js
var require_GuildUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.id);
      if (guild) {
        const old = guild._update(data);
        client.emit(Events.GuildUpdate, old, guild);
        return {
          old,
          updated: guild
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = GuildUpdateAction;
});

// node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js
var require_CommandInteractionOptionResolver = __commonJS((exports, module) => {
  var { ApplicationCommandOptionType } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class CommandInteractionOptionResolver {
    constructor(client, options, resolved) {
      Object.defineProperty(this, "client", { value: client });
      this._group = null;
      this._subcommand = null;
      this._hoistedOptions = options;
      if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.SubcommandGroup) {
        this._group = this._hoistedOptions[0].name;
        this._hoistedOptions = this._hoistedOptions[0].options ?? [];
      }
      if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.Subcommand) {
        this._subcommand = this._hoistedOptions[0].name;
        this._hoistedOptions = this._hoistedOptions[0].options ?? [];
      }
      Object.defineProperty(this, "data", { value: Object.freeze([...options]) });
      Object.defineProperty(this, "resolved", { value: resolved ? Object.freeze(resolved) : null });
    }
    get(name, required = false) {
      const option = this._hoistedOptions.find((opt) => opt.name === name);
      if (!option) {
        if (required) {
          throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNotFound, name);
        }
        return null;
      }
      return option;
    }
    _getTypedOption(name, allowedTypes, properties, required) {
      const option = this.get(name, required);
      if (!option) {
        return null;
      } else if (!allowedTypes.includes(option.type)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionType, name, option.type, allowedTypes.join(", "));
      } else if (required && properties.every((prop) => option[prop] === null || option[prop] === undefined)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionEmpty, name, option.type);
      }
      return option;
    }
    getSubcommand(required = true) {
      if (required && !this._subcommand) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommand);
      }
      return this._subcommand;
    }
    getSubcommandGroup(required = false) {
      if (required && !this._group) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommandGroup);
      }
      return this._group;
    }
    getBoolean(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Boolean], ["value"], required);
      return option?.value ?? null;
    }
    getChannel(name, required = false, channelTypes = []) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Channel], ["channel"], required);
      const channel = option?.channel ?? null;
      if (channel && channelTypes.length > 0 && !channelTypes.includes(channel.type)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionInvalidChannelType, name, channel.type, channelTypes.join(", "));
      }
      return channel;
    }
    getString(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.String], ["value"], required);
      return option?.value ?? null;
    }
    getInteger(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Integer], ["value"], required);
      return option?.value ?? null;
    }
    getNumber(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Number], ["value"], required);
      return option?.value ?? null;
    }
    getUser(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable], ["user"], required);
      return option?.user ?? null;
    }
    getMember(name) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable], ["member"], false);
      return option?.member ?? null;
    }
    getRole(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Role, ApplicationCommandOptionType.Mentionable], ["role"], required);
      return option?.role ?? null;
    }
    getAttachment(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Attachment], ["attachment"], required);
      return option?.attachment ?? null;
    }
    getMentionable(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Mentionable], ["user", "member", "role"], required);
      return option?.member ?? option?.user ?? option?.role ?? null;
    }
    getMessage(name, required = false) {
      const option = this._getTypedOption(name, ["_MESSAGE"], ["message"], required);
      return option?.message ?? null;
    }
    getFocused(getFull = false) {
      const focusedOption = this._hoistedOptions.find((option) => option.focused);
      if (!focusedOption)
        throw new DiscordjsTypeError(ErrorCodes.AutocompleteInteractionOptionNoFocusedOption);
      return getFull ? focusedOption : focusedOption.value;
    }
  }
  module.exports = CommandInteractionOptionResolver;
});

// node_modules/discord.js/src/structures/AutocompleteInteraction.js
var require_AutocompleteInteraction = __commonJS((exports, module) => {
  var { InteractionResponseType, Routes } = require_v106();
  var BaseInteraction = require_BaseInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class AutocompleteInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.commandId = data.data.id;
      this.commandName = data.data.name;
      this.commandType = data.data.type;
      this.commandGuildId = data.data.guild_id ?? null;
      this.responded = false;
      this.options = new CommandInteractionOptionResolver(this.client, data.data.options ?? []);
    }
    get command() {
      const id = this.commandId;
      return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
    }
    async respond(options) {
      if (this.responded)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.ApplicationCommandAutocompleteResult,
          data: {
            choices: options.map(({ nameLocalizations, ...option }) => ({
              ...this.client.options.jsonTransformer(option),
              name_localizations: nameLocalizations
            }))
          }
        },
        auth: false
      });
      this.responded = true;
    }
  }
  module.exports = AutocompleteInteraction;
});

// node_modules/discord.js/src/structures/InteractionCallback.js
var require_InteractionCallback = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();

  class InteractionCallback {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      this.id = data.id;
      this.type = data.type;
      this.activityInstanceId = data.activity_instance_id ?? null;
      this.responseMessageId = data.response_message_id ?? null;
      this.responseMessageLoading = data.response_message_loading ?? null;
      this.responseMessageEphemeral = data.response_message_ephemeral ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
  }
  module.exports = InteractionCallback;
});

// node_modules/discord.js/src/structures/InteractionCallbackResource.js
var require_InteractionCallbackResource = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var getMessage = lazy(() => require_Message().Message);

  class InteractionCallbackResource {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      this.type = data.type;
      this.activityInstance = data.activity_instance ?? null;
      if ("message" in data) {
        this.message = this.client.channels.cache.get(data.message.channel_id)?.messages._add(data.message) ?? new (getMessage())(client, data.message);
      } else {
        this.message = null;
      }
    }
  }
  module.exports = InteractionCallbackResource;
});

// node_modules/discord.js/src/structures/InteractionCallbackResponse.js
var require_InteractionCallbackResponse = __commonJS((exports, module) => {
  var InteractionCallback = require_InteractionCallback();
  var InteractionCallbackResource = require_InteractionCallbackResource();

  class InteractionCallbackResponse {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      this.interaction = new InteractionCallback(client, data.interaction);
      this.resource = data.resource ? new InteractionCallbackResource(client, data.resource) : null;
    }
  }
  module.exports = InteractionCallbackResponse;
});

// node_modules/discord.js/src/structures/InteractionResponse.js
var require_InteractionResponse = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var { InteractionType } = require_v106();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class InteractionResponse {
    constructor(interaction, id) {
      this.interaction = interaction;
      this.id = id ?? interaction.id;
      this.client = interaction.client;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionResponse: this,
        interactionType: InteractionType.MessageComponent
      });
    }
    fetch() {
      return this.interaction.fetchReply();
    }
    delete() {
      return this.interaction.deleteReply();
    }
    edit(options) {
      return this.interaction.editReply(options);
    }
  }
  var InteractionCollector = require_InteractionCollector();
  module.exports = InteractionResponse;
});

// node_modules/discord.js/src/structures/interfaces/InteractionResponses.js
var require_InteractionResponses = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var { deprecate } = import.meta.require("util");
  var { makeURLSearchParams } = require_dist5();
  var { isJSONEncodable } = require_dist();
  var { InteractionResponseType, MessageFlags, Routes, InteractionType } = require_v106();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var InteractionCallbackResponse = require_InteractionCallbackResponse();
  var InteractionCollector = require_InteractionCollector();
  var InteractionResponse = require_InteractionResponse();
  var MessagePayload = require_MessagePayload();
  var deprecationEmittedForEphemeralOption = false;
  var deprecationEmittedForFetchReplyOption = false;

  class InteractionResponses {
    async deferReply(options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if ("ephemeral" in options) {
        if (!deprecationEmittedForEphemeralOption) {
          process2.emitWarning(`Supplying "ephemeral" for interaction response options is deprecated. Utilize flags instead.`);
          deprecationEmittedForEphemeralOption = true;
        }
      }
      if ("fetchReply" in options) {
        if (!deprecationEmittedForFetchReplyOption) {
          process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
          deprecationEmittedForFetchReplyOption = true;
        }
      }
      const flags = new MessageFlagsBitField(options.flags);
      if (options.ephemeral) {
        flags.add(MessageFlags.Ephemeral);
      }
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.DeferredChannelMessageWithSource,
          data: {
            flags: flags.bitfield
          }
        },
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.deferred = true;
      this.ephemeral = flags.has(MessageFlags.Ephemeral);
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
    }
    async reply(options) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if (typeof options !== "string") {
        if ("ephemeral" in options) {
          if (!deprecationEmittedForEphemeralOption) {
            process2.emitWarning(`Supplying "ephemeral" for interaction response options is deprecated. Utilize flags instead.`);
            deprecationEmittedForEphemeralOption = true;
          }
        }
        if ("fetchReply" in options) {
          if (!deprecationEmittedForFetchReplyOption) {
            process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
            deprecationEmittedForFetchReplyOption = true;
          }
        }
      }
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.ChannelMessageWithSource,
          data
        },
        files,
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.ephemeral = Boolean(data.flags & MessageFlags.Ephemeral);
      this.replied = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
    }
    fetchReply(message = "@original") {
      return this.webhook.fetchMessage(message);
    }
    async editReply(options) {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      const msg = await this.webhook.editMessage(options.message ?? "@original", options);
      this.replied = true;
      return msg;
    }
    async deleteReply(message = "@original") {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      await this.webhook.deleteMessage(message);
    }
    async followUp(options) {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      const msg = await this.webhook.send(options);
      this.replied = true;
      return msg;
    }
    async deferUpdate(options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if ("fetchReply" in options) {
        if (!deprecationEmittedForFetchReplyOption) {
          process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
          deprecationEmittedForFetchReplyOption = true;
        }
      }
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.DeferredMessageUpdate
        },
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.deferred = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interactionMetadata?.id);
    }
    async update(options) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if (typeof options !== "string" && "fetchReply" in options) {
        if (!deprecationEmittedForFetchReplyOption) {
          process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
          deprecationEmittedForFetchReplyOption = true;
        }
      }
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.UpdateMessage,
          data
        },
        files,
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.replied = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message.interactionMetadata?.id);
    }
    async showModal(modal, options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.Modal,
          data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal)
        },
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.replied = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : undefined;
    }
    async sendPremiumRequired() {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.PremiumRequired
        },
        auth: false
      });
      this.replied = true;
    }
    async awaitModalSubmit(options) {
      if (typeof options.time !== "number")
        throw new DiscordjsError(ErrorCodes.InvalidType, "time", "number");
      const _options = { ...options, max: 1, interactionType: InteractionType.ModalSubmit };
      return new Promise((resolve, reject) => {
        const collector = new InteractionCollector(this.client, _options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    static applyToClass(structure, ignore = []) {
      const props = [
        "deferReply",
        "reply",
        "fetchReply",
        "editReply",
        "deleteReply",
        "followUp",
        "deferUpdate",
        "update",
        "showModal",
        "sendPremiumRequired",
        "awaitModalSubmit"
      ];
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop));
      }
    }
  }
  InteractionResponses.prototype.sendPremiumRequired = deprecate(InteractionResponses.prototype.sendPremiumRequired, "InteractionResponses#sendPremiumRequired() is deprecated. Sending a premium-style button is the new Discord behaviour.");
  module.exports = InteractionResponses;
});

// node_modules/discord.js/src/structures/MessageComponentInteraction.js
var require_MessageComponentInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var InteractionResponses = require_InteractionResponses();
  var { findComponentByCustomId } = require_Components();
  var getMessage = lazy(() => require_Message().Message);

  class MessageComponentInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(client, data.message);
      this.customId = data.data.custom_id;
      this.componentType = data.data.component_type;
      this.deferred = false;
      this.ephemeral = null;
      this.replied = false;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    get component() {
      return findComponentByCustomId(this.message.components, this.customId);
    }
    deferReply() {
    }
    reply() {
    }
    fetchReply() {
    }
    editReply() {
    }
    deleteReply() {
    }
    followUp() {
    }
    deferUpdate() {
    }
    update() {
    }
    showModal() {
    }
    sendPremiumRequired() {
    }
    awaitModalSubmit() {
    }
  }
  InteractionResponses.applyToClass(MessageComponentInteraction);
  module.exports = MessageComponentInteraction;
});

// node_modules/discord.js/src/structures/ButtonInteraction.js
var require_ButtonInteraction = __commonJS((exports, module) => {
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class ButtonInteraction extends MessageComponentInteraction {
  }
  module.exports = ButtonInteraction;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuInteraction.js
var require_ChannelSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class ChannelSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.channels = new Collection;
      for (const channel of Object.values(resolved?.channels ?? {})) {
        this.channels.set(channel.id, this.client.channels._add(channel, this.guild) ?? channel);
      }
    }
  }
  module.exports = ChannelSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/CommandInteraction.js
var require_CommandInteraction = __commonJS((exports, module) => {
  var Attachment = require_Attachment();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var InteractionResponses = require_InteractionResponses();

  class CommandInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.commandId = data.data.id;
      this.commandName = data.data.name;
      this.commandType = data.data.type;
      this.commandGuildId = data.data.guild_id ?? null;
      this.deferred = false;
      this.replied = false;
      this.ephemeral = null;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    get command() {
      const id = this.commandId;
      return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
    }
    transformOption(option, resolved) {
      const result = {
        name: option.name,
        type: option.type
      };
      if ("value" in option)
        result.value = option.value;
      if ("options" in option)
        result.options = option.options.map((opt) => this.transformOption(opt, resolved));
      if (resolved) {
        const user = resolved.users?.[option.value];
        if (user)
          result.user = this.client.users._add(user);
        const member = resolved.members?.[option.value];
        if (member)
          result.member = this.guild?.members._add({ user, ...member }) ?? member;
        const channel = resolved.channels?.[option.value];
        if (channel)
          result.channel = this.client.channels._add(channel, this.guild) ?? channel;
        const role = resolved.roles?.[option.value];
        if (role)
          result.role = this.guild?.roles._add(role) ?? role;
        const attachment = resolved.attachments?.[option.value];
        if (attachment)
          result.attachment = new Attachment(attachment);
      }
      return result;
    }
    deferReply() {
    }
    reply() {
    }
    fetchReply() {
    }
    editReply() {
    }
    deleteReply() {
    }
    followUp() {
    }
    showModal() {
    }
    sendPremiumRequired() {
    }
    awaitModalSubmit() {
    }
  }
  InteractionResponses.applyToClass(CommandInteraction, ["deferUpdate", "update"]);
  module.exports = CommandInteraction;
});

// node_modules/discord.js/src/structures/ChatInputCommandInteraction.js
var require_ChatInputCommandInteraction = __commonJS((exports, module) => {
  var CommandInteraction = require_CommandInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { transformResolved } = require_Util();

  class ChatInputCommandInteraction extends CommandInteraction {
    constructor(client, data) {
      super(client, data);
      this.options = new CommandInteractionOptionResolver(this.client, data.data.options?.map((option) => this.transformOption(option, data.data.resolved)) ?? [], transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.data.resolved));
    }
    toString() {
      const properties = [
        this.commandName,
        this.options._group,
        this.options._subcommand,
        ...this.options._hoistedOptions.map((option) => `${option.name}:${option.value}`)
      ];
      return `/${properties.filter(Boolean).join(" ")}`;
    }
  }
  module.exports = ChatInputCommandInteraction;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuInteraction.js
var require_MentionableSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();
  var Events = require_Events();

  class MentionableSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      const { members, users, roles } = resolved ?? {};
      this.values = values ?? [];
      this.users = new Collection;
      this.members = new Collection;
      this.roles = new Collection;
      if (members) {
        for (const [id, member] of Object.entries(members)) {
          const user = users[id];
          if (!user) {
            this.client.emit(Events.Debug, `[MentionableSelectMenuInteraction] Received a member without a user, skipping ${id}`);
            continue;
          }
          this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
        }
      }
      if (users) {
        for (const user of Object.values(users)) {
          this.users.set(user.id, this.client.users._add(user));
        }
      }
      if (roles) {
        for (const role of Object.values(roles)) {
          this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
        }
      }
    }
  }
  module.exports = MentionableSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js
var require_ContextMenuCommandInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var { ApplicationCommandOptionType } = require_v106();
  var CommandInteraction = require_CommandInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { transformResolved } = require_Util();
  var getMessage = lazy(() => require_Message().Message);

  class ContextMenuCommandInteraction extends CommandInteraction {
    constructor(client, data) {
      super(client, data);
      this.options = new CommandInteractionOptionResolver(this.client, this.resolveContextMenuOptions(data.data), transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.data.resolved));
      this.targetId = data.data.target_id;
    }
    resolveContextMenuOptions({ target_id, resolved }) {
      const result = [];
      if (resolved.users?.[target_id]) {
        result.push(this.transformOption({ name: "user", type: ApplicationCommandOptionType.User, value: target_id }, resolved));
      }
      if (resolved.messages?.[target_id]) {
        result.push({
          name: "message",
          type: "_MESSAGE",
          value: target_id,
          message: this.channel?.messages._add(resolved.messages[target_id]) ?? new (getMessage())(this.client, resolved.messages[target_id])
        });
      }
      return result;
    }
  }
  module.exports = ContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js
var require_MessageContextMenuCommandInteraction = __commonJS((exports, module) => {
  var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();

  class MessageContextMenuCommandInteraction extends ContextMenuCommandInteraction {
    get targetMessage() {
      return this.options.getMessage("message");
    }
  }
  module.exports = MessageContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/ModalSubmitFields.js
var require_ModalSubmitFields = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { ComponentType } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class ModalSubmitFields {
    constructor(components) {
      this.components = components;
      this.fields = components.reduce((accumulator, next) => {
        next.components.forEach((component) => accumulator.set(component.customId, component));
        return accumulator;
      }, new Collection);
    }
    getField(customId, type) {
      const field = this.fields.get(customId);
      if (!field)
        throw new DiscordjsTypeError(ErrorCodes.ModalSubmitInteractionFieldNotFound, customId);
      if (type !== undefined && type !== field.type) {
        throw new DiscordjsTypeError(ErrorCodes.ModalSubmitInteractionFieldType, customId, field.type, type);
      }
      return field;
    }
    getTextInputValue(customId) {
      return this.getField(customId, ComponentType.TextInput).value;
    }
  }
  module.exports = ModalSubmitFields;
});

// node_modules/discord.js/src/structures/ModalSubmitInteraction.js
var require_ModalSubmitInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var ModalSubmitFields = require_ModalSubmitFields();
  var InteractionResponses = require_InteractionResponses();
  var getMessage = lazy(() => require_Message().Message);

  class ModalSubmitInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.customId = data.data.custom_id;
      if ("message" in data) {
        this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(this.client, data.message);
      } else {
        this.message = null;
      }
      this.components = data.data.components?.map((component) => ModalSubmitInteraction.transformComponent(component));
      this.fields = new ModalSubmitFields(this.components);
      this.deferred = false;
      this.replied = false;
      this.ephemeral = null;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    static transformComponent(rawComponent) {
      return rawComponent.components ? {
        type: rawComponent.type,
        components: rawComponent.components.map((component) => this.transformComponent(component))
      } : {
        value: rawComponent.value,
        type: rawComponent.type,
        customId: rawComponent.custom_id
      };
    }
    isFromMessage() {
      return Boolean(this.message);
    }
    deferReply() {
    }
    reply() {
    }
    fetchReply() {
    }
    editReply() {
    }
    deleteReply() {
    }
    followUp() {
    }
    deferUpdate() {
    }
    update() {
    }
    sendPremiumRequired() {
    }
  }
  InteractionResponses.applyToClass(ModalSubmitInteraction, "showModal");
  module.exports = ModalSubmitInteraction;
});

// node_modules/discord.js/src/structures/RoleSelectMenuInteraction.js
var require_RoleSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class RoleSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.roles = new Collection;
      for (const role of Object.values(resolved?.roles ?? {})) {
        this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
      }
    }
  }
  module.exports = RoleSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/StringSelectMenuInteraction.js
var require_StringSelectMenuInteraction = __commonJS((exports, module) => {
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class StringSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      this.values = data.data.values ?? [];
    }
  }
  module.exports = StringSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js
var require_UserContextMenuCommandInteraction = __commonJS((exports, module) => {
  var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();

  class UserContextMenuCommandInteraction extends ContextMenuCommandInteraction {
    get targetUser() {
      return this.options.getUser("user");
    }
    get targetMember() {
      return this.options.getMember("user");
    }
  }
  module.exports = UserContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/UserSelectMenuInteraction.js
var require_UserSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();
  var Events = require_Events();

  class UserSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.users = new Collection;
      this.members = new Collection;
      for (const user of Object.values(resolved?.users ?? {})) {
        this.users.set(user.id, this.client.users._add(user));
      }
      for (const [id, member] of Object.entries(resolved?.members ?? {})) {
        const user = resolved.users[id];
        if (!user) {
          this.client.emit(Events.Debug, `[UserSelectMenuInteraction] Received a member without a user, skipping ${id}`);
          continue;
        }
        this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
      }
    }
  }
  module.exports = UserSelectMenuInteraction;
});

// node_modules/discord.js/src/client/actions/InteractionCreate.js
var require_InteractionCreate = __commonJS((exports, module) => {
  var { InteractionType, ComponentType, ApplicationCommandType } = require_v106();
  var Action = require_Action();
  var AutocompleteInteraction = require_AutocompleteInteraction();
  var ButtonInteraction = require_ButtonInteraction();
  var ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
  var ChatInputCommandInteraction = require_ChatInputCommandInteraction();
  var MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  var MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
  var ModalSubmitInteraction = require_ModalSubmitInteraction();
  var RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
  var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  var UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
  var UserSelectMenuInteraction = require_UserSelectMenuInteraction();
  var Events = require_Events();

  class InteractionCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = data.channel && this.getChannel(data.channel);
      let InteractionClass;
      switch (data.type) {
        case InteractionType.ApplicationCommand:
          switch (data.data.type) {
            case ApplicationCommandType.ChatInput:
              InteractionClass = ChatInputCommandInteraction;
              break;
            case ApplicationCommandType.User:
              InteractionClass = UserContextMenuCommandInteraction;
              break;
            case ApplicationCommandType.Message:
              if (channel && !channel.isTextBased())
                return;
              InteractionClass = MessageContextMenuCommandInteraction;
              break;
            default:
              client.emit(Events.Debug, `[INTERACTION] Received application command interaction with unknown type: ${data.data.type}`);
              return;
          }
          break;
        case InteractionType.MessageComponent:
          if (channel && !channel.isTextBased())
            return;
          switch (data.data.component_type) {
            case ComponentType.Button:
              InteractionClass = ButtonInteraction;
              break;
            case ComponentType.StringSelect:
              InteractionClass = StringSelectMenuInteraction;
              break;
            case ComponentType.UserSelect:
              InteractionClass = UserSelectMenuInteraction;
              break;
            case ComponentType.RoleSelect:
              InteractionClass = RoleSelectMenuInteraction;
              break;
            case ComponentType.MentionableSelect:
              InteractionClass = MentionableSelectMenuInteraction;
              break;
            case ComponentType.ChannelSelect:
              InteractionClass = ChannelSelectMenuInteraction;
              break;
            default:
              client.emit(Events.Debug, `[INTERACTION] Received component interaction with unknown type: ${data.data.component_type}`);
              return;
          }
          break;
        case InteractionType.ApplicationCommandAutocomplete:
          InteractionClass = AutocompleteInteraction;
          break;
        case InteractionType.ModalSubmit:
          InteractionClass = ModalSubmitInteraction;
          break;
        default:
          client.emit(Events.Debug, `[INTERACTION] Received interaction with unknown type: ${data.type}`);
          return;
      }
      const interaction = new InteractionClass(client, data);
      client.emit(Events.InteractionCreate, interaction);
    }
  }
  module.exports = InteractionCreateAction;
});

// node_modules/discord.js/src/client/actions/InviteCreate.js
var require_InviteCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class InviteCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, { channel, guild });
      const invite = guild.invites._add(inviteData);
      client.emit(Events.InviteCreate, invite);
      return { invite };
    }
  }
  module.exports = InviteCreateAction;
});

// node_modules/discord.js/src/client/actions/InviteDelete.js
var require_InviteDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Invite = require_Invite();
  var Events = require_Events();

  class InviteDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, { channel, guild });
      const invite = new Invite(client, inviteData);
      guild.invites.cache.delete(invite.code);
      client.emit(Events.InviteDelete, invite);
      return { invite };
    }
  }
  module.exports = InviteDeleteAction;
});

// node_modules/discord.js/src/client/actions/MessageCreate.js
var require_MessageCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({
        id: data.channel_id,
        author: data.author,
        ..."guild_id" in data && { guild_id: data.guild_id }
      });
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread()) {
          channel.messageCount++;
          channel.totalMessageSent++;
        }
        const existing = channel.messages.cache.get(data.id);
        if (existing && existing.author?.id !== this.client.user.id)
          return { message: existing };
        const message = existing ?? channel.messages._add(data);
        channel.lastMessageId = data.id;
        client.emit(Events.MessageCreate, message);
        return { message };
      }
      return {};
    }
  }
  module.exports = MessageCreateAction;
});

// node_modules/discord.js/src/client/actions/MessageDelete.js
var require_MessageDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      let message;
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread())
          channel.messageCount--;
        message = this.getMessage(data, channel);
        if (message) {
          channel.messages.cache.delete(message.id);
          client.emit(Events.MessageDelete, message);
        }
      }
      return { message };
    }
  }
  module.exports = MessageDeleteAction;
});

// node_modules/discord.js/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Action = require_Action();
  var Events = require_Events();

  class MessageDeleteBulkAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread())
          channel.messageCount -= data.ids.length;
        const ids = data.ids;
        const messages = new Collection;
        for (const id of ids) {
          const message = this.getMessage({
            id,
            guild_id: data.guild_id
          }, channel, false);
          if (message) {
            messages.set(message.id, message);
            channel.messages.cache.delete(id);
          }
        }
        if (messages.size > 0)
          client.emit(Events.MessageBulkDelete, messages, channel);
        return { messages };
      }
      return {};
    }
  }
  module.exports = MessageDeleteBulkAction;
});

// node_modules/discord.js/src/client/actions/MessagePollVoteAdd.js
var require_MessagePollVoteAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessagePollVoteAddAction extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const { poll } = message;
      const answer = poll?.answers.get(data.answer_id);
      if (!answer)
        return false;
      answer.voteCount++;
      this.client.emit(Events.MessagePollVoteAdd, answer, data.user_id);
      return { poll };
    }
  }
  module.exports = MessagePollVoteAddAction;
});

// node_modules/discord.js/src/client/actions/MessagePollVoteRemove.js
var require_MessagePollVoteRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessagePollVoteRemoveAction extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const { poll } = message;
      const answer = poll?.answers.get(data.answer_id);
      if (!answer)
        return false;
      answer.voteCount--;
      this.client.emit(Events.MessagePollVoteRemove, answer, data.user_id);
      return { poll };
    }
  }
  module.exports = MessagePollVoteRemoveAction;
});

// node_modules/discord.js/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Partials = require_Partials();

  class MessageReactionAdd extends Action {
    handle(data, fromStructure = false) {
      if (!data.emoji)
        return false;
      const user = this.getUserFromMember(data);
      if (!user)
        return false;
      const channel = this.getChannel({
        id: data.channel_id,
        ..."guild_id" in data && { guild_id: data.guild_id },
        user_id: data.user_id,
        ...this.spreadInjectedData(data)
      });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const includePartial = this.client.options.partials.includes(Partials.Reaction);
      if (message.partial && !includePartial)
        return false;
      const reaction = message.reactions._add({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user.id === this.client.user.id,
        burst_colors: data.burst_colors
      });
      if (!reaction)
        return false;
      reaction._add(user, data.burst);
      if (fromStructure)
        return { message, reaction, user };
      this.client.emit(Events.MessageReactionAdd, reaction, user, { type: data.type, burst: data.burst });
      return { message, reaction, user };
    }
  }
  module.exports = MessageReactionAdd;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemove extends Action {
    handle(data) {
      if (!data.emoji)
        return false;
      const user = this.getUser(data);
      if (!user)
        return false;
      const channel = this.getChannel({
        id: data.channel_id,
        ..."guild_id" in data && { guild_id: data.guild_id },
        user_id: data.user_id
      });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message, user);
      if (!reaction)
        return false;
      reaction._remove(user, data.burst);
      this.client.emit(Events.MessageReactionRemove, reaction, user, { type: data.type, burst: data.burst });
      return { message, reaction, user };
    }
  }
  module.exports = MessageReactionRemove;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemoveAll extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const removed = message.reactions.cache.clone();
      message.reactions.cache.clear();
      this.client.emit(Events.MessageReactionRemoveAll, message, removed);
      return { message };
    }
  }
  module.exports = MessageReactionRemoveAll;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js
var require_MessageReactionRemoveEmoji = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemoveEmoji extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message);
      if (!reaction)
        return false;
      if (!message.partial)
        message.reactions.cache.delete(reaction.emoji.id ?? reaction.emoji.name);
      this.client.emit(Events.MessageReactionRemoveEmoji, reaction);
      return { reaction };
    }
  }
  module.exports = MessageReactionRemoveEmoji;
});

// node_modules/discord.js/src/client/actions/MessageUpdate.js
var require_MessageUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class MessageUpdateAction extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (channel) {
        if (!channel.isTextBased())
          return {};
        const { id, channel_id, guild_id, author, timestamp, type } = data;
        const message = this.getMessage({ id, channel_id, guild_id, author, timestamp, type }, channel);
        if (message) {
          const old = message._update(data);
          return {
            old,
            updated: message
          };
        }
      }
      return {};
    }
  }
  module.exports = MessageUpdateAction;
});

// node_modules/discord.js/src/client/actions/PresenceUpdate.js
var require_PresenceUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Partials = require_Partials();

  class PresenceUpdateAction extends Action {
    handle(data) {
      let user = this.client.users.cache.get(data.user.id);
      if (!user && (("username" in data.user) || this.client.options.partials.includes(Partials.User))) {
        user = this.client.users._add(data.user);
      }
      if (!user)
        return;
      if (data.user.username) {
        if (!user._equals(data.user))
          this.client.actions.UserUpdate.handle(data.user);
      }
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild)
        return;
      const oldPresence = guild.presences.cache.get(user.id)?._clone() ?? null;
      let member = guild.members.cache.get(user.id);
      if (!member && data.status !== "offline") {
        member = guild.members._add({
          user,
          deaf: false,
          mute: false
        });
        this.client.emit(Events.GuildMemberAvailable, member);
      }
      const newPresence = guild.presences._add(Object.assign(data, { guild }));
      if (this.client.listenerCount(Events.PresenceUpdate) && !newPresence.equals(oldPresence)) {
        this.client.emit(Events.PresenceUpdate, oldPresence, newPresence);
      }
    }
  }
  module.exports = PresenceUpdateAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceCreate.js
var require_StageInstanceCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
      if (channel) {
        const stageInstance = channel.guild.stageInstances._add(data);
        client.emit(Events.StageInstanceCreate, stageInstance);
        return { stageInstance };
      }
      return {};
    }
  }
  module.exports = StageInstanceCreateAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceDelete.js
var require_StageInstanceDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
      if (channel) {
        const stageInstance = channel.guild.stageInstances._add(data);
        if (stageInstance) {
          channel.guild.stageInstances.cache.delete(stageInstance.id);
          client.emit(Events.StageInstanceDelete, stageInstance);
          return { stageInstance };
        }
      }
      return {};
    }
  }
  module.exports = StageInstanceDeleteAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceUpdate.js
var require_StageInstanceUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
      if (channel) {
        const oldStageInstance = channel.guild.stageInstances.cache.get(data.id)?._clone() ?? null;
        const newStageInstance = channel.guild.stageInstances._add(data);
        client.emit(Events.StageInstanceUpdate, oldStageInstance, newStageInstance);
        return { oldStageInstance, newStageInstance };
      }
      return {};
    }
  }
  module.exports = StageInstanceUpdateAction;
});

// node_modules/discord.js/src/client/actions/ThreadCreate.js
var require_ThreadCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const thread = client.channels._add(data);
      if (!existing && thread) {
        client.emit(Events.ThreadCreate, thread, data.newly_created ?? false);
      }
      return { thread };
    }
  }
  module.exports = ThreadCreateAction;
});

// node_modules/discord.js/src/client/actions/ThreadDelete.js
var require_ThreadDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        client.channels._remove(thread.id);
        client.emit(Events.ThreadDelete, thread);
      }
      return { thread };
    }
  }
  module.exports = ThreadDeleteAction;
});

// node_modules/discord.js/src/client/actions/ThreadListSync.js
var require_ThreadListSync = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Action = require_Action();
  var Events = require_Events();

  class ThreadListSyncAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (!guild)
        return {};
      if (data.channel_ids) {
        for (const id of data.channel_ids) {
          const channel = client.channels.cache.get(id);
          if (channel)
            this.removeStale(channel);
        }
      } else {
        for (const channel of guild.channels.cache.values()) {
          this.removeStale(channel);
        }
      }
      const syncedThreads = data.threads.reduce((coll, rawThread) => {
        const thread = client.channels._add(rawThread);
        return coll.set(thread.id, thread);
      }, new Collection);
      for (const rawMember of Object.values(data.members)) {
        const thread = client.channels.cache.get(rawMember.id);
        if (thread) {
          thread.members._add(rawMember);
        }
      }
      client.emit(Events.ThreadListSync, syncedThreads, guild);
      return {
        syncedThreads
      };
    }
    removeStale(channel) {
      channel.threads?.cache.forEach((thread) => {
        if (!thread.archived) {
          this.client.channels._remove(thread.id);
        }
      });
    }
  }
  module.exports = ThreadListSyncAction;
});

// node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js
var require_ThreadMemberUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadMemberUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        const member = thread.members.cache.get(data.user_id);
        if (!member) {
          const newMember = thread.members._add(data);
          return { newMember };
        }
        const old = member._update(data);
        client.emit(Events.ThreadMemberUpdate, old, member);
      }
      return {};
    }
  }
  module.exports = ThreadMemberUpdateAction;
});

// node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js
var require_ThreadMembersUpdate = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Action = require_Action();
  var Events = require_Events();

  class ThreadMembersUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        thread.memberCount = data.member_count;
        const addedMembers = new Collection;
        const removedMembers = new Collection;
        data.added_members?.reduce((_addedMembers, addedMember) => _addedMembers.set(addedMember.user_id, thread.members._add(addedMember)), addedMembers);
        data.removed_member_ids?.reduce((removedMembersIds, removedMembersId) => {
          const threadMember = this.getThreadMember(removedMembersId, thread.members);
          if (threadMember)
            removedMembersIds.set(threadMember.id, threadMember);
          thread.members.cache.delete(removedMembersId);
          return removedMembersIds;
        }, removedMembers);
        if (addedMembers.size === 0 && removedMembers.size === 0) {
          return {};
        }
        client.emit(Events.ThreadMembersUpdate, addedMembers, removedMembers, thread);
      }
      return {};
    }
  }
  module.exports = ThreadMembersUpdateAction;
});

// node_modules/discord.js/src/structures/Typing.js
var require_Typing = __commonJS((exports, module) => {
  var Base = require_Base();

  class Typing extends Base {
    constructor(channel, user, data) {
      super(channel.client);
      this.channel = channel;
      this.user = user;
      this._patch(data);
    }
    _patch(data) {
      if ("timestamp" in data) {
        this.startedTimestamp = data.timestamp * 1000;
      }
    }
    inGuild() {
      return this.guild !== null;
    }
    get startedAt() {
      return new Date(this.startedTimestamp);
    }
    get guild() {
      return this.channel.guild ?? null;
    }
    get member() {
      return this.guild?.members.resolve(this.user) ?? null;
    }
  }
  module.exports = Typing;
});

// node_modules/discord.js/src/client/actions/TypingStart.js
var require_TypingStart = __commonJS((exports, module) => {
  var Action = require_Action();
  var Typing = require_Typing();
  var Events = require_Events();

  class TypingStart extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel)
        return;
      if (!channel.isTextBased()) {
        this.client.emit(Events.Warn, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
        return;
      }
      const user = this.getUserFromMember(data);
      if (user) {
        this.client.emit(Events.TypingStart, new Typing(channel, user, data));
      }
    }
  }
  module.exports = TypingStart;
});

// node_modules/discord.js/src/client/actions/UserUpdate.js
var require_UserUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class UserUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const newUser = data.id === client.user.id ? client.user : client.users.cache.get(data.id);
      const oldUser = newUser._update(data);
      if (!oldUser.equals(newUser)) {
        client.emit(Events.UserUpdate, oldUser, newUser);
        return {
          old: oldUser,
          updated: newUser
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = UserUpdateAction;
});

// node_modules/discord.js/src/client/actions/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var VoiceState = require_VoiceState();
  var Events = require_Events();

  class VoiceStateUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldState = guild.voiceStates.cache.get(data.user_id)?._clone() ?? new VoiceState(guild, { user_id: data.user_id });
        const newState = guild.voiceStates._add(data);
        let member = guild.members.cache.get(data.user_id);
        if (member && data.member) {
          member._patch(data.member);
        } else if (data.member?.user && data.member.joined_at) {
          member = guild.members._add(data.member);
        }
        if (member?.user.id === client.user.id) {
          client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
          client.voice.onVoiceStateUpdate(data);
        }
        client.emit(Events.VoiceStateUpdate, oldState, newState);
      }
    }
  }
  module.exports = VoiceStateUpdate;
});

// node_modules/discord.js/src/client/actions/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var Action = require_Action();
  var deprecationEmitted = false;

  class WebhooksUpdate extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (!channel)
        return;
      client.emit("webhooksUpdate", channel);
      if (client.emit("webhookUpdate", channel) && !deprecationEmitted) {
        deprecationEmitted = true;
        process2.emitWarning("The webhookUpdate event is deprecated. Use webhooksUpdate instead.", "DeprecationWarning");
      }
    }
  }
  module.exports = WebhooksUpdate;
});

// node_modules/discord.js/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS((exports, module) => {
  class ActionsManager {
    injectedUser = Symbol("djs.actions.injectedUser");
    injectedChannel = Symbol("djs.actions.injectedChannel");
    injectedMessage = Symbol("djs.actions.injectedMessage");
    constructor(client) {
      this.client = client;
      this.register(require_ApplicationCommandPermissionsUpdate());
      this.register(require_AutoModerationActionExecution2());
      this.register(require_AutoModerationRuleCreate());
      this.register(require_AutoModerationRuleDelete());
      this.register(require_AutoModerationRuleUpdate());
      this.register(require_ChannelCreate());
      this.register(require_ChannelDelete());
      this.register(require_ChannelUpdate());
      this.register(require_EntitlementCreate());
      this.register(require_EntitlementDelete());
      this.register(require_EntitlementUpdate());
      this.register(require_GuildAuditLogEntryCreate());
      this.register(require_GuildBanAdd());
      this.register(require_GuildBanRemove());
      this.register(require_GuildChannelsPositionUpdate());
      this.register(require_GuildDelete());
      this.register(require_GuildEmojiCreate());
      this.register(require_GuildEmojiDelete());
      this.register(require_GuildEmojiUpdate());
      this.register(require_GuildEmojisUpdate());
      this.register(require_GuildIntegrationsUpdate());
      this.register(require_GuildMemberRemove());
      this.register(require_GuildMemberUpdate());
      this.register(require_GuildRoleCreate());
      this.register(require_GuildRoleDelete());
      this.register(require_GuildRoleUpdate());
      this.register(require_GuildRolesPositionUpdate());
      this.register(require_GuildScheduledEventCreate());
      this.register(require_GuildScheduledEventDelete());
      this.register(require_GuildScheduledEventUpdate());
      this.register(require_GuildScheduledEventUserAdd());
      this.register(require_GuildScheduledEventUserRemove());
      this.register(require_GuildSoundboardSoundDelete());
      this.register(require_GuildStickerCreate());
      this.register(require_GuildStickerDelete());
      this.register(require_GuildStickerUpdate());
      this.register(require_GuildStickersUpdate());
      this.register(require_GuildUpdate());
      this.register(require_InteractionCreate());
      this.register(require_InviteCreate());
      this.register(require_InviteDelete());
      this.register(require_MessageCreate());
      this.register(require_MessageDelete());
      this.register(require_MessageDeleteBulk());
      this.register(require_MessagePollVoteAdd());
      this.register(require_MessagePollVoteRemove());
      this.register(require_MessageReactionAdd());
      this.register(require_MessageReactionRemove());
      this.register(require_MessageReactionRemoveAll());
      this.register(require_MessageReactionRemoveEmoji());
      this.register(require_MessageUpdate());
      this.register(require_PresenceUpdate());
      this.register(require_StageInstanceCreate());
      this.register(require_StageInstanceDelete());
      this.register(require_StageInstanceUpdate());
      this.register(require_ThreadCreate());
      this.register(require_ThreadDelete());
      this.register(require_ThreadListSync());
      this.register(require_ThreadMemberUpdate());
      this.register(require_ThreadMembersUpdate());
      this.register(require_TypingStart());
      this.register(require_UserUpdate());
      this.register(require_VoiceStateUpdate());
      this.register(require_WebhooksUpdate());
    }
    register(Action) {
      this[Action.name.replace(/Action$/, "")] = new Action(this.client);
    }
  }
  module.exports = ActionsManager;
});

// node_modules/discord.js/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS((exports, module) => {
  var Events = require_Events();

  class ClientVoiceManager {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
      this.adapters = new Map;
      client.on(Events.ShardDisconnect, (_, shardId) => {
        for (const [guildId, adapter] of this.adapters.entries()) {
          if (client.guilds.cache.get(guildId)?.shardId === shardId) {
            adapter.destroy();
          }
        }
      });
    }
    onVoiceServer(payload) {
      this.adapters.get(payload.guild_id)?.onVoiceServerUpdate(payload);
    }
    onVoiceStateUpdate(payload) {
      if (payload.guild_id && payload.session_id && payload.user_id === this.client.user?.id) {
        this.adapters.get(payload.guild_id)?.onVoiceStateUpdate(payload);
      }
    }
  }
  module.exports = ClientVoiceManager;
});

// node_modules/@discordjs/ws/node_modules/@discordjs/collection/dist/index.js
var require_dist9 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    findLast(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const val = entries[index][1];
        const key = entries[index][0];
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findLastKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const key = entries[index][0];
        const val = entries[index][1];
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    reduceRight(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      const entries = [...this.entries()];
      let accumulator;
      let index;
      if (initialValue === undefined) {
        if (entries.length === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = entries[entries.length - 1][1];
        index = entries.length - 1;
      } else {
        accumulator = initialValue;
        index = entries.length;
      }
      while (--index >= 0) {
        const key = entries[index][0];
        const val = entries[index][1];
        accumulator = fn(accumulator, val, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersection(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    union(other) {
      const coll = new this.constructor[Symbol.species](this);
      for (const [key, value] of other) {
        if (!coll.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    symmetricDifference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    toReversed() {
      return new this.constructor[Symbol.species](this).reverse();
    }
    toSorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.entries()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "2.1.1";
});

// node_modules/@discordjs/ws/dist/index.js
var require_dist10 = __commonJS((exports, module) => {
  async function managerToFetchingStrategyOptions(manager) {
    const {
      buildIdentifyThrottler,
      buildStrategy,
      retrieveSessionInfo,
      updateSessionInfo,
      shardCount,
      shardIds,
      rest,
      ...managerOptions
    } = manager.options;
    return {
      ...managerOptions,
      gatewayInformation: await manager.fetchGatewayInformation(),
      shardCount: await manager.getShardCount()
    };
  }
  var getInitialSendRateLimitState = function() {
    return {
      sent: 0,
      resetAt: Date.now() + 60000
    };
  };
  var __dirname = "D:\\Projects\\RainyTS\\node_modules\\@discordjs\\ws\\dist";
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    CloseCodes: () => CloseCodes,
    CompressionMethod: () => CompressionMethod,
    DefaultDeviceProperty: () => DefaultDeviceProperty,
    DefaultWebSocketManagerOptions: () => DefaultWebSocketManagerOptions,
    Encoding: () => Encoding,
    ImportantGatewayOpcodes: () => ImportantGatewayOpcodes,
    KnownNetworkErrorCodes: () => KnownNetworkErrorCodes,
    SimpleContextFetchingStrategy: () => SimpleContextFetchingStrategy,
    SimpleIdentifyThrottler: () => SimpleIdentifyThrottler,
    SimpleShardingStrategy: () => SimpleShardingStrategy,
    WebSocketManager: () => WebSocketManager,
    WebSocketShard: () => WebSocketShard,
    WebSocketShardDestroyRecovery: () => WebSocketShardDestroyRecovery,
    WebSocketShardEvents: () => WebSocketShardEvents,
    WebSocketShardStatus: () => WebSocketShardStatus,
    WorkerBootstrapper: () => WorkerBootstrapper,
    WorkerContextFetchingStrategy: () => WorkerContextFetchingStrategy,
    WorkerReceivePayloadOp: () => WorkerReceivePayloadOp,
    WorkerSendPayloadOp: () => WorkerSendPayloadOp,
    WorkerShardingStrategy: () => WorkerShardingStrategy,
    getInitialSendRateLimitState: () => getInitialSendRateLimitState,
    managerToFetchingStrategyOptions: () => managerToFetchingStrategyOptions,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  __name(managerToFetchingStrategyOptions, "managerToFetchingStrategyOptions");
  var SimpleContextFetchingStrategy = class _SimpleContextFetchingStrategy {
    constructor(manager, options) {
      this.manager = manager;
      this.options = options;
    }
    static {
      __name(this, "SimpleContextFetchingStrategy");
    }
    static throttlerCache = new WeakMap;
    static async ensureThrottler(manager) {
      const throttler = _SimpleContextFetchingStrategy.throttlerCache.get(manager);
      if (throttler) {
        return throttler;
      }
      const newThrottler = await manager.options.buildIdentifyThrottler(manager);
      _SimpleContextFetchingStrategy.throttlerCache.set(manager, newThrottler);
      return newThrottler;
    }
    async retrieveSessionInfo(shardId) {
      return this.manager.options.retrieveSessionInfo(shardId);
    }
    updateSessionInfo(shardId, sessionInfo) {
      return this.manager.options.updateSessionInfo(shardId, sessionInfo);
    }
    async waitForIdentify(shardId, signal) {
      const throttler = await _SimpleContextFetchingStrategy.ensureThrottler(this.manager);
      await throttler.waitForIdentify(shardId, signal);
    }
  };
  var import_node_worker_threads2 = import.meta.require("worker_threads");
  var import_collection2 = require_dist9();
  var import_node_events = import.meta.require("events");
  var import_node_path = import.meta.require("path");
  var import_node_worker_threads = import.meta.require("worker_threads");
  var import_collection = require_dist9();
  var WorkerSendPayloadOp = ((WorkerSendPayloadOp2) => {
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Connect"] = 0] = "Connect";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Destroy"] = 1] = "Destroy";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Send"] = 2] = "Send";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["SessionInfoResponse"] = 3] = "SessionInfoResponse";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["ShardIdentifyResponse"] = 4] = "ShardIdentifyResponse";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["FetchStatus"] = 5] = "FetchStatus";
    return WorkerSendPayloadOp2;
  })(WorkerSendPayloadOp || {});
  var WorkerReceivePayloadOp = ((WorkerReceivePayloadOp2) => {
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Connected"] = 0] = "Connected";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Destroyed"] = 1] = "Destroyed";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Event"] = 2] = "Event";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["RetrieveSessionInfo"] = 3] = "RetrieveSessionInfo";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["UpdateSessionInfo"] = 4] = "UpdateSessionInfo";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WaitForIdentify"] = 5] = "WaitForIdentify";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["FetchStatusResponse"] = 6] = "FetchStatusResponse";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WorkerReady"] = 7] = "WorkerReady";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["CancelIdentify"] = 8] = "CancelIdentify";
    return WorkerReceivePayloadOp2;
  })(WorkerReceivePayloadOp || {});
  var WorkerShardingStrategy = class {
    static {
      __name(this, "WorkerShardingStrategy");
    }
    manager;
    options;
    #workers = [];
    #workerByShardId = new import_collection.Collection;
    connectPromises = new import_collection.Collection;
    destroyPromises = new import_collection.Collection;
    fetchStatusPromises = new import_collection.Collection;
    waitForIdentifyControllers = new import_collection.Collection;
    throttler;
    constructor(manager, options) {
      this.manager = manager;
      this.options = options;
    }
    async spawn(shardIds) {
      const shardsPerWorker = this.options.shardsPerWorker === "all" ? shardIds.length : this.options.shardsPerWorker;
      const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
      const loops = Math.ceil(shardIds.length / shardsPerWorker);
      const promises = [];
      for (let idx = 0;idx < loops; idx++) {
        const slice = shardIds.slice(idx * shardsPerWorker, (idx + 1) * shardsPerWorker);
        const workerData2 = {
          ...strategyOptions,
          shardIds: slice
        };
        promises.push(this.setupWorker(workerData2));
      }
      await Promise.all(promises);
    }
    async connect() {
      const promises = [];
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const payload = {
          op: 0,
          shardId
        };
        const promise = new Promise((resolve2) => this.connectPromises.set(shardId, resolve2));
        worker.postMessage(payload);
        promises.push(promise);
      }
      await Promise.all(promises);
    }
    async destroy(options = {}) {
      const promises = [];
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const payload = {
          op: 1,
          shardId,
          options
        };
        promises.push(new Promise((resolve2) => this.destroyPromises.set(shardId, resolve2)).then(async () => worker.terminate()));
        worker.postMessage(payload);
      }
      this.#workers = [];
      this.#workerByShardId.clear();
      await Promise.all(promises);
    }
    send(shardId, data) {
      const worker = this.#workerByShardId.get(shardId);
      if (!worker) {
        throw new Error(`No worker found for shard ${shardId}`);
      }
      const payload = {
        op: 2,
        shardId,
        payload: data
      };
      worker.postMessage(payload);
    }
    async fetchStatus() {
      const statuses = new import_collection.Collection;
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const nonce = Math.random();
        const payload = {
          op: 5,
          shardId,
          nonce
        };
        const promise = new Promise((resolve2) => this.fetchStatusPromises.set(nonce, resolve2));
        worker.postMessage(payload);
        const status = await promise;
        statuses.set(shardId, status);
      }
      return statuses;
    }
    async setupWorker(workerData2) {
      const worker = new import_node_worker_threads.Worker(this.resolveWorkerPath(), { workerData: workerData2 });
      await (0, import_node_events.once)(worker, "online");
      await this.waitForWorkerReady(worker);
      worker.on("error", (err) => {
        throw err;
      }).on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => {
        if ("op" in payload) {
          await this.onMessage(worker, payload);
        } else {
          await this.options.unknownPayloadHandler?.(payload);
        }
      });
      this.#workers.push(worker);
      for (const shardId of workerData2.shardIds) {
        this.#workerByShardId.set(shardId, worker);
      }
    }
    resolveWorkerPath() {
      const path = this.options.workerPath;
      if (!path) {
        return (0, import_node_path.join)(__dirname, "defaultWorker.js");
      }
      if ((0, import_node_path.isAbsolute)(path)) {
        return path;
      }
      if (/^\.\.?[/\\]/.test(path)) {
        return (0, import_node_path.resolve)(path);
      }
      try {
        return import.meta.require.resolve(path);
      } catch {
        return (0, import_node_path.resolve)(path);
      }
    }
    async waitForWorkerReady(worker) {
      return new Promise((resolve2) => {
        const handler = __name((payload) => {
          if (payload.op === 7) {
            resolve2();
            worker.off("message", handler);
          }
        }, "handler");
        worker.on("message", handler);
      });
    }
    async onMessage(worker, payload) {
      switch (payload.op) {
        case 0: {
          this.connectPromises.get(payload.shardId)?.();
          this.connectPromises.delete(payload.shardId);
          break;
        }
        case 1: {
          this.destroyPromises.get(payload.shardId)?.();
          this.destroyPromises.delete(payload.shardId);
          break;
        }
        case 2: {
          this.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });
          break;
        }
        case 3: {
          const session = await this.manager.options.retrieveSessionInfo(payload.shardId);
          const response = {
            op: 3,
            nonce: payload.nonce,
            session
          };
          worker.postMessage(response);
          break;
        }
        case 4: {
          await this.manager.options.updateSessionInfo(payload.shardId, payload.session);
          break;
        }
        case 5: {
          const throttler = await this.ensureThrottler();
          try {
            const controller = new AbortController;
            this.waitForIdentifyControllers.set(payload.nonce, controller);
            await throttler.waitForIdentify(payload.shardId, controller.signal);
          } catch {
            return;
          }
          const response = {
            op: 4,
            nonce: payload.nonce,
            ok: true
          };
          worker.postMessage(response);
          break;
        }
        case 6: {
          this.fetchStatusPromises.get(payload.nonce)?.(payload.status);
          this.fetchStatusPromises.delete(payload.nonce);
          break;
        }
        case 7: {
          break;
        }
        case 8: {
          this.waitForIdentifyControllers.get(payload.nonce)?.abort();
          this.waitForIdentifyControllers.delete(payload.nonce);
          const response = {
            op: 4,
            nonce: payload.nonce,
            ok: false
          };
          worker.postMessage(response);
          break;
        }
        default: {
          await this.options.unknownPayloadHandler?.(payload);
          break;
        }
      }
    }
    async ensureThrottler() {
      this.throttler ??= await this.manager.options.buildIdentifyThrottler(this.manager);
      return this.throttler;
    }
  };
  var WorkerContextFetchingStrategy = class {
    constructor(options) {
      this.options = options;
      if (import_node_worker_threads2.isMainThread) {
        throw new Error("Cannot instantiate WorkerContextFetchingStrategy on the main thread");
      }
      import_node_worker_threads2.parentPort.on("message", (payload) => {
        if (payload.op === 3) {
          this.sessionPromises.get(payload.nonce)?.(payload.session);
          this.sessionPromises.delete(payload.nonce);
        }
        if (payload.op === 4) {
          const promise = this.waitForIdentifyPromises.get(payload.nonce);
          if (payload.ok) {
            promise?.resolve();
          } else {
            promise?.reject(promise.signal.reason);
          }
          this.waitForIdentifyPromises.delete(payload.nonce);
        }
      });
    }
    static {
      __name(this, "WorkerContextFetchingStrategy");
    }
    sessionPromises = new import_collection2.Collection;
    waitForIdentifyPromises = new import_collection2.Collection;
    async retrieveSessionInfo(shardId) {
      const nonce = Math.random();
      const payload = {
        op: 3,
        shardId,
        nonce
      };
      const promise = new Promise((resolve2) => this.sessionPromises.set(nonce, resolve2));
      import_node_worker_threads2.parentPort.postMessage(payload);
      return promise;
    }
    updateSessionInfo(shardId, sessionInfo) {
      const payload = {
        op: 4,
        shardId,
        session: sessionInfo
      };
      import_node_worker_threads2.parentPort.postMessage(payload);
    }
    async waitForIdentify(shardId, signal) {
      const nonce = Math.random();
      const payload = {
        op: 5,
        nonce,
        shardId
      };
      const promise = new Promise((resolve2, reject) => this.waitForIdentifyPromises.set(nonce, { signal, resolve: resolve2, reject }));
      import_node_worker_threads2.parentPort.postMessage(payload);
      const listener = __name(() => {
        const payload2 = {
          op: 8,
          nonce
        };
        import_node_worker_threads2.parentPort.postMessage(payload2);
      }, "listener");
      signal.addEventListener("abort", listener);
      try {
        await promise;
      } finally {
        signal.removeEventListener("abort", listener);
      }
    }
  };
  var import_collection6 = require_dist9();
  var import_node_buffer = import.meta.require("buffer");
  var import_node_events2 = import.meta.require("events");
  var import_node_timers = import.meta.require("timers");
  var import_promises2 = import.meta.require("timers/promises");
  var import_node_url = import.meta.require("url");
  var import_node_util = import.meta.require("util");
  var import_node_zlib = import.meta.require("zlib");
  var import_collection5 = require_dist9();
  var import_util2 = require_dist();
  var import_async_queue2 = require_cjs2();
  var import_async_event_emitter = require_dist3();
  var import_v102 = require_v106();
  var import_ws = import.meta.require("ws");
  var import_node_process = __toESM2(import.meta.require("process"));
  var import_collection4 = require_dist9();
  var import_util = require_dist();
  var import_v10 = require_v106();
  var import_promises = import.meta.require("timers/promises");
  var import_collection3 = require_dist9();
  var import_async_queue = require_cjs2();
  var SimpleIdentifyThrottler = class {
    constructor(maxConcurrency) {
      this.maxConcurrency = maxConcurrency;
    }
    static {
      __name(this, "SimpleIdentifyThrottler");
    }
    states = new import_collection3.Collection;
    async waitForIdentify(shardId, signal) {
      const key = shardId % this.maxConcurrency;
      const state = this.states.ensure(key, () => {
        return {
          queue: new import_async_queue.AsyncQueue,
          resetsAt: Number.POSITIVE_INFINITY
        };
      });
      await state.queue.wait({ signal });
      try {
        const diff = state.resetsAt - Date.now();
        if (diff > 0 && diff <= 5000) {
          const time = diff + Math.random() * 1500;
          await (0, import_promises.setTimeout)(time);
        }
        state.resetsAt = Date.now() + 5000;
      } finally {
        state.queue.shift();
      }
    }
  };
  var Encoding = ((Encoding2) => {
    Encoding2["JSON"] = "json";
    return Encoding2;
  })(Encoding || {});
  var CompressionMethod = ((CompressionMethod2) => {
    CompressionMethod2["ZlibStream"] = "zlib-stream";
    return CompressionMethod2;
  })(CompressionMethod || {});
  var DefaultDeviceProperty = `@discordjs/ws 1.2.2`;
  var getDefaultSessionStore = (0, import_util.lazy)(() => new import_collection4.Collection);
  var DefaultWebSocketManagerOptions = {
    async buildIdentifyThrottler(manager) {
      const info = await manager.fetchGatewayInformation();
      return new SimpleIdentifyThrottler(info.session_start_limit.max_concurrency);
    },
    buildStrategy: __name((manager) => new SimpleShardingStrategy(manager), "buildStrategy"),
    shardCount: null,
    shardIds: null,
    largeThreshold: null,
    initialPresence: null,
    identifyProperties: {
      browser: DefaultDeviceProperty,
      device: DefaultDeviceProperty,
      os: import_node_process.default.platform
    },
    version: import_v10.APIVersion,
    encoding: "json",
    compression: null,
    retrieveSessionInfo(shardId) {
      const store = getDefaultSessionStore();
      return store.get(shardId) ?? null;
    },
    updateSessionInfo(shardId, info) {
      const store = getDefaultSessionStore();
      if (info) {
        store.set(shardId, info);
      } else {
        store.delete(shardId);
      }
    },
    handshakeTimeout: 30000,
    helloTimeout: 60000,
    readyTimeout: 15000
  };
  var ImportantGatewayOpcodes = new Set([
    import_v10.GatewayOpcodes.Heartbeat,
    import_v10.GatewayOpcodes.Identify,
    import_v10.GatewayOpcodes.Resume
  ]);
  __name(getInitialSendRateLimitState, "getInitialSendRateLimitState");
  var KnownNetworkErrorCodes = new Set(["ECONNRESET", "ECONNREFUSED", "ETIMEDOUT", "EAI_AGAIN"]);
  var getZlibSync = (0, import_util2.lazy)(async () => import("zlib-sync").then((mod) => mod.default).catch(() => null));
  var WebSocketShardEvents = ((WebSocketShardEvents2) => {
    WebSocketShardEvents2["Closed"] = "closed";
    WebSocketShardEvents2["Debug"] = "debug";
    WebSocketShardEvents2["Dispatch"] = "dispatch";
    WebSocketShardEvents2["Error"] = "error";
    WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
    WebSocketShardEvents2["Hello"] = "hello";
    WebSocketShardEvents2["Ready"] = "ready";
    WebSocketShardEvents2["Resumed"] = "resumed";
    return WebSocketShardEvents2;
  })(WebSocketShardEvents || {});
  var WebSocketShardStatus = ((WebSocketShardStatus2) => {
    WebSocketShardStatus2[WebSocketShardStatus2["Idle"] = 0] = "Idle";
    WebSocketShardStatus2[WebSocketShardStatus2["Connecting"] = 1] = "Connecting";
    WebSocketShardStatus2[WebSocketShardStatus2["Resuming"] = 2] = "Resuming";
    WebSocketShardStatus2[WebSocketShardStatus2["Ready"] = 3] = "Ready";
    return WebSocketShardStatus2;
  })(WebSocketShardStatus || {});
  var WebSocketShardDestroyRecovery = ((WebSocketShardDestroyRecovery2) => {
    WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Reconnect"] = 0] = "Reconnect";
    WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Resume"] = 1] = "Resume";
    return WebSocketShardDestroyRecovery2;
  })(WebSocketShardDestroyRecovery || {});
  var CloseCodes = ((CloseCodes2) => {
    CloseCodes2[CloseCodes2["Normal"] = 1000] = "Normal";
    CloseCodes2[CloseCodes2["Resuming"] = 4200] = "Resuming";
    return CloseCodes2;
  })(CloseCodes || {});
  var WebSocketConstructor = (0, import_util2.shouldUseGlobalFetchAndWebSocket)() ? globalThis.WebSocket : import_ws.WebSocket;
  var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter {
    static {
      __name(this, "WebSocketShard");
    }
    connection = null;
    useIdentifyCompress = false;
    inflate = null;
    textDecoder = new import_node_util.TextDecoder;
    replayedEvents = 0;
    isAck = true;
    sendRateLimitState = getInitialSendRateLimitState();
    initialHeartbeatTimeoutController = null;
    heartbeatInterval = null;
    lastHeartbeatAt = -1;
    initialConnectResolved = false;
    failedToConnectDueToNetworkError = false;
    sendQueue = new import_async_queue2.AsyncQueue;
    timeoutAbortControllers = new import_collection5.Collection;
    strategy;
    id;
    #status = 0;
    get status() {
      return this.#status;
    }
    constructor(strategy, id) {
      super();
      this.strategy = strategy;
      this.id = id;
    }
    async connect() {
      const controller = new AbortController;
      let promise;
      if (!this.initialConnectResolved) {
        promise = Promise.race([
          (0, import_node_events2.once)(this, "ready", { signal: controller.signal }),
          (0, import_node_events2.once)(this, "resumed", { signal: controller.signal })
        ]);
      }
      this.internalConnect();
      try {
        await promise;
      } catch ({ error }) {
        throw error;
      } finally {
        controller.abort();
      }
      this.initialConnectResolved = true;
    }
    async internalConnect() {
      if (this.#status !== 0) {
        throw new Error("Tried to connect a shard that wasn't idle");
      }
      const { version: version2, encoding, compression } = this.strategy.options;
      const params = new import_node_url.URLSearchParams({ v: version2, encoding });
      if (compression) {
        const zlib = await getZlibSync();
        if (zlib) {
          params.append("compress", compression);
          this.inflate = new zlib.Inflate({
            chunkSize: 65535,
            to: "string"
          });
        } else if (!this.useIdentifyCompress) {
          this.useIdentifyCompress = true;
          console.warn("WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress");
        }
      }
      const session = await this.strategy.retrieveSessionInfo(this.id);
      const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
      this.debug([`Connecting to ${url}`]);
      const connection = new WebSocketConstructor(url, [], {
        handshakeTimeout: this.strategy.options.handshakeTimeout ?? undefined
      });
      connection.binaryType = "arraybuffer";
      connection.onmessage = (event) => {
        this.onMessage(event.data, event.data instanceof ArrayBuffer);
      };
      connection.onerror = (event) => {
        this.onError(event.error);
      };
      connection.onclose = (event) => {
        this.onClose(event.code);
      };
      connection.onopen = () => {
        this.sendRateLimitState = getInitialSendRateLimitState();
      };
      this.connection = connection;
      this.#status = 1;
      const { ok } = await this.waitForEvent("hello", this.strategy.options.helloTimeout);
      if (!ok) {
        return;
      }
      if (session?.shardCount === this.strategy.options.shardCount) {
        await this.resume(session);
      } else {
        await this.identify();
      }
    }
    async destroy(options = {}) {
      if (this.#status === 0) {
        this.debug(["Tried to destroy a shard that was idle"]);
        return;
      }
      if (!options.code) {
        options.code = options.recover === 1 ? 4200 : 1000;
      }
      this.debug([
        "Destroying shard",
        `Reason: ${options.reason ?? "none"}`,
        `Code: ${options.code}`,
        `Recover: ${options.recover === undefined ? "none" : WebSocketShardDestroyRecovery[options.recover]}`
      ]);
      this.isAck = true;
      if (this.heartbeatInterval) {
        (0, import_node_timers.clearInterval)(this.heartbeatInterval);
      }
      if (this.initialHeartbeatTimeoutController) {
        this.initialHeartbeatTimeoutController.abort();
        this.initialHeartbeatTimeoutController = null;
      }
      this.lastHeartbeatAt = -1;
      for (const controller of this.timeoutAbortControllers.values()) {
        controller.abort();
      }
      this.timeoutAbortControllers.clear();
      this.failedToConnectDueToNetworkError = false;
      if (options.recover !== 1) {
        await this.strategy.updateSessionInfo(this.id, null);
      }
      if (this.connection) {
        this.connection.onmessage = null;
        this.connection.onclose = null;
        const shouldClose = this.connection.readyState === import_ws.WebSocket.OPEN;
        this.debug([
          "Connection status during destroy",
          `Needs closing: ${shouldClose}`,
          `Ready state: ${this.connection.readyState}`
        ]);
        if (shouldClose) {
          let outerResolve;
          const promise = new Promise((resolve2) => {
            outerResolve = resolve2;
          });
          this.connection.onclose = outerResolve;
          this.connection.close(options.code, options.reason);
          await promise;
          this.emit("closed", { code: options.code });
        }
        this.connection.onerror = null;
      } else {
        this.debug(["Destroying a shard that has no connection; please open an issue on GitHub"]);
      }
      this.#status = 0;
      if (options.recover !== undefined) {
        await (0, import_promises2.setTimeout)(500);
        return this.internalConnect();
      }
    }
    async waitForEvent(event, timeoutDuration) {
      this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
      const timeoutController = new AbortController;
      const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration).unref() : null;
      this.timeoutAbortControllers.set(event, timeoutController);
      const closeController = new AbortController;
      try {
        const closed = await Promise.race([
          (0, import_node_events2.once)(this, event, { signal: timeoutController.signal }).then(() => false),
          (0, import_node_events2.once)(this, "closed", { signal: closeController.signal }).then(() => true)
        ]);
        return { ok: !closed };
      } catch {
        this.destroy({
          code: 1000,
          reason: "Something timed out or went wrong while waiting for an event",
          recover: 0
        });
        return { ok: false };
      } finally {
        if (timeout) {
          (0, import_node_timers.clearTimeout)(timeout);
        }
        this.timeoutAbortControllers.delete(event);
        if (!closeController.signal.aborted) {
          closeController.abort();
        }
      }
    }
    async send(payload) {
      if (!this.connection) {
        throw new Error("WebSocketShard wasn't connected");
      }
      if (ImportantGatewayOpcodes.has(payload.op)) {
        this.connection.send(JSON.stringify(payload));
        return;
      }
      if (this.#status !== 3 && !ImportantGatewayOpcodes.has(payload.op)) {
        this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
        try {
          await (0, import_node_events2.once)(this, "ready");
        } catch {
          return this.send(payload);
        }
      }
      await this.sendQueue.wait();
      const now = Date.now();
      if (now >= this.sendRateLimitState.resetAt) {
        this.sendRateLimitState = getInitialSendRateLimitState();
      }
      if (this.sendRateLimitState.sent + 1 >= 115) {
        const sleepFor = this.sendRateLimitState.resetAt - now + Math.random() * 1500;
        this.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);
        const controller = new AbortController;
        const interrupted = await Promise.race([
          (0, import_promises2.setTimeout)(sleepFor).then(() => false),
          (0, import_node_events2.once)(this, "closed", { signal: controller.signal }).then(() => true)
        ]);
        if (interrupted) {
          this.debug(["Connection closed while waiting for the send rate limit to reset, re-queueing payload"]);
          this.sendQueue.shift();
          return this.send(payload);
        }
        controller.abort();
      }
      this.sendRateLimitState.sent++;
      this.sendQueue.shift();
      this.connection.send(JSON.stringify(payload));
    }
    async identify() {
      this.debug(["Waiting for identify throttle"]);
      const controller = new AbortController;
      const closeHandler = __name(() => {
        controller.abort();
      }, "closeHandler");
      this.on("closed", closeHandler);
      try {
        await this.strategy.waitForIdentify(this.id, controller.signal);
      } catch {
        if (controller.signal.aborted) {
          this.debug(["Was waiting for an identify, but the shard closed in the meantime"]);
          return;
        }
        this.debug([
          "IContextFetchingStrategy#waitForIdentify threw an unknown error.",
          "If you're using a custom strategy, this is probably nothing to worry about.",
          "If you're not, please open an issue on GitHub."
        ]);
        await this.destroy({
          reason: "Identify throttling logic failed",
          recover: 1
        });
      } finally {
        this.off("closed", closeHandler);
      }
      this.debug([
        "Identifying",
        `shard id: ${this.id.toString()}`,
        `shard count: ${this.strategy.options.shardCount}`,
        `intents: ${this.strategy.options.intents}`,
        `compression: ${this.inflate ? "zlib-stream" : this.useIdentifyCompress ? "identify" : "none"}`
      ]);
      const d = {
        token: this.strategy.options.token,
        properties: this.strategy.options.identifyProperties,
        intents: this.strategy.options.intents,
        compress: this.useIdentifyCompress,
        shard: [this.id, this.strategy.options.shardCount]
      };
      if (this.strategy.options.largeThreshold) {
        d.large_threshold = this.strategy.options.largeThreshold;
      }
      if (this.strategy.options.initialPresence) {
        d.presence = this.strategy.options.initialPresence;
      }
      await this.send({
        op: import_v102.GatewayOpcodes.Identify,
        d
      });
      await this.waitForEvent("ready", this.strategy.options.readyTimeout);
    }
    async resume(session) {
      this.debug([
        "Resuming session",
        `resume url: ${session.resumeURL}`,
        `sequence: ${session.sequence}`,
        `shard id: ${this.id.toString()}`
      ]);
      this.#status = 2;
      this.replayedEvents = 0;
      return this.send({
        op: import_v102.GatewayOpcodes.Resume,
        d: {
          token: this.strategy.options.token,
          seq: session.sequence,
          session_id: session.sessionId
        }
      });
    }
    async heartbeat(requested = false) {
      if (!this.isAck && !requested) {
        return this.destroy({ reason: "Zombie connection", recover: 1 });
      }
      const session = await this.strategy.retrieveSessionInfo(this.id);
      await this.send({
        op: import_v102.GatewayOpcodes.Heartbeat,
        d: session?.sequence ?? null
      });
      this.lastHeartbeatAt = Date.now();
      this.isAck = false;
    }
    async unpackMessage(data, isBinary) {
      if (!isBinary) {
        try {
          return JSON.parse(data);
        } catch {
          return null;
        }
      }
      const decompressable = new Uint8Array(data);
      if (this.useIdentifyCompress) {
        return new Promise((resolve2, reject) => {
          (0, import_node_zlib.inflate)(decompressable, { chunkSize: 65535 }, (err, result) => {
            if (err) {
              reject(err);
              return;
            }
            resolve2(JSON.parse(this.textDecoder.decode(result)));
          });
        });
      }
      if (this.inflate) {
        const l = decompressable.length;
        const flush = l >= 4 && decompressable[l - 4] === 0 && decompressable[l - 3] === 0 && decompressable[l - 2] === 255 && decompressable[l - 1] === 255;
        const zlib = await getZlibSync();
        this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
        if (this.inflate.err) {
          this.emit("error", {
            error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`)
          });
        }
        if (!flush) {
          return null;
        }
        const { result } = this.inflate;
        if (!result) {
          return null;
        }
        return JSON.parse(typeof result === "string" ? result : this.textDecoder.decode(result));
      }
      this.debug([
        "Received a message we were unable to decompress",
        `isBinary: ${isBinary.toString()}`,
        `useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,
        `inflate: ${Boolean(this.inflate).toString()}`
      ]);
      return null;
    }
    async onMessage(data, isBinary) {
      const payload = await this.unpackMessage(data, isBinary);
      if (!payload) {
        return;
      }
      switch (payload.op) {
        case import_v102.GatewayOpcodes.Dispatch: {
          if (this.#status === 2) {
            this.replayedEvents++;
          }
          switch (payload.t) {
            case import_v102.GatewayDispatchEvents.Ready: {
              this.#status = 3;
              const session2 = {
                sequence: payload.s,
                sessionId: payload.d.session_id,
                shardId: this.id,
                shardCount: this.strategy.options.shardCount,
                resumeURL: payload.d.resume_gateway_url
              };
              await this.strategy.updateSessionInfo(this.id, session2);
              this.emit("ready", { data: payload.d });
              break;
            }
            case import_v102.GatewayDispatchEvents.Resumed: {
              this.#status = 3;
              this.debug([`Resumed and replayed ${this.replayedEvents} events`]);
              this.emit("resumed");
              break;
            }
            default: {
              break;
            }
          }
          const session = await this.strategy.retrieveSessionInfo(this.id);
          if (session) {
            if (payload.s > session.sequence) {
              await this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });
            }
          } else {
            this.debug([
              `Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`
            ]);
          }
          this.emit("dispatch", { data: payload });
          break;
        }
        case import_v102.GatewayOpcodes.Heartbeat: {
          await this.heartbeat(true);
          break;
        }
        case import_v102.GatewayOpcodes.Reconnect: {
          await this.destroy({
            reason: "Told to reconnect by Discord",
            recover: 1
          });
          break;
        }
        case import_v102.GatewayOpcodes.InvalidSession: {
          this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
          const session = await this.strategy.retrieveSessionInfo(this.id);
          if (payload.d && session) {
            await this.resume(session);
          } else {
            await this.destroy({
              reason: "Invalid session",
              recover: 0
            });
          }
          break;
        }
        case import_v102.GatewayOpcodes.Hello: {
          this.emit("hello");
          const jitter = Math.random();
          const firstWait = Math.floor(payload.d.heartbeat_interval * jitter);
          this.debug([`Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`]);
          try {
            const controller = new AbortController;
            this.initialHeartbeatTimeoutController = controller;
            await (0, import_promises2.setTimeout)(firstWait, undefined, { signal: controller.signal });
          } catch {
            this.debug(["Cancelled initial heartbeat due to #destroy being called"]);
            return;
          } finally {
            this.initialHeartbeatTimeoutController = null;
          }
          await this.heartbeat();
          this.debug([`First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`]);
          this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
          break;
        }
        case import_v102.GatewayOpcodes.HeartbeatAck: {
          this.isAck = true;
          const ackAt = Date.now();
          this.emit("heartbeat", {
            ackAt,
            heartbeatAt: this.lastHeartbeatAt,
            latency: ackAt - this.lastHeartbeatAt
          });
          break;
        }
      }
    }
    onError(error) {
      if ("code" in error && KnownNetworkErrorCodes.has(error.code)) {
        this.debug(["Failed to connect to the gateway URL specified due to a network error"]);
        this.failedToConnectDueToNetworkError = true;
        return;
      }
      this.emit("error", { error });
    }
    async onClose(code) {
      this.emit("closed", { code });
      switch (code) {
        case 1000: {
          return this.destroy({
            code,
            reason: "Got disconnected by Discord",
            recover: 0
          });
        }
        case 4200: {
          break;
        }
        case import_v102.GatewayCloseCodes.UnknownError: {
          this.debug([`An unknown error occurred: ${code}`]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.UnknownOpcode: {
          this.debug(["An invalid opcode was sent to Discord."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.DecodeError: {
          this.debug(["An invalid payload was sent to Discord."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.NotAuthenticated: {
          this.debug(["A request was somehow sent before the identify/resume payload."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.AuthenticationFailed: {
          this.emit("error", {
            error: new Error("Authentication failed")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.AlreadyAuthenticated: {
          this.debug(["More than one auth payload was sent."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.InvalidSeq: {
          this.debug(["An invalid sequence was sent."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.RateLimited: {
          this.debug(["The WebSocket rate limit has been hit, this should never happen"]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.SessionTimedOut: {
          this.debug(["Session timed out."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.InvalidShard: {
          this.emit("error", {
            error: new Error("Invalid shard")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.ShardingRequired: {
          this.emit("error", {
            error: new Error("Sharding is required")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.InvalidAPIVersion: {
          this.emit("error", {
            error: new Error("Used an invalid API version")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.InvalidIntents: {
          this.emit("error", {
            error: new Error("Used invalid intents")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.DisallowedIntents: {
          this.emit("error", {
            error: new Error("Used disallowed intents")
          });
          return this.destroy({ code });
        }
        default: {
          this.debug([
            `The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? "reconnect" : "resume"}.`
          ]);
          return this.destroy({
            code,
            recover: this.failedToConnectDueToNetworkError ? 0 : 1
          });
        }
      }
    }
    debug(messages) {
      this.emit("debug", { message: messages.join("\n	") });
    }
  };
  var SimpleShardingStrategy = class {
    static {
      __name(this, "SimpleShardingStrategy");
    }
    manager;
    shards = new import_collection6.Collection;
    constructor(manager) {
      this.manager = manager;
    }
    async spawn(shardIds) {
      const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
      for (const shardId of shardIds) {
        const strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);
        const shard = new WebSocketShard(strategy, shardId);
        for (const event of Object.values(WebSocketShardEvents)) {
          shard.on(event, (payload) => this.manager.emit(event, { ...payload, shardId }));
        }
        this.shards.set(shardId, shard);
      }
    }
    async connect() {
      const promises = [];
      for (const shard of this.shards.values()) {
        promises.push(shard.connect());
      }
      await Promise.all(promises);
    }
    async destroy(options) {
      const promises = [];
      for (const shard of this.shards.values()) {
        promises.push(shard.destroy(options));
      }
      await Promise.all(promises);
      this.shards.clear();
    }
    async send(shardId, payload) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} not found`);
      }
      return shard.send(payload);
    }
    async fetchStatus() {
      return this.shards.mapValues((shard) => shard.status);
    }
  };
  var import_node_worker_threads3 = import.meta.require("worker_threads");
  var import_collection7 = require_dist9();
  var WorkerBootstrapper = class {
    static {
      __name(this, "WorkerBootstrapper");
    }
    data = import_node_worker_threads3.workerData;
    shards = new import_collection7.Collection;
    constructor() {
      if (import_node_worker_threads3.isMainThread) {
        throw new Error("Expected WorkerBootstrap to not be used within the main thread");
      }
    }
    async connect(shardId) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} does not exist`);
      }
      await shard.connect();
    }
    async destroy(shardId, options) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} does not exist`);
      }
      await shard.destroy(options);
    }
    setupThreadEvents() {
      import_node_worker_threads3.parentPort.on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => {
        switch (payload.op) {
          case 0: {
            await this.connect(payload.shardId);
            const response = {
              op: 0,
              shardId: payload.shardId
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
          case 1: {
            await this.destroy(payload.shardId, payload.options);
            const response = {
              op: 1,
              shardId: payload.shardId
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
          case 2: {
            const shard = this.shards.get(payload.shardId);
            if (!shard) {
              throw new RangeError(`Shard ${payload.shardId} does not exist`);
            }
            await shard.send(payload.payload);
            break;
          }
          case 3: {
            break;
          }
          case 4: {
            break;
          }
          case 5: {
            const shard = this.shards.get(payload.shardId);
            if (!shard) {
              throw new Error(`Shard ${payload.shardId} does not exist`);
            }
            const response = {
              op: 6,
              status: shard.status,
              nonce: payload.nonce
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
        }
      });
    }
    async bootstrap(options = {}) {
      for (const shardId of this.data.shardIds) {
        const shard = new WebSocketShard(new WorkerContextFetchingStrategy(this.data), shardId);
        for (const event of options.forwardEvents ?? Object.values(WebSocketShardEvents)) {
          shard.on(event, (data) => {
            const payload = {
              op: 2,
              event,
              data,
              shardId
            };
            import_node_worker_threads3.parentPort.postMessage(payload);
          });
        }
        await options.shardCallback?.(shard);
        this.shards.set(shardId, shard);
      }
      this.setupThreadEvents();
      const message = {
        op: 7
      };
      import_node_worker_threads3.parentPort.postMessage(message);
    }
  };
  var import_util3 = require_dist();
  var import_util4 = require_dist();
  var import_async_event_emitter2 = require_dist3();
  var import_v103 = require_v106();
  (0, import_util4.polyfillDispose)();
  var WebSocketManager = class extends import_async_event_emitter2.AsyncEventEmitter {
    static {
      __name(this, "WebSocketManager");
    }
    options;
    gatewayInformation = null;
    shardIds = null;
    strategy;
    constructor(options) {
      super();
      this.options = { ...DefaultWebSocketManagerOptions, ...options };
      this.strategy = this.options.buildStrategy(this);
    }
    async fetchGatewayInformation(force = false) {
      if (this.gatewayInformation) {
        if (this.gatewayInformation.expiresAt <= Date.now()) {
          this.gatewayInformation = null;
        } else if (!force) {
          return this.gatewayInformation.data;
        }
      }
      const data = await this.options.rest.get(import_v103.Routes.gatewayBot());
      this.gatewayInformation = { data, expiresAt: Date.now() + (data.session_start_limit.reset_after || 5000) };
      return this.gatewayInformation.data;
    }
    async updateShardCount(shardCount) {
      await this.strategy.destroy({ reason: "User is adjusting their shards" });
      this.options.shardCount = shardCount;
      const shardIds = await this.getShardIds(true);
      await this.strategy.spawn(shardIds);
      return this;
    }
    async getShardCount() {
      if (this.options.shardCount) {
        return this.options.shardCount;
      }
      const shardIds = await this.getShardIds();
      return Math.max(...shardIds) + 1;
    }
    async getShardIds(force = false) {
      if (this.shardIds && !force) {
        return this.shardIds;
      }
      let shardIds;
      if (this.options.shardIds) {
        if (Array.isArray(this.options.shardIds)) {
          shardIds = this.options.shardIds;
        } else {
          const { start, end } = this.options.shardIds;
          shardIds = [...(0, import_util3.range)({ start, end: end + 1 })];
        }
      } else {
        const data = await this.fetchGatewayInformation();
        shardIds = [...(0, import_util3.range)(this.options.shardCount ?? data.shards)];
      }
      this.shardIds = shardIds;
      return shardIds;
    }
    async connect() {
      const shardCount = await this.getShardCount();
      await this.updateShardCount(shardCount);
      const shardIds = await this.getShardIds();
      const data = await this.fetchGatewayInformation();
      if (data.session_start_limit.remaining < shardIds.length) {
        throw new Error(`Not enough sessions remaining to spawn ${shardIds.length} shards; only ${data.session_start_limit.remaining} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`);
      }
      await this.strategy.connect();
    }
    destroy(options) {
      return this.strategy.destroy(options);
    }
    send(shardId, payload) {
      return this.strategy.send(shardId, payload);
    }
    fetchStatus() {
      return this.strategy.fetchStatus();
    }
    async[Symbol.asyncDispose]() {
      await this.destroy();
    }
  };
  var version = "1.2.2";
});

// node_modules/discord.js/src/util/WebSocketShardEvents.js
var require_WebSocketShardEvents = __commonJS((exports, module) => {
  module.exports = {
    Close: "close",
    Destroyed: "destroyed",
    InvalidSession: "invalidSession",
    Ready: "ready",
    Resumed: "resumed",
    AllReady: "allReady"
  };
});

// node_modules/discord.js/src/client/websocket/WebSocketShard.js
var require_WebSocketShard = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var process2 = import.meta.require("process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = import.meta.require("timers");
  var { GatewayIntentBits } = require_v106();
  var Status = require_Status();
  var WebSocketShardEvents = require_WebSocketShardEvents();
  var deprecationEmittedForImportant = false;

  class WebSocketShard extends EventEmitter {
    constructor(manager, id) {
      super();
      this.manager = manager;
      this.id = id;
      this.status = Status.Idle;
      this.closeSequence = 0;
      this.ping = -1;
      this.lastPingTimestamp = -1;
      Object.defineProperty(this, "expectedGuilds", { value: null, writable: true });
      Object.defineProperty(this, "readyTimeout", { value: null, writable: true });
      Object.defineProperty(this, "sessionInfo", { value: null, writable: true });
    }
    debug(messages) {
      this.manager.debug(messages, this.id);
    }
    emitClose(event = {
      code: 1011,
      reason: "INTERNAL_ERROR",
      wasClean: false
    }) {
      this.debug([
        "[CLOSE]",
        `Event Code: ${event.code}`,
        `Clean     : ${event.wasClean}`,
        `Reason    : ${event.reason ?? "No reason received"}`
      ]);
      this.emit(WebSocketShardEvents.Close, event);
    }
    onReadyPacket(packet) {
      if (!packet) {
        this.debug([`Received broken packet: '${packet}'.`]);
        return;
      }
      this.emit(WebSocketShardEvents.Ready);
      this.expectedGuilds = new Set(packet.guilds.map((guild) => guild.id));
      this.status = Status.WaitingForGuilds;
    }
    gotGuild(guildId) {
      this.expectedGuilds.delete(guildId);
      this.checkReady();
    }
    checkReady() {
      if (this.readyTimeout) {
        clearTimeout2(this.readyTimeout);
        this.readyTimeout = null;
      }
      if (!this.expectedGuilds.size) {
        this.debug(["Shard received all its guilds. Marking as fully ready."]);
        this.status = Status.Ready;
        this.emit(WebSocketShardEvents.AllReady);
        return;
      }
      const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);
      const { waitGuildTimeout } = this.manager.client.options;
      this.readyTimeout = setTimeout2(() => {
        this.debug([
          hasGuildsIntent ? `Shard did not receive any guild packets in ${waitGuildTimeout} ms.` : "Shard will not receive anymore guild packets.",
          `Unavailable guild count: ${this.expectedGuilds.size}`
        ]);
        this.readyTimeout = null;
        this.status = Status.Ready;
        this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);
      }, hasGuildsIntent ? waitGuildTimeout : 0).unref();
    }
    send(data, important = false) {
      if (important && !deprecationEmittedForImportant) {
        process2.emitWarning("Sending important payloads explicitly is deprecated. They are determined by their opcode implicitly now.", "DeprecationWarning");
        deprecationEmittedForImportant = true;
      }
      this.manager._ws.send(this.id, data);
    }
  }
  module.exports = WebSocketShard;
});

// node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js
var require_APPLICATION_COMMAND_PERMISSIONS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ApplicationCommandPermissionsUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js
var require_AUTO_MODERATION_ACTION_EXECUTION = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationActionExecution.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js
var require_AUTO_MODERATION_RULE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js
var require_AUTO_MODERATION_RULE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js
var require_AUTO_MODERATION_RULE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js
var require_CHANNEL_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ChannelCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js
var require_CHANNEL_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ChannelDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js
var require_CHANNEL_PINS_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const channel = client.channels.cache.get(data.channel_id);
    const time = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
    if (channel) {
      channel.lastPinTimestamp = time;
      client.emit(Events.ChannelPinsUpdate, channel, time);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js
var require_CHANNEL_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.ChannelUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/ENTITLEMENT_CREATE.js
var require_ENTITLEMENT_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.EntitlementCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/ENTITLEMENT_DELETE.js
var require_ENTITLEMENT_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.EntitlementDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/ENTITLEMENT_UPDATE.js
var require_ENTITLEMENT_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.EntitlementUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js
var require_GUILD_AUDIT_LOG_ENTRY_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildAuditLogEntryCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js
var require_GUILD_BAN_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildBanAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js
var require_GUILD_BAN_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildBanRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js
var require_GUILD_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  var Status = require_Status();
  module.exports = (client, { d: data }, shard) => {
    let guild = client.guilds.cache.get(data.id);
    if (guild) {
      if (!guild.available && !data.unavailable) {
        guild._patch(data);
        client.emit(Events.GuildAvailable, guild);
      }
    } else {
      data.shardId = shard.id;
      guild = client.guilds._add(data);
      if (client.ws.status === Status.Ready) {
        client.emit(Events.GuildCreate, guild);
      }
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js
var require_GUILD_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js
var require_GUILD_EMOJIS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildEmojisUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js
var require_GUILD_INTEGRATIONS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildIntegrationsUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js
var require_GUILD_MEMBERS_CHUNK = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const members = new Collection;
    for (const member of data.members)
      members.set(member.user.id, guild.members._add(member));
    if (data.presences) {
      for (const presence of data.presences)
        guild.presences._add(Object.assign(presence, { guild }));
    }
    client.emit(Events.GuildMembersChunk, members, guild, {
      index: data.chunk_index,
      count: data.chunk_count,
      notFound: data.not_found,
      nonce: data.nonce
    });
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js
var require_GUILD_MEMBER_ADD = __commonJS((exports, module) => {
  var Events = require_Events();
  var Status = require_Status();
  module.exports = (client, { d: data }, shard) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (guild) {
      guild.memberCount++;
      const member = guild.members._add(data);
      if (shard.status === Status.Ready) {
        client.emit(Events.GuildMemberAdd, member);
      }
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js
var require_GUILD_MEMBER_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet, shard) => {
    client.actions.GuildMemberRemove.handle(packet.d, shard);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js
var require_GUILD_MEMBER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet, shard) => {
    client.actions.GuildMemberUpdate.handle(packet.d, shard);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js
var require_GUILD_ROLE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js
var require_GUILD_ROLE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js
var require_GUILD_ROLE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js
var require_GUILD_SCHEDULED_EVENT_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js
var require_GUILD_SCHEDULED_EVENT_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js
var require_GUILD_SCHEDULED_EVENT_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js
var require_GUILD_SCHEDULED_EVENT_USER_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUserAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js
var require_GUILD_SCHEDULED_EVENT_USER_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUserRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUNDS_UPDATE.js
var require_GUILD_SOUNDBOARD_SOUNDS_UPDATE = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const soundboardSounds = new Collection;
    for (const soundboardSound of data.soundboard_sounds) {
      soundboardSounds.set(soundboardSound.sound_id, guild.soundboardSounds._add(soundboardSound));
    }
    client.emit(Events.GuildSoundboardSoundsUpdate, soundboardSounds, guild);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUND_CREATE.js
var require_GUILD_SOUNDBOARD_SOUND_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const soundboardSound = guild.soundboardSounds._add(data);
    client.emit(Events.GuildSoundboardSoundCreate, soundboardSound);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUND_DELETE.js
var require_GUILD_SOUNDBOARD_SOUND_DELETE = __commonJS((exports, module) => {
  module.exports = (client, { d: data }) => {
    client.actions.GuildSoundboardSoundDelete.handle(data);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUND_UPDATE.js
var require_GUILD_SOUNDBOARD_SOUND_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const oldGuildSoundboardSound = guild.soundboardSounds.cache.get(data.sound_id)?._clone() ?? null;
    const newGuildSoundboardSound = guild.soundboardSounds._add(data);
    client.emit(Events.GuildSoundboardSoundUpdate, oldGuildSoundboardSound, newGuildSoundboardSound);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js
var require_GUILD_STICKERS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildStickersUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js
var require_GUILD_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js
var require_INTERACTION_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InteractionCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js
var require_INVITE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InviteCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js
var require_INVITE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InviteDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js
var require_MESSAGE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js
var require_MESSAGE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js
var require_MESSAGE_DELETE_BULK = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageDeleteBulk.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_POLL_VOTE_ADD.js
var require_MESSAGE_POLL_VOTE_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessagePollVoteAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_POLL_VOTE_REMOVE.js
var require_MESSAGE_POLL_VOTE_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessagePollVoteRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js
var require_MESSAGE_REACTION_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js
var require_MESSAGE_REACTION_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js
var require_MESSAGE_REACTION_REMOVE_ALL = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemoveAll.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js
var require_MESSAGE_REACTION_REMOVE_EMOJI = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemoveEmoji.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js
var require_MESSAGE_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.MessageUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.MessageUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js
var require_PRESENCE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.PresenceUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/structures/ClientUser.js
var require_ClientUser = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var User = require_User();
  var { resolveImage } = require_DataResolver();

  class ClientUser extends User {
    _patch(data) {
      super._patch(data);
      if ("verified" in data) {
        this.verified = data.verified;
      }
      if ("mfa_enabled" in data) {
        this.mfaEnabled = typeof data.mfa_enabled === "boolean" ? data.mfa_enabled : null;
      } else {
        this.mfaEnabled ??= null;
      }
      if ("token" in data)
        this.client.token = data.token;
    }
    get presence() {
      return this.client.presence;
    }
    async edit({ username, avatar, banner }) {
      const data = await this.client.rest.patch(Routes.user(), {
        body: {
          username,
          avatar: avatar && await resolveImage(avatar),
          banner: banner && await resolveImage(banner)
        }
      });
      this.client.token = data.token;
      this.client.rest.setToken(data.token);
      const { updated } = this.client.actions.UserUpdate.handle(data);
      return updated ?? this;
    }
    setUsername(username) {
      return this.edit({ username });
    }
    setAvatar(avatar) {
      return this.edit({ avatar });
    }
    setBanner(banner) {
      return this.edit({ banner });
    }
    setPresence(data) {
      return this.client.presence.set(data);
    }
    setStatus(status, shardId) {
      return this.setPresence({ status, shardId });
    }
    setActivity(name, options = {}) {
      if (!name)
        return this.setPresence({ activities: [], shardId: options.shardId });
      const activity = Object.assign({}, options, typeof name === "object" ? name : { name });
      return this.setPresence({ activities: [activity], shardId: activity.shardId });
    }
    setAFK(afk = true, shardId) {
      return this.setPresence({ afk, shardId });
    }
  }
  module.exports = ClientUser;
});

// node_modules/discord.js/src/client/websocket/handlers/READY.js
var require_READY = __commonJS((exports, module) => {
  var ClientApplication = require_ClientApplication();
  var ClientUser;
  module.exports = (client, { d: data }, shard) => {
    if (client.user) {
      client.user._patch(data.user);
    } else {
      ClientUser ??= require_ClientUser();
      client.user = new ClientUser(client, data.user);
      client.users.cache.set(client.user.id, client.user);
    }
    for (const guild of data.guilds) {
      guild.shardId = shard.id;
      client.guilds._add(guild);
    }
    if (client.application) {
      client.application._patch(data.application);
    } else {
      client.application = new ClientApplication(client, data.application);
    }
    shard.checkReady();
  };
});

// node_modules/discord.js/src/client/websocket/handlers/RESUMED.js
var require_RESUMED = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet, shard) => {
    const replayed = shard.sessionInfo.sequence - shard.closeSequence;
    client.emit(Events.ShardResume, shard.id, replayed);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/SOUNDBOARD_SOUNDS.js
var require_SOUNDBOARD_SOUNDS = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const soundboardSounds = new Collection;
    for (const soundboardSound of data.soundboard_sounds) {
      soundboardSounds.set(soundboardSound.sound_id, guild.soundboardSounds._add(soundboardSound));
    }
    client.emit(Events.SoundboardSounds, soundboardSounds, guild);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js
var require_STAGE_INSTANCE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js
var require_STAGE_INSTANCE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js
var require_STAGE_INSTANCE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/SUBSCRIPTION_CREATE.js
var require_SUBSCRIPTION_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const subscription = client.application.subscriptions._add(data);
    client.emit(Events.SubscriptionCreate, subscription);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/SUBSCRIPTION_DELETE.js
var require_SUBSCRIPTION_DELETE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const subscription = client.application.subscriptions._add(data, false);
    client.application.subscriptions.cache.delete(subscription.id);
    client.emit(Events.SubscriptionDelete, subscription);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/SUBSCRIPTION_UPDATE.js
var require_SUBSCRIPTION_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const oldSubscription = client.application.subscriptions.cache.get(data.id)?._clone() ?? null;
    const newSubscription = client.application.subscriptions._add(data);
    client.emit(Events.SubscriptionUpdate, oldSubscription, newSubscription);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js
var require_THREAD_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js
var require_THREAD_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js
var require_THREAD_LIST_SYNC = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadListSync.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js
var require_THREAD_MEMBERS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadMembersUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js
var require_THREAD_MEMBER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadMemberUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js
var require_THREAD_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.ThreadUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js
var require_TYPING_START = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.TypingStart.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js
var require_USER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.UserUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/structures/VoiceChannelEffect.js
var require_VoiceChannelEffect = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class VoiceChannelEffect {
    constructor(data, guild) {
      this.guild = guild;
      this.channelId = data.channel_id;
      this.userId = data.user_id;
      this.emoji = data.emoji ? new Emoji(guild.client, data.emoji) : null;
      this.animationType = data.animation_type ?? null;
      this.animationId = data.animation_id ?? null;
      this.soundId = data.sound_id ?? null;
      this.soundVolume = data.sound_volume ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get soundboardSound() {
      return this.guild.soundboardSounds.cache.get(this.soundId) ?? null;
    }
  }
  module.exports = VoiceChannelEffect;
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_CHANNEL_EFFECT_SEND.js
var require_VOICE_CHANNEL_EFFECT_SEND = __commonJS((exports, module) => {
  var VoiceChannelEffect = require_VoiceChannelEffect();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    client.emit(Events.VoiceChannelEffectSend, new VoiceChannelEffect(data, guild));
  };
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js
var require_VOICE_SERVER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.emit("debug", `[VOICE] received voice server: ${JSON.stringify(packet)}`);
    client.voice.onVoiceServer(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js
var require_VOICE_STATE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.VoiceStateUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js
var require_WEBHOOKS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.WebhooksUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/index.js
var require_handlers = __commonJS((exports, module) => {
  var handlers = Object.fromEntries([
    ["APPLICATION_COMMAND_PERMISSIONS_UPDATE", require_APPLICATION_COMMAND_PERMISSIONS_UPDATE()],
    ["AUTO_MODERATION_ACTION_EXECUTION", require_AUTO_MODERATION_ACTION_EXECUTION()],
    ["AUTO_MODERATION_RULE_CREATE", require_AUTO_MODERATION_RULE_CREATE()],
    ["AUTO_MODERATION_RULE_DELETE", require_AUTO_MODERATION_RULE_DELETE()],
    ["AUTO_MODERATION_RULE_UPDATE", require_AUTO_MODERATION_RULE_UPDATE()],
    ["CHANNEL_CREATE", require_CHANNEL_CREATE()],
    ["CHANNEL_DELETE", require_CHANNEL_DELETE()],
    ["CHANNEL_PINS_UPDATE", require_CHANNEL_PINS_UPDATE()],
    ["CHANNEL_UPDATE", require_CHANNEL_UPDATE()],
    ["ENTITLEMENT_CREATE", require_ENTITLEMENT_CREATE()],
    ["ENTITLEMENT_DELETE", require_ENTITLEMENT_DELETE()],
    ["ENTITLEMENT_UPDATE", require_ENTITLEMENT_UPDATE()],
    ["GUILD_AUDIT_LOG_ENTRY_CREATE", require_GUILD_AUDIT_LOG_ENTRY_CREATE()],
    ["GUILD_BAN_ADD", require_GUILD_BAN_ADD()],
    ["GUILD_BAN_REMOVE", require_GUILD_BAN_REMOVE()],
    ["GUILD_CREATE", require_GUILD_CREATE()],
    ["GUILD_DELETE", require_GUILD_DELETE()],
    ["GUILD_EMOJIS_UPDATE", require_GUILD_EMOJIS_UPDATE()],
    ["GUILD_INTEGRATIONS_UPDATE", require_GUILD_INTEGRATIONS_UPDATE()],
    ["GUILD_MEMBERS_CHUNK", require_GUILD_MEMBERS_CHUNK()],
    ["GUILD_MEMBER_ADD", require_GUILD_MEMBER_ADD()],
    ["GUILD_MEMBER_REMOVE", require_GUILD_MEMBER_REMOVE()],
    ["GUILD_MEMBER_UPDATE", require_GUILD_MEMBER_UPDATE()],
    ["GUILD_ROLE_CREATE", require_GUILD_ROLE_CREATE()],
    ["GUILD_ROLE_DELETE", require_GUILD_ROLE_DELETE()],
    ["GUILD_ROLE_UPDATE", require_GUILD_ROLE_UPDATE()],
    ["GUILD_SCHEDULED_EVENT_CREATE", require_GUILD_SCHEDULED_EVENT_CREATE()],
    ["GUILD_SCHEDULED_EVENT_DELETE", require_GUILD_SCHEDULED_EVENT_DELETE()],
    ["GUILD_SCHEDULED_EVENT_UPDATE", require_GUILD_SCHEDULED_EVENT_UPDATE()],
    ["GUILD_SCHEDULED_EVENT_USER_ADD", require_GUILD_SCHEDULED_EVENT_USER_ADD()],
    ["GUILD_SCHEDULED_EVENT_USER_REMOVE", require_GUILD_SCHEDULED_EVENT_USER_REMOVE()],
    ["GUILD_SOUNDBOARD_SOUNDS_UPDATE", require_GUILD_SOUNDBOARD_SOUNDS_UPDATE()],
    ["GUILD_SOUNDBOARD_SOUND_CREATE", require_GUILD_SOUNDBOARD_SOUND_CREATE()],
    ["GUILD_SOUNDBOARD_SOUND_DELETE", require_GUILD_SOUNDBOARD_SOUND_DELETE()],
    ["GUILD_SOUNDBOARD_SOUND_UPDATE", require_GUILD_SOUNDBOARD_SOUND_UPDATE()],
    ["GUILD_STICKERS_UPDATE", require_GUILD_STICKERS_UPDATE()],
    ["GUILD_UPDATE", require_GUILD_UPDATE()],
    ["INTERACTION_CREATE", require_INTERACTION_CREATE()],
    ["INVITE_CREATE", require_INVITE_CREATE()],
    ["INVITE_DELETE", require_INVITE_DELETE()],
    ["MESSAGE_CREATE", require_MESSAGE_CREATE()],
    ["MESSAGE_DELETE", require_MESSAGE_DELETE()],
    ["MESSAGE_DELETE_BULK", require_MESSAGE_DELETE_BULK()],
    ["MESSAGE_POLL_VOTE_ADD", require_MESSAGE_POLL_VOTE_ADD()],
    ["MESSAGE_POLL_VOTE_REMOVE", require_MESSAGE_POLL_VOTE_REMOVE()],
    ["MESSAGE_REACTION_ADD", require_MESSAGE_REACTION_ADD()],
    ["MESSAGE_REACTION_REMOVE", require_MESSAGE_REACTION_REMOVE()],
    ["MESSAGE_REACTION_REMOVE_ALL", require_MESSAGE_REACTION_REMOVE_ALL()],
    ["MESSAGE_REACTION_REMOVE_EMOJI", require_MESSAGE_REACTION_REMOVE_EMOJI()],
    ["MESSAGE_UPDATE", require_MESSAGE_UPDATE()],
    ["PRESENCE_UPDATE", require_PRESENCE_UPDATE()],
    ["READY", require_READY()],
    ["RESUMED", require_RESUMED()],
    ["SOUNDBOARD_SOUNDS", require_SOUNDBOARD_SOUNDS()],
    ["STAGE_INSTANCE_CREATE", require_STAGE_INSTANCE_CREATE()],
    ["STAGE_INSTANCE_DELETE", require_STAGE_INSTANCE_DELETE()],
    ["STAGE_INSTANCE_UPDATE", require_STAGE_INSTANCE_UPDATE()],
    ["SUBSCRIPTION_CREATE", require_SUBSCRIPTION_CREATE()],
    ["SUBSCRIPTION_DELETE", require_SUBSCRIPTION_DELETE()],
    ["SUBSCRIPTION_UPDATE", require_SUBSCRIPTION_UPDATE()],
    ["THREAD_CREATE", require_THREAD_CREATE()],
    ["THREAD_DELETE", require_THREAD_DELETE()],
    ["THREAD_LIST_SYNC", require_THREAD_LIST_SYNC()],
    ["THREAD_MEMBERS_UPDATE", require_THREAD_MEMBERS_UPDATE()],
    ["THREAD_MEMBER_UPDATE", require_THREAD_MEMBER_UPDATE()],
    ["THREAD_UPDATE", require_THREAD_UPDATE()],
    ["TYPING_START", require_TYPING_START()],
    ["USER_UPDATE", require_USER_UPDATE()],
    ["VOICE_CHANNEL_EFFECT_SEND", require_VOICE_CHANNEL_EFFECT_SEND()],
    ["VOICE_SERVER_UPDATE", require_VOICE_SERVER_UPDATE()],
    ["VOICE_STATE_UPDATE", require_VOICE_STATE_UPDATE()],
    ["WEBHOOKS_UPDATE", require_WEBHOOKS_UPDATE()]
  ]);
  module.exports = handlers;
});

// node_modules/discord.js/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var process2 = import.meta.require("process");
  var { setImmediate } = import.meta.require("timers");
  var { Collection } = require_dist6();
  var {
    WebSocketManager: WSWebSocketManager,
    WebSocketShardEvents: WSWebSocketShardEvents,
    CompressionMethod,
    CloseCodes
  } = require_dist10();
  var { GatewayCloseCodes, GatewayDispatchEvents } = require_v106();
  var WebSocketShard = require_WebSocketShard();
  var PacketHandlers = require_handlers();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var Events = require_Events();
  var Status = require_Status();
  var WebSocketShardEvents = require_WebSocketShardEvents();
  var zlib;
  try {
    zlib = (()=>{throw new Error(`Cannot require module "zlib-sync"`);})();
  } catch {
  }
  var BeforeReadyWhitelist = [
    GatewayDispatchEvents.Ready,
    GatewayDispatchEvents.Resumed,
    GatewayDispatchEvents.GuildCreate,
    GatewayDispatchEvents.GuildDelete,
    GatewayDispatchEvents.GuildMembersChunk,
    GatewayDispatchEvents.GuildMemberAdd,
    GatewayDispatchEvents.GuildMemberRemove
  ];
  var WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];
  var UNRECOVERABLE_CLOSE_CODES = [
    GatewayCloseCodes.AuthenticationFailed,
    GatewayCloseCodes.InvalidShard,
    GatewayCloseCodes.ShardingRequired,
    GatewayCloseCodes.InvalidAPIVersion,
    GatewayCloseCodes.InvalidIntents,
    GatewayCloseCodes.DisallowedIntents
  ];
  var reasonIsDeprecated = "the reason property is deprecated, use the code property to determine the reason";
  var deprecationEmittedForInvalidSessionEvent = false;
  var deprecationEmittedForDestroyedEvent = false;

  class WebSocketManager extends EventEmitter {
    constructor(client) {
      super();
      Object.defineProperty(this, "client", { value: client });
      this.gateway = null;
      this.shards = new Collection;
      Object.defineProperty(this, "packetQueue", { value: [] });
      this.status = Status.Idle;
      this.destroyed = false;
      this._ws = null;
    }
    get ping() {
      const sum = this.shards.reduce((a, b) => a + b.ping, 0);
      return sum / this.shards.size;
    }
    debug(messages, shardId) {
      this.client.emit(Events.Debug, `[WS => ${typeof shardId === "number" ? `Shard ${shardId}` : "Manager"}] ${messages.join("\n\t")}`);
    }
    async connect() {
      const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);
      const { shards, shardCount, intents, ws } = this.client.options;
      if (this._ws && this._ws.options.token !== this.client.token) {
        await this._ws.destroy({ code: CloseCodes.Normal, reason: "Login with differing token requested" });
        this._ws = null;
      }
      if (!this._ws) {
        const wsOptions = {
          intents: intents.bitfield,
          rest: this.client.rest,
          token: this.client.token,
          largeThreshold: ws.large_threshold,
          version: ws.version,
          shardIds: shards === "auto" ? null : shards,
          shardCount: shards === "auto" ? null : shardCount,
          initialPresence: ws.presence,
          retrieveSessionInfo: (shardId) => this.shards.get(shardId).sessionInfo,
          updateSessionInfo: (shardId, sessionInfo) => {
            this.shards.get(shardId).sessionInfo = sessionInfo;
          },
          compression: zlib ? CompressionMethod.ZlibStream : null
        };
        if (ws.buildIdentifyThrottler)
          wsOptions.buildIdentifyThrottler = ws.buildIdentifyThrottler;
        if (ws.buildStrategy)
          wsOptions.buildStrategy = ws.buildStrategy;
        this._ws = new WSWebSocketManager(wsOptions);
        this.attachEvents();
      }
      const {
        url: gatewayURL,
        shards: recommendedShards,
        session_start_limit: sessionStartLimit
      } = await this._ws.fetchGatewayInformation().catch((error) => {
        throw error.status === 401 ? invalidToken : error;
      });
      const { total, remaining } = sessionStartLimit;
      this.debug(["Fetched Gateway Information", `URL: ${gatewayURL}`, `Recommended Shards: ${recommendedShards}`]);
      this.debug(["Session Limit Information", `Total: ${total}`, `Remaining: ${remaining}`]);
      this.gateway = `${gatewayURL}/`;
      this.client.options.shardCount = await this._ws.getShardCount();
      this.client.options.shards = await this._ws.getShardIds();
      this.totalShards = this.client.options.shards.length;
      for (const id of this.client.options.shards) {
        if (!this.shards.has(id)) {
          const shard = new WebSocketShard(this, id);
          this.shards.set(id, shard);
          shard.on(WebSocketShardEvents.AllReady, (unavailableGuilds) => {
            this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);
            this.checkShardsReady();
          });
          shard.status = Status.Connecting;
        }
      }
      await this._ws.connect();
      this.shards.forEach((shard) => {
        if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {
          process2.emitWarning("The WebSocketShard#invalidSession event is deprecated and will never emit.", "DeprecationWarning");
          deprecationEmittedForInvalidSessionEvent = true;
        }
        if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {
          process2.emitWarning("The WebSocketShard#destroyed event is deprecated and will never emit.", "DeprecationWarning");
          deprecationEmittedForDestroyedEvent = true;
        }
      });
    }
    attachEvents() {
      this._ws.on(WSWebSocketShardEvents.Debug, ({ message, shardId }) => this.debug([message], shardId));
      this._ws.on(WSWebSocketShardEvents.Dispatch, ({ data, shardId }) => {
        this.client.emit(Events.Raw, data, shardId);
        this.emit(data.t, data.d, shardId);
        const shard = this.shards.get(shardId);
        this.handlePacket(data, shard);
        if (shard.status === Status.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {
          shard.gotGuild(data.d.id);
        }
      });
      this._ws.on(WSWebSocketShardEvents.Ready, ({ data, shardId }) => {
        this.shards.get(shardId).onReadyPacket(data);
      });
      this._ws.on(WSWebSocketShardEvents.Closed, ({ code, shardId }) => {
        const shard = this.shards.get(shardId);
        shard.emit(WebSocketShardEvents.Close, { code, reason: reasonIsDeprecated, wasClean: true });
        if (UNRECOVERABLE_CLOSE_CODES.includes(code)) {
          shard.status = Status.Disconnected;
          this.client.emit(Events.ShardDisconnect, { code, reason: reasonIsDeprecated, wasClean: true }, shardId);
          this.debug([`Shard not recoverable: ${code} (${GatewayCloseCodes[code] ?? CloseCodes[code]})`], shardId);
          return;
        }
        this.shards.get(shardId).status = Status.Connecting;
        this.client.emit(Events.ShardReconnecting, shardId);
      });
      this._ws.on(WSWebSocketShardEvents.Hello, ({ shardId }) => {
        const shard = this.shards.get(shardId);
        if (shard.sessionInfo) {
          shard.closeSequence = shard.sessionInfo.sequence;
          shard.status = Status.Resuming;
        } else {
          shard.status = Status.Identifying;
        }
      });
      this._ws.on(WSWebSocketShardEvents.Resumed, ({ shardId }) => {
        const shard = this.shards.get(shardId);
        shard.status = Status.Ready;
        shard.emit(WebSocketShardEvents.Resumed);
      });
      this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, ({ heartbeatAt, latency, shardId }) => {
        this.debug([`Heartbeat acknowledged, latency of ${latency}ms.`], shardId);
        const shard = this.shards.get(shardId);
        shard.lastPingTimestamp = heartbeatAt;
        shard.ping = latency;
      });
      this._ws.on(WSWebSocketShardEvents.Error, ({ error, shardId }) => {
        this.client.emit(Events.ShardError, error, shardId);
      });
    }
    broadcast(packet) {
      for (const shardId of this.shards.keys())
        this._ws.send(shardId, packet);
    }
    async destroy() {
      if (this.destroyed)
        return;
      this.debug([Object.assign(new Error, { name: "Manager was destroyed:" }).stack]);
      this.destroyed = true;
      await this._ws?.destroy({ code: CloseCodes.Normal, reason: "Manager was destroyed" });
    }
    handlePacket(packet, shard) {
      if (packet && this.status !== Status.Ready) {
        if (!BeforeReadyWhitelist.includes(packet.t)) {
          this.packetQueue.push({ packet, shard });
          return false;
        }
      }
      if (this.packetQueue.length) {
        const item = this.packetQueue.shift();
        setImmediate(() => {
          this.handlePacket(item.packet, item.shard);
        }).unref();
      }
      if (packet && PacketHandlers[packet.t]) {
        PacketHandlers[packet.t](this.client, packet, shard);
      }
      return true;
    }
    checkShardsReady() {
      if (this.status === Status.Ready)
        return;
      if (this.shards.size !== this.totalShards || this.shards.some((shard) => shard.status !== Status.Ready)) {
        return;
      }
      this.triggerClientReady();
    }
    triggerClientReady() {
      this.status = Status.Ready;
      this.client.readyTimestamp = Date.now();
      this.client.emit(Events.ClientReady, this.client);
      this.handlePacket();
    }
  }
  module.exports = WebSocketManager;
});

// node_modules/discord.js/src/managers/BaseGuildEmojiManager.js
var require_BaseGuildEmojiManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var ApplicationEmoji = require_ApplicationEmoji();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var { parseEmoji } = require_Util();

  class BaseGuildEmojiManager extends CachedManager {
    constructor(client, iterable) {
      super(client, GuildEmoji, iterable);
    }
    resolve(emoji) {
      if (emoji instanceof ReactionEmoji)
        return this.cache.get(emoji.id) ?? null;
      if (emoji instanceof ApplicationEmoji)
        return this.cache.get(emoji.id) ?? null;
      return super.resolve(emoji);
    }
    resolveId(emoji) {
      if (emoji instanceof ReactionEmoji)
        return emoji.id;
      if (emoji instanceof ApplicationEmoji)
        return emoji.id;
      return super.resolveId(emoji);
    }
    resolveIdentifier(emoji) {
      const emojiResolvable = this.resolve(emoji);
      if (emojiResolvable)
        return emojiResolvable.identifier;
      if (emoji instanceof ReactionEmoji)
        return emoji.identifier;
      if (emoji instanceof ApplicationEmoji)
        return emoji.identifier;
      if (typeof emoji === "string") {
        const res = parseEmoji(emoji);
        if (res?.name.length) {
          emoji = `${res.animated ? "a:" : ""}${res.name}${res.id ? `:${res.id}` : ""}`;
        }
        if (!emoji.includes("%"))
          return encodeURIComponent(emoji);
        return emoji;
      }
      return null;
    }
  }
  module.exports = BaseGuildEmojiManager;
});

// node_modules/discord.js/src/managers/ChannelManager.js
var require_ChannelManager = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { BaseChannel } = require_BaseChannel();
  var { createChannel } = require_Channels();
  var { ThreadChannelTypes } = require_Constants();
  var Events = require_Events();
  var cacheWarningEmitted = false;

  class ChannelManager extends CachedManager {
    constructor(client, iterable) {
      super(client, BaseChannel, iterable);
      const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;
      if (!cacheWarningEmitted && !defaultCaching) {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
    }
    _add(data, guild, { cache = true, allowUnknownGuild = false } = {}) {
      const existing = this.cache.get(data.id);
      if (existing) {
        if (cache)
          existing._patch(data);
        guild?.channels?._add(existing);
        if (ThreadChannelTypes.includes(existing.type)) {
          existing.parent?.threads?._add(existing);
        }
        return existing;
      }
      const channel = createChannel(this.client, data, guild, { allowUnknownGuild });
      if (!channel) {
        this.client.emit(Events.Debug, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
        return null;
      }
      if (cache && !allowUnknownGuild)
        this.cache.set(channel.id, channel);
      return channel;
    }
    _remove(id) {
      const channel = this.cache.get(id);
      channel?.guild?.channels.cache.delete(id);
      for (const [code, invite] of channel?.guild?.invites.cache ?? []) {
        if (invite.channelId === id)
          channel.guild.invites.cache.delete(code);
      }
      channel?.parent?.threads?.cache.delete(id);
      this.cache.delete(id);
    }
    async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.channel(id));
      return this._add(data, null, { cache, allowUnknownGuild });
    }
  }
  module.exports = ChannelManager;
});

// node_modules/discord.js/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var { calculateShardId } = require_dist();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var Events = require_Events();
  var { makeError, makePlainError } = require_Util();

  class ShardClientUtil {
    constructor(client, mode) {
      this.client = client;
      this.mode = mode;
      this.parentPort = null;
      switch (mode) {
        case "process":
          process2.on("message", this._handleMessage.bind(this));
          client.on(Events.ShardReady, () => {
            process2.send({ _ready: true });
          });
          client.on(Events.ShardDisconnect, () => {
            process2.send({ _disconnect: true });
          });
          client.on(Events.ShardReconnecting, () => {
            process2.send({ _reconnecting: true });
          });
          client.on(Events.ShardResume, () => {
            process2.send({ _resume: true });
          });
          break;
        case "worker":
          this.parentPort = import.meta.require("worker_threads").parentPort;
          this.parentPort.on("message", this._handleMessage.bind(this));
          client.on(Events.ShardReady, () => {
            this.parentPort.postMessage({ _ready: true });
          });
          client.on(Events.ShardDisconnect, () => {
            this.parentPort.postMessage({ _disconnect: true });
          });
          client.on(Events.ShardReconnecting, () => {
            this.parentPort.postMessage({ _reconnecting: true });
          });
          client.on(Events.ShardResume, () => {
            this.parentPort.postMessage({ _resume: true });
          });
          break;
      }
    }
    get ids() {
      return this.client.options.shards;
    }
    get count() {
      return this.client.options.shardCount;
    }
    send(message) {
      return new Promise((resolve, reject) => {
        switch (this.mode) {
          case "process":
            process2.send(message, (err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
            break;
          case "worker":
            this.parentPort.postMessage(message);
            resolve();
            break;
        }
      });
    }
    fetchClientValues(prop, shard) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort ?? process2;
        const listener = (message) => {
          if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard)
            return;
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(parent);
        parent.on("message", listener);
        this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch((err) => {
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          reject(err);
        });
      });
    }
    broadcastEval(script2, options = {}) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort ?? process2;
        if (typeof script2 !== "function") {
          reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));
          return;
        }
        script2 = `(${script2})(this, ${JSON.stringify(options.context)})`;
        const listener = (message) => {
          if (message?._sEval !== script2 || message._sEvalShard !== options.shard)
            return;
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(parent);
        parent.on("message", listener);
        this.send({ _sEval: script2, _sEvalShard: options.shard }).catch((err) => {
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          reject(err);
        });
      });
    }
    respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {
      return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });
    }
    async _handleMessage(message) {
      if (!message)
        return;
      if (message._fetchProp) {
        try {
          const props = message._fetchProp.split(".");
          let value = this.client;
          for (const prop of props)
            value = value[prop];
          this._respond("fetchProp", { _fetchProp: message._fetchProp, _result: value });
        } catch (err) {
          this._respond("fetchProp", { _fetchProp: message._fetchProp, _error: makePlainError(err) });
        }
      } else if (message._eval) {
        try {
          this._respond("eval", { _eval: message._eval, _result: await this.client._eval(message._eval) });
        } catch (err) {
          this._respond("eval", { _eval: message._eval, _error: makePlainError(err) });
        }
      }
    }
    _respond(type, message) {
      this.send(message).catch((err) => {
        const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);
        error.stack = err.stack;
        this.client.emit(Events.Error, error);
      });
    }
    static singleton(client, mode) {
      if (!this._singleton) {
        this._singleton = new this(client, mode);
      } else {
        client.emit(Events.Warn, "Multiple clients created in child process/worker; only the first will handle sharding helpers.");
      }
      return this._singleton;
    }
    static shardIdForGuildId(guildId, shardCount) {
      const shard = calculateShardId(guildId, shardCount);
      if (shard < 0)
        throw new DiscordjsError(ErrorCodes.ShardingShardMiscalculation, shard, guildId, shardCount);
      return shard;
    }
    incrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners - 1);
      }
    }
  }
  module.exports = ShardClientUtil;
});

// node_modules/discord.js/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var ApplicationCommand = require_ApplicationCommand();
  var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  var Integration = require_Integration();
  var Webhook = require_Webhook();
  var { flatten } = require_Util();

  class GuildAuditLogs {
    constructor(guild, data) {
      if (data.users)
        for (const user of data.users)
          guild.client.users._add(user);
      if (data.threads)
        for (const thread of data.threads)
          guild.client.channels._add(thread, guild);
      this.webhooks = new Collection;
      if (data.webhooks) {
        for (const hook of data.webhooks) {
          this.webhooks.set(hook.id, new Webhook(guild.client, hook));
        }
      }
      this.integrations = new Collection;
      if (data.integrations) {
        for (const integration of data.integrations) {
          this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
        }
      }
      this.guildScheduledEvents = data.guild_scheduled_events.reduce((guildScheduledEvents, guildScheduledEvent) => guildScheduledEvents.set(guildScheduledEvent.id, guild.scheduledEvents._add(guildScheduledEvent)), new Collection);
      this.applicationCommands = new Collection;
      if (data.application_commands) {
        for (const command of data.application_commands) {
          this.applicationCommands.set(command.id, new ApplicationCommand(guild.client, command, guild));
        }
      }
      this.autoModerationRules = data.auto_moderation_rules.reduce((autoModerationRules, autoModerationRule) => autoModerationRules.set(autoModerationRule.id, guild.autoModerationRules._add(autoModerationRule)), new Collection);
      this.entries = new Collection;
      for (const item of data.audit_log_entries) {
        const entry = new GuildAuditLogsEntry(guild, item, this);
        this.entries.set(entry.id, entry);
      }
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = GuildAuditLogs;
});

// node_modules/discord.js/src/structures/GuildOnboarding.js
var require_GuildOnboarding = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { GuildOnboardingPrompt } = require_GuildOnboardingPrompt();

  class GuildOnboarding extends Base {
    constructor(client, data) {
      super(client);
      this.guildId = data.guild_id;
      const guild = this.guild;
      this.prompts = data.prompts.reduce((prompts, prompt) => prompts.set(prompt.id, new GuildOnboardingPrompt(client, prompt, this.guildId)), new Collection);
      this.defaultChannels = data.default_channel_ids.reduce((channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)), new Collection);
      this.enabled = data.enabled;
      this.mode = data.mode;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboarding = GuildOnboarding;
});

// node_modules/discord.js/src/structures/GuildPreviewEmoji.js
var require_GuildPreviewEmoji = __commonJS((exports, module) => {
  var BaseGuildEmoji = require_BaseGuildEmoji();

  class GuildPreviewEmoji extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.roles = data.roles;
    }
  }
  module.exports = GuildPreviewEmoji;
});

// node_modules/discord.js/src/structures/GuildPreview.js
var require_GuildPreview = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var { Routes } = require_v106();
  var Base = require_Base();
  var GuildPreviewEmoji = require_GuildPreviewEmoji();
  var { Sticker } = require_Sticker();

  class GuildPreview extends Base {
    constructor(client, data) {
      super(client);
      if (!data)
        return;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      }
      if ("splash" in data) {
        this.splash = data.splash;
      }
      if ("discovery_splash" in data) {
        this.discoverySplash = data.discovery_splash;
      }
      if ("features" in data) {
        this.features = data.features;
      }
      if ("approximate_member_count" in data) {
        this.approximateMemberCount = data.approximate_member_count;
      }
      if ("approximate_presence_count" in data) {
        this.approximatePresenceCount = data.approximate_presence_count;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if (!this.emojis) {
        this.emojis = new Collection;
      } else {
        this.emojis.clear();
      }
      for (const emoji of data.emojis) {
        this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
      }
      this.stickers = data.stickers.reduce((stickers, sticker) => stickers.set(sticker.id, new Sticker(this.client, sticker)), new Collection);
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    splashURL(options = {}) {
      return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
    }
    discoverySplashURL(options = {}) {
      return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guildPreview(this.id));
      this._patch(data);
      return this;
    }
    toString() {
      return this.name;
    }
    toJSON() {
      const json = super.toJSON();
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      return json;
    }
  }
  module.exports = GuildPreview;
});

// node_modules/discord.js/src/managers/AutoModerationRuleManager.js
var require_AutoModerationRuleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var AutoModerationRule = require_AutoModerationRule();

  class AutoModerationRuleManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, AutoModerationRule, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({
      name,
      eventType,
      triggerType,
      triggerMetadata,
      actions,
      enabled,
      exemptRoles,
      exemptChannels,
      reason
    }) {
      const data = await this.client.rest.post(Routes.guildAutoModerationRules(this.guild.id), {
        body: {
          name,
          event_type: eventType,
          trigger_type: triggerType,
          trigger_metadata: triggerMetadata && {
            keyword_filter: triggerMetadata.keywordFilter,
            regex_patterns: triggerMetadata.regexPatterns,
            presets: triggerMetadata.presets,
            allow_list: triggerMetadata.allowList,
            mention_total_limit: triggerMetadata.mentionTotalLimit,
            mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
          },
          actions: actions.map((action) => ({
            type: action.type,
            metadata: {
              duration_seconds: action.metadata?.durationSeconds,
              channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
              custom_message: action.metadata?.customMessage
            }
          })),
          enabled,
          exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
          exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
        },
        reason
      });
      return this._add(data);
    }
    async edit(autoModerationRule, { name, eventType, triggerMetadata, actions, enabled, exemptRoles, exemptChannels, reason }) {
      const autoModerationRuleId = this.resolveId(autoModerationRule);
      const data = await this.client.rest.patch(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), {
        body: {
          name,
          event_type: eventType,
          trigger_metadata: triggerMetadata && {
            keyword_filter: triggerMetadata.keywordFilter,
            regex_patterns: triggerMetadata.regexPatterns,
            presets: triggerMetadata.presets,
            allow_list: triggerMetadata.allowList,
            mention_total_limit: triggerMetadata.mentionTotalLimit,
            mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
          },
          actions: actions?.map((action) => ({
            type: action.type,
            metadata: {
              duration_seconds: action.metadata?.durationSeconds,
              channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
              custom_message: action.metadata?.customMessage
            }
          })),
          enabled,
          exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
          exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
        },
        reason
      });
      return this._add(data);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { autoModerationRule, cache, force } = options;
      const resolvedAutoModerationRule = this.resolveId(autoModerationRule ?? options);
      if (resolvedAutoModerationRule) {
        return this._fetchSingle({ autoModerationRule: resolvedAutoModerationRule, cache, force });
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ autoModerationRule, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(autoModerationRule);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildAutoModerationRule(this.guild.id, autoModerationRule));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.guildAutoModerationRules(this.guild.id));
      return data.reduce((col, autoModerationRule) => col.set(autoModerationRule.id, this._add(autoModerationRule, options.cache)), new Collection);
    }
    async delete(autoModerationRule, reason) {
      const autoModerationRuleId = this.resolveId(autoModerationRule);
      await this.client.rest.delete(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), { reason });
    }
  }
  module.exports = AutoModerationRuleManager;
});

// node_modules/discord.js/src/managers/GuildApplicationCommandManager.js
var require_GuildApplicationCommandManager = __commonJS((exports, module) => {
  var ApplicationCommandManager = require_ApplicationCommandManager();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();

  class GuildApplicationCommandManager extends ApplicationCommandManager {
    constructor(guild, iterable) {
      super(guild.client, iterable);
      this.guild = guild;
      this.permissions = new ApplicationCommandPermissionsManager(this);
    }
  }
  module.exports = GuildApplicationCommandManager;
});

// node_modules/discord.js/src/managers/GuildBanManager.js
var require_GuildBanManager = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors();
  var GuildBan = require_GuildBan();
  var { GuildMember } = require_GuildMember();
  var deprecationEmittedForDeleteMessageDays = false;

  class GuildBanManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildBan, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
    }
    resolve(ban) {
      return super.resolve(ban) ?? super.resolve(this.client.users.resolveId(ban));
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany();
      const { user, cache, force, limit, before, after } = options;
      const resolvedUser = this.client.users.resolveId(user ?? options);
      if (resolvedUser)
        return this._fetchSingle({ user: resolvedUser, cache, force });
      if (!before && !after && !limit && cache === undefined) {
        throw new DiscordjsError(ErrorCodes.FetchBanResolveId);
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ user, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildBan(this.guild.id, user));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.guildBans(this.guild.id), {
        query: makeURLSearchParams(options)
      });
      return data.reduce((col, ban) => col.set(ban.user.id, this._add(ban, options.cache)), new Collection);
    }
    async create(user, options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsError(ErrorCodes.BanResolveId, true);
      if (options.deleteMessageDays !== undefined && !deprecationEmittedForDeleteMessageDays) {
        process2.emitWarning("The deleteMessageDays option for GuildBanManager#create() is deprecated. Use the deleteMessageSeconds option instead.", "DeprecationWarning");
        deprecationEmittedForDeleteMessageDays = true;
      }
      await this.client.rest.put(Routes.guildBan(this.guild.id, id), {
        body: {
          delete_message_seconds: options.deleteMessageSeconds ?? (options.deleteMessageDays ? options.deleteMessageDays * 24 * 60 * 60 : undefined)
        },
        reason: options.reason
      });
      if (user instanceof GuildMember)
        return user;
      const _user = this.client.users.cache.get(id);
      if (_user) {
        return this.guild.members.resolve(_user) ?? _user;
      }
      return id;
    }
    async remove(user, reason) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsError(ErrorCodes.BanResolveId);
      await this.client.rest.delete(Routes.guildBan(this.guild.id, id), { reason });
      return this.client.users.resolve(user);
    }
    async bulkCreate(users, options = {}) {
      if (!users || !(Array.isArray(users) || users instanceof Collection)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "users", "Array or Collection of UserResolvable", true);
      }
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const userIds = users.map((user) => this.client.users.resolveId(user));
      if (userIds.length === 0)
        throw new DiscordjsError(ErrorCodes.BulkBanUsersOptionEmpty);
      const result = await this.client.rest.post(Routes.guildBulkBan(this.guild.id), {
        body: { delete_message_seconds: options.deleteMessageSeconds, user_ids: userIds },
        reason: options.reason
      });
      return { bannedUsers: result.banned_users, failedUsers: result.failed_users };
    }
  }
  module.exports = GuildBanManager;
});

// node_modules/discord.js/src/managers/GuildChannelManager.js
var require_GuildChannelManager = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var { Collection } = require_dist6();
  var { ChannelType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var GuildTextThreadManager = require_GuildTextThreadManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var GuildChannel = require_GuildChannel();
  var PermissionOverwrites = require_PermissionOverwrites();
  var ThreadChannel = require_ThreadChannel();
  var Webhook = require_Webhook();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();
  var { transformGuildForumTag, transformGuildDefaultReaction } = require_Channels();
  var { ThreadChannelTypes } = require_Constants();
  var { resolveImage } = require_DataResolver();
  var { setPosition } = require_Util();
  var cacheWarningEmitted = false;

  class GuildChannelManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildChannel, iterable);
      const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;
      if (!cacheWarningEmitted && !defaultCaching) {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.guild = guild;
    }
    get channelCountWithoutThreads() {
      return this.cache.reduce((acc, channel) => {
        if (ThreadChannelTypes.includes(channel.type))
          return acc;
        return ++acc;
      }, 0);
    }
    _add(channel) {
      const existing = this.cache.get(channel.id);
      if (existing)
        return existing;
      this.cache.set(channel.id, channel);
      return channel;
    }
    resolve(channel) {
      if (channel instanceof ThreadChannel)
        return this.cache.get(channel.id) ?? null;
      return super.resolve(channel);
    }
    resolveId(channel) {
      if (channel instanceof ThreadChannel)
        return super.resolveId(channel.id);
      return super.resolveId(channel);
    }
    async addFollower(channel, targetChannel, reason) {
      const channelId = this.resolveId(channel);
      if (!channelId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "NewsChannelResolvable");
      }
      const targetChannelId = this.resolveId(targetChannel);
      if (!targetChannelId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "targetChannel", "TextChannelResolvable");
      }
      const { webhook_id } = await this.client.rest.post(Routes.channelFollowers(channelId), {
        body: { webhook_channel_id: targetChannelId },
        reason
      });
      return webhook_id;
    }
    async create({
      name,
      type,
      topic,
      nsfw,
      bitrate,
      userLimit,
      parent,
      permissionOverwrites,
      position,
      rateLimitPerUser,
      rtcRegion,
      videoQualityMode,
      defaultThreadRateLimitPerUser,
      availableTags,
      defaultReactionEmoji,
      defaultAutoArchiveDuration,
      defaultSortOrder,
      defaultForumLayout,
      reason
    }) {
      parent &&= this.client.channels.resolveId(parent);
      permissionOverwrites &&= permissionOverwrites.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
      const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {
        body: {
          name,
          topic,
          type,
          nsfw,
          bitrate,
          user_limit: userLimit,
          parent_id: parent,
          position,
          permission_overwrites: permissionOverwrites,
          rate_limit_per_user: rateLimitPerUser,
          rtc_region: rtcRegion,
          video_quality_mode: videoQualityMode,
          default_thread_rate_limit_per_user: defaultThreadRateLimitPerUser,
          available_tags: availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
          default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),
          default_auto_archive_duration: defaultAutoArchiveDuration,
          default_sort_order: defaultSortOrder,
          default_forum_layout: defaultForumLayout
        },
        reason
      });
      return this.client.actions.ChannelCreate.handle(data).channel;
    }
    async createWebhook({ channel, name, avatar, reason }) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      if (typeof avatar === "string" && !avatar.startsWith("data:")) {
        avatar = await resolveImage(avatar);
      }
      const data = await this.client.rest.post(Routes.channelWebhooks(id), {
        body: {
          name,
          avatar
        },
        reason
      });
      return new Webhook(this.client, data);
    }
    async edit(channel, options) {
      const resolvedChannel = this.resolve(channel);
      if (!resolvedChannel)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const parentId = options.parent && this.client.channels.resolveId(options.parent);
      if (options.position !== undefined) {
        await this.setPosition(resolvedChannel, options.position, { position: options.position, reason: options.reason });
      }
      let permission_overwrites = options.permissionOverwrites?.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
      if (options.lockPermissions) {
        if (parentId) {
          const newParent = this.cache.get(parentId);
          if (newParent?.type === ChannelType.GuildCategory) {
            permission_overwrites = newParent.permissionOverwrites.cache.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
          }
        } else if (resolvedChannel.parent) {
          permission_overwrites = resolvedChannel.parent.permissionOverwrites.cache.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
        }
      }
      const newData = await this.client.rest.patch(Routes.channel(resolvedChannel.id), {
        body: {
          name: options.name,
          type: options.type,
          topic: options.topic,
          nsfw: options.nsfw,
          bitrate: options.bitrate,
          user_limit: options.userLimit,
          rtc_region: options.rtcRegion,
          video_quality_mode: options.videoQualityMode,
          parent_id: parentId,
          lock_permissions: options.lockPermissions,
          rate_limit_per_user: options.rateLimitPerUser,
          default_auto_archive_duration: options.defaultAutoArchiveDuration,
          permission_overwrites,
          available_tags: options.availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
          default_reaction_emoji: options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),
          default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,
          flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : undefined,
          default_sort_order: options.defaultSortOrder,
          default_forum_layout: options.defaultForumLayout
        },
        reason: options.reason
      });
      return this.client.actions.ChannelUpdate.handle(newData).updated;
    }
    async setPosition(channel, position, { relative, reason } = {}) {
      channel = this.resolve(channel);
      if (!channel)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const updatedChannels = await setPosition(channel, position, relative, this.guild._sortedChannels(channel), this.client, Routes.guildChannels(this.guild.id), reason);
      this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: updatedChannels
      });
      return channel;
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id && !force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      if (id) {
        const data2 = await this.client.rest.get(Routes.channel(id));
        if (this.guild.id !== data2.guild_id)
          throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);
        return this.client.channels._add(data2, this.guild, { cache });
      }
      const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));
      const channels = new Collection;
      for (const channel of data)
        channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));
      return channels;
    }
    async fetchWebhooks(channel) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const data = await this.client.rest.get(Routes.channelWebhooks(id));
      return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection);
    }
    async setPositions(channelPositions) {
      channelPositions = channelPositions.map((channelPosition) => ({
        id: this.client.channels.resolveId(channelPosition.channel),
        position: channelPosition.position,
        lock_permissions: channelPosition.lockPermissions,
        parent_id: channelPosition.parent !== undefined ? this.resolveId(channelPosition.parent) : undefined
      }));
      await this.client.rest.patch(Routes.guildChannels(this.guild.id), { body: channelPositions });
      return this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: channelPositions
      }).guild;
    }
    async fetchActiveThreads(cache = true) {
      const data = await this.rawFetchGuildActiveThreads();
      return GuildTextThreadManager._mapThreads(data, this.client, { guild: this.guild, cache });
    }
    rawFetchGuildActiveThreads() {
      return this.client.rest.get(Routes.guildActiveThreads(this.guild.id));
    }
    async delete(channel, reason) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      await this.client.rest.delete(Routes.channel(id), { reason });
      this.client.actions.ChannelDelete.handle({ id });
    }
  }
  module.exports = GuildChannelManager;
});

// node_modules/discord.js/src/managers/GuildEmojiManager.js
var require_GuildEmojiManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes, PermissionFlagsBits } = require_v106();
  var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var { resolveImage } = require_DataResolver();

  class GuildEmojiManager extends BaseGuildEmojiManager {
    constructor(guild, iterable) {
      super(guild.client, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({ attachment, name, roles, reason }) {
      attachment = await resolveImage(attachment);
      if (!attachment)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      const body = { image: attachment, name };
      if (roles) {
        if (!Array.isArray(roles) && !(roles instanceof Collection)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.roles", "Array or Collection of Roles or Snowflakes", true);
        }
        body.roles = [];
        for (const role of roles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "options.roles", role);
          }
          body.roles.push(resolvedRole);
        }
      }
      const emoji = await this.client.rest.post(Routes.guildEmojis(this.guild.id), { body, reason });
      return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const emoji = await this.client.rest.get(Routes.guildEmoji(this.guild.id, id));
        return this._add(emoji, cache);
      }
      const data = await this.client.rest.get(Routes.guildEmojis(this.guild.id));
      const emojis = new Collection;
      for (const emoji of data)
        emojis.set(emoji.id, this._add(emoji, cache));
      return emojis;
    }
    async delete(emoji, reason) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      await this.client.rest.delete(Routes.guildEmoji(this.guild.id, id), { reason });
    }
    async edit(emoji, options) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const roles = options.roles?.map((role) => this.guild.roles.resolveId(role));
      const newData = await this.client.rest.patch(Routes.guildEmoji(this.guild.id, id), {
        body: {
          name: options.name,
          roles
        },
        reason: options.reason
      });
      const existing = this.cache.get(id);
      if (existing) {
        const clone = existing._clone();
        clone._patch(newData);
        return clone;
      }
      return this._add(newData);
    }
    async fetchAuthor(emoji) {
      emoji = this.resolve(emoji);
      if (!emoji)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      if (emoji.managed) {
        throw new DiscordjsError(ErrorCodes.EmojiManaged);
      }
      const { me } = this.guild.members;
      if (!me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      if (!me.permissions.has(PermissionFlagsBits.ManageGuildExpressions)) {
        throw new DiscordjsError(ErrorCodes.MissingManageGuildExpressionsPermission, this.guild);
      }
      const data = await this.client.rest.get(Routes.guildEmoji(this.guild.id, emoji.id));
      emoji._patch(data);
      return emoji.author;
    }
  }
  module.exports = GuildEmojiManager;
});

// node_modules/discord.js/src/managers/GuildInviteManager.js
var require_GuildInviteManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var Invite = require_Invite();
  var { resolveInviteCode } = require_DataResolver();

  class GuildInviteManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Invite, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.code, extras: [this.guild] });
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany();
      if (typeof options === "string") {
        const code = resolveInviteCode(options);
        if (!code)
          throw new DiscordjsError(ErrorCodes.InviteResolveCode);
        return this._fetchSingle({ code, cache: true });
      }
      if (!options.code) {
        if (options.channelId) {
          const id = this.guild.channels.resolveId(options.channelId);
          if (!id)
            throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
          return this._fetchChannelMany(id, options.cache);
        }
        if ("cache" in options)
          return this._fetchMany(options.cache);
        throw new DiscordjsError(ErrorCodes.InviteResolveCode);
      }
      return this._fetchSingle({
        ...options,
        code: resolveInviteCode(options.code)
      });
    }
    async _fetchSingle({ code, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(code);
        if (existing)
          return existing;
      }
      const invites = await this._fetchMany(cache);
      const invite = invites.get(code);
      if (!invite)
        throw new DiscordjsError(ErrorCodes.InviteNotFound);
      return invite;
    }
    async _fetchMany(cache) {
      const data = await this.client.rest.get(Routes.guildInvites(this.guild.id));
      return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection);
    }
    async _fetchChannelMany(channelId, cache) {
      const data = await this.client.rest.get(Routes.channelInvites(channelId));
      return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection);
    }
    async create(channel, { temporary, maxAge, maxUses, unique, targetUser, targetApplication, targetType, reason } = {}) {
      const id = this.guild.channels.resolveId(channel);
      if (!id)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      const invite = await this.client.rest.post(Routes.channelInvites(id), {
        body: {
          temporary,
          max_age: maxAge,
          max_uses: maxUses,
          unique,
          target_user_id: this.client.users.resolveId(targetUser),
          target_application_id: targetApplication?.id ?? targetApplication?.applicationId ?? targetApplication,
          target_type: targetType
        },
        reason
      });
      return new Invite(this.client, invite);
    }
    async delete(invite, reason) {
      const code = resolveInviteCode(invite);
      await this.client.rest.delete(Routes.invite(code), { reason });
    }
  }
  module.exports = GuildInviteManager;
});

// node_modules/discord.js/src/managers/GuildMemberManager.js
var require_GuildMemberManager = __commonJS((exports, module) => {
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = import.meta.require("timers");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var { Routes, GatewayOpcodes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors();
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
  var { GuildMember } = require_GuildMember();
  var { Role } = require_Role();
  var Events = require_Events();
  var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
  var Partials = require_Partials();

  class GuildMemberManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildMember, iterable);
      this.guild = guild;
    }
    _add(data, cache = true) {
      return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userId = this.client.users.resolveId(member);
      if (userId)
        return this.cache.get(userId) ?? null;
      return null;
    }
    resolveId(member) {
      const memberResolvable = super.resolveId(member);
      if (memberResolvable)
        return memberResolvable;
      const userId = this.client.users.resolveId(member);
      return this.cache.has(userId) ? userId : null;
    }
    async add(user, options) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      if (!options.force) {
        const cachedUser = this.cache.get(userId);
        if (cachedUser)
          return cachedUser;
      }
      const resolvedOptions = {
        access_token: options.accessToken,
        nick: options.nick,
        mute: options.mute,
        deaf: options.deaf
      };
      if (options.roles) {
        if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.roles", "Array or Collection of Roles or Snowflakes", true);
        }
        const resolvedRoles = [];
        for (const role of options.roles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "options.roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        resolvedOptions.roles = resolvedRoles;
      }
      const data = await this.client.rest.put(Routes.guildMember(this.guild.id, userId), { body: resolvedOptions });
      return data instanceof ArrayBuffer ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);
    }
    get me() {
      return this.cache.get(this.client.user.id) ?? (this.client.options.partials.includes(Partials.GuildMember) ? this._add({ user: { id: this.client.user.id } }, true) : null);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { user: users, limit, withPresences, cache, force } = options;
      const resolvedUser = this.client.users.resolveId(users ?? options);
      if (resolvedUser && !limit && !withPresences)
        return this._fetchSingle({ user: resolvedUser, cache, force });
      const resolvedUsers = users?.map?.((user) => this.client.users.resolveId(user)) ?? resolvedUser ?? undefined;
      return this._fetchMany({ ...options, users: resolvedUsers });
    }
    async _fetchSingle({ user, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildMember(this.guild.id, user));
      return this._add(data, cache);
    }
    async _fetchMany({
      limit = 0,
      withPresences: presences,
      users,
      query,
      time = 120000,
      nonce = DiscordSnowflake.generate().toString()
    } = {}) {
      if (nonce.length > 32)
        throw new DiscordjsRangeError(ErrorCodes.MemberFetchNonceLength);
      return new Promise((resolve, reject) => {
        if (!query && !users)
          query = "";
        this.guild.shard.send({
          op: GatewayOpcodes.RequestGuildMembers,
          d: {
            guild_id: this.guild.id,
            presences,
            user_ids: users,
            query,
            nonce,
            limit
          }
        });
        const fetchedMembers = new Collection;
        let i = 0;
        const handler = (members, _, chunk) => {
          if (chunk.nonce !== nonce)
            return;
          timeout.refresh();
          i++;
          for (const member of members.values()) {
            fetchedMembers.set(member.id, member);
          }
          if (members.size < 1000 || limit && fetchedMembers.size >= limit || i === chunk.count) {
            clearTimeout2(timeout);
            this.client.removeListener(Events.GuildMembersChunk, handler);
            this.client.decrementMaxListeners();
            resolve(users && !Array.isArray(users) && fetchedMembers.size ? fetchedMembers.first() : fetchedMembers);
          }
        };
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.GuildMembersChunk, handler);
          this.client.decrementMaxListeners();
          reject(new DiscordjsError(ErrorCodes.GuildMembersTimeout));
        }, time).unref();
        this.client.incrementMaxListeners();
        this.client.on(Events.GuildMembersChunk, handler);
      });
    }
    fetchMe(options) {
      return this.fetch({ ...options, user: this.client.user.id });
    }
    async search({ query, limit, cache = true } = {}) {
      const data = await this.client.rest.get(Routes.guildMembersSearch(this.guild.id), {
        query: makeURLSearchParams({ query, limit })
      });
      return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection);
    }
    async list({ after, limit, cache = true } = {}) {
      const query = makeURLSearchParams({ limit, after });
      const data = await this.client.rest.get(Routes.guildMembers(this.guild.id), { query });
      return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection);
    }
    async edit(user, { reason, ...options }) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      if (options.channel) {
        options.channel = this.guild.channels.resolve(options.channel);
        if (!(options.channel instanceof BaseGuildVoiceChannel)) {
          throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);
        }
        options.channel_id = options.channel.id;
        options.channel = undefined;
      } else if (options.channel === null) {
        options.channel_id = null;
        options.channel = undefined;
      }
      options.roles &&= options.roles.map((role) => role instanceof Role ? role.id : role);
      if (options.communicationDisabledUntil !== undefined) {
        options.communication_disabled_until = options.communicationDisabledUntil != null ? new Date(options.communicationDisabledUntil).toISOString() : options.communicationDisabledUntil;
      }
      if (options.flags !== undefined) {
        options.flags = GuildMemberFlagsBitField.resolve(options.flags);
      }
      let endpoint;
      if (id === this.client.user.id) {
        const keys = Object.keys(options);
        if (keys.length === 1 && keys[0] === "nick")
          endpoint = Routes.guildMember(this.guild.id);
        else
          endpoint = Routes.guildMember(this.guild.id, id);
      } else {
        endpoint = Routes.guildMember(this.guild.id, id);
      }
      const d = await this.client.rest.patch(endpoint, { body: options, reason });
      const clone = this.cache.get(id)?._clone();
      clone?._patch(d);
      return clone ?? this._add(d, false);
    }
    async prune({ days, dry = false, count: compute_prune_count, roles = [], reason } = {}) {
      if (typeof days !== "number")
        throw new DiscordjsTypeError(ErrorCodes.PruneDaysType);
      const query = { days };
      const resolvedRoles = [];
      for (const role of roles) {
        const resolvedRole = this.guild.roles.resolveId(role);
        if (!resolvedRole) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "options.roles", role);
        }
        resolvedRoles.push(resolvedRole);
      }
      if (resolvedRoles.length) {
        query.include_roles = dry ? resolvedRoles.join(",") : resolvedRoles;
      }
      const endpoint = Routes.guildPrune(this.guild.id);
      const { pruned } = await (dry ? this.client.rest.get(endpoint, { query: makeURLSearchParams(query), reason }) : this.client.rest.post(endpoint, { body: { ...query, compute_prune_count }, reason }));
      return pruned;
    }
    async kick(user, reason) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      await this.client.rest.delete(Routes.guildMember(this.guild.id, id), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? id;
    }
    ban(user, options) {
      return this.guild.bans.create(user, options);
    }
    unban(user, reason) {
      return this.guild.bans.remove(user, reason);
    }
    bulkBan(users, options = {}) {
      return this.guild.bans.bulkCreate(users, options);
    }
    async addRole(options) {
      const { user, role, reason } = options;
      const userId = this.resolveId(user);
      const roleId = this.guild.roles.resolveId(role);
      await this.client.rest.put(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
    }
    async removeRole(options) {
      const { user, role, reason } = options;
      const userId = this.resolveId(user);
      const roleId = this.guild.roles.resolveId(role);
      await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
    }
  }
  module.exports = GuildMemberManager;
});

// node_modules/discord.js/src/managers/GuildScheduledEventManager.js
var require_GuildScheduledEventManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { GuildScheduledEventEntityType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var { resolveImage } = require_DataResolver();
  var { _transformGuildScheduledEventRecurrenceRule } = require_Transformers();

  class GuildScheduledEventManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildScheduledEvent, iterable);
      this.guild = guild;
    }
    async create(options) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let {
        privacyLevel,
        entityType,
        channel,
        name,
        scheduledStartTime,
        description,
        scheduledEndTime,
        entityMetadata,
        reason,
        image,
        recurrenceRule
      } = options;
      let entity_metadata, channel_id;
      if (entityType === GuildScheduledEventEntityType.External) {
        channel_id = channel === undefined ? channel : null;
        entity_metadata = { location: entityMetadata?.location };
      } else {
        channel_id = this.guild.channels.resolveId(channel);
        if (!channel_id)
          throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);
        entity_metadata = entityMetadata === undefined ? entityMetadata : null;
      }
      const data = await this.client.rest.post(Routes.guildScheduledEvents(this.guild.id), {
        body: {
          channel_id,
          name,
          privacy_level: privacyLevel,
          scheduled_start_time: new Date(scheduledStartTime).toISOString(),
          scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
          description,
          entity_type: entityType,
          entity_metadata,
          image: image && await resolveImage(image),
          recurrence_rule: recurrenceRule && _transformGuildScheduledEventRecurrenceRule(recurrenceRule)
        },
        reason
      });
      return this._add(data);
    }
    async fetch(options = {}) {
      const id = this.resolveId(options.guildScheduledEvent ?? options);
      if (id) {
        if (!options.force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data2 = await this.client.rest.get(Routes.guildScheduledEvent(this.guild.id, id), {
          query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true })
        });
        return this._add(data2, options.cache);
      }
      const data = await this.client.rest.get(Routes.guildScheduledEvents(this.guild.id), {
        query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true })
      });
      return data.reduce((coll, rawGuildScheduledEventData) => coll.set(rawGuildScheduledEventData.id, this._add(rawGuildScheduledEventData, options.cache)), new Collection);
    }
    async edit(guildScheduledEvent, options) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let {
        privacyLevel,
        entityType,
        channel,
        status,
        name,
        scheduledStartTime,
        description,
        scheduledEndTime,
        entityMetadata,
        reason,
        image,
        recurrenceRule
      } = options;
      let entity_metadata;
      if (entityMetadata) {
        entity_metadata = {
          location: entityMetadata.location
        };
      }
      const data = await this.client.rest.patch(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId), {
        body: {
          channel_id: channel === undefined ? channel : this.guild.channels.resolveId(channel),
          name,
          privacy_level: privacyLevel,
          scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : undefined,
          scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
          description,
          entity_type: entityType,
          status,
          image: image && await resolveImage(image),
          entity_metadata,
          recurrence_rule: recurrenceRule && _transformGuildScheduledEventRecurrenceRule(recurrenceRule)
        },
        reason
      });
      return this._add(data);
    }
    async delete(guildScheduledEvent) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      await this.client.rest.delete(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId));
    }
    async fetchSubscribers(guildScheduledEvent, options = {}) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      const query = makeURLSearchParams({
        limit: options.limit,
        with_member: options.withMember,
        before: options.before,
        after: options.after
      });
      const data = await this.client.rest.get(Routes.guildScheduledEventUsers(this.guild.id, guildScheduledEventId), {
        query
      });
      return data.reduce((coll, rawData) => coll.set(rawData.user.id, {
        guildScheduledEventId: rawData.guild_scheduled_event_id,
        user: this.client.users._add(rawData.user),
        member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null
      }), new Collection);
    }
  }
  module.exports = GuildScheduledEventManager;
});

// node_modules/discord.js/src/structures/SoundboardSound.js
var require_SoundboardSound = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var { Emoji } = require_Emoji();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class SoundboardSound extends Base {
    constructor(client, data) {
      super(client);
      this.soundId = data.sound_id;
      this._patch(data);
    }
    _patch(data) {
      if ("available" in data) {
        this.available = data.available;
      } else {
        this.available ??= null;
      }
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("volume" in data) {
        this.volume = data.volume;
      } else {
        this.volume ??= null;
      }
      if ("emoji_id" in data) {
        this._emoji = {
          id: data.emoji_id,
          name: data.emoji_name
        };
      } else {
        this._emoji ??= null;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("user" in data) {
        this.user = this.client.users._add(data.user);
      } else {
        this.user ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.soundId);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get emoji() {
      if (!this._emoji)
        return null;
      return this.guild?.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return this.client.rest.cdn.soundboardSound(this.soundId);
    }
    async edit(options) {
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSoundboardSound, "edited");
      return this.guild.soundboardSounds.edit(this, options);
    }
    async delete(reason) {
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSoundboardSound, "deleted");
      await this.guild.soundboardSounds.delete(this, reason);
      return this;
    }
    equals(other) {
      if (other instanceof SoundboardSound) {
        return this.soundId === other.soundId && this.available === other.available && this.name === other.name && this.volume === other.volume && this._emoji?.id === other._emoji?.id && this._emoji?.name === other._emoji?.name && this.guildId === other.guildId && this.user?.id === other.user?.id;
      }
      return this.soundId === other.sound_id && this.available === other.available && this.name === other.name && this.volume === other.volume && (this._emoji?.id ?? null) === other.emoji_id && (this._emoji?.name ?? null) === other.emoji_name && this.guildId === other.guild_id && this.user?.id === other.user?.id;
    }
  }
  exports.SoundboardSound = SoundboardSound;
});

// node_modules/discord.js/src/managers/GuildSoundboardSoundManager.js
var require_GuildSoundboardSoundManager = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { lazy } = require_dist();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { SoundboardSound } = require_SoundboardSound();
  var { resolveBase64, resolveFile } = require_DataResolver();
  var fileTypeMime = lazy(() => require_dist4().filetypemime);

  class GuildSoundboardSoundManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, SoundboardSound, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild], id: data.sound_id });
    }
    resolveId(soundboardSound) {
      if (soundboardSound instanceof this.holds)
        return soundboardSound.soundId;
      if (typeof soundboardSound === "string")
        return soundboardSound;
      return null;
    }
    async create({ contentType, emojiId, emojiName, file, name, reason, volume }) {
      const resolvedFile = await resolveFile(file);
      const resolvedContentType = contentType ?? resolvedFile.contentType ?? fileTypeMime()(resolvedFile.data)[0];
      const sound = resolveBase64(resolvedFile.data, resolvedContentType);
      const body = { emoji_id: emojiId, emoji_name: emojiName, name, sound, volume };
      const soundboardSound = await this.client.rest.post(Routes.guildSoundboardSounds(this.guild.id), {
        body,
        reason
      });
      return this._add(soundboardSound);
    }
    async edit(soundboardSound, options = {}) {
      const soundId = this.resolveId(soundboardSound);
      if (!soundId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "soundboardSound", "SoundboardSoundResolvable");
      const { emojiId, emojiName, name, reason, volume } = options;
      const body = { emoji_id: emojiId, emoji_name: emojiName, name, volume };
      const data = await this.client.rest.patch(Routes.guildSoundboardSound(this.guild.id, soundId), {
        body,
        reason
      });
      const existing = this.cache.get(soundId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(data);
        return clone;
      }
      return this._add(data);
    }
    async delete(soundboardSound, reason) {
      const soundId = this.resolveId(soundboardSound);
      if (!soundId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "soundboardSound", "SoundboardSoundResolvable");
      await this.client.rest.delete(Routes.guildSoundboardSound(this.guild.id, soundId), { reason });
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany();
      const { cache, force, soundboardSound } = options;
      const resolvedSoundboardSound = this.resolveId(soundboardSound ?? options);
      if (resolvedSoundboardSound)
        return this._fetchSingle({ cache, force, soundboardSound: resolvedSoundboardSound });
      return this._fetchMany({ cache });
    }
    async _fetchSingle({ cache, force, soundboardSound } = {}) {
      if (!force) {
        const existing = this.cache.get(soundboardSound);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildSoundboardSound(this.guild.id, soundboardSound));
      return this._add(data, cache);
    }
    async _fetchMany({ cache } = {}) {
      const data = await this.client.rest.get(Routes.guildSoundboardSounds(this.guild.id));
      return data.items.reduce((coll, sound) => coll.set(sound.sound_id, this._add(sound, cache)), new Collection);
    }
  }
  exports.GuildSoundboardSoundManager = GuildSoundboardSoundManager;
});

// node_modules/discord.js/src/managers/GuildStickerManager.js
var require_GuildStickerManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var MessagePayload = require_MessagePayload();
  var { Sticker } = require_Sticker();

  class GuildStickerManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Sticker, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({ file, name, tags, description, reason } = {}) {
      const resolvedFile = await MessagePayload.resolveFile(file);
      if (!resolvedFile)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      file = { ...resolvedFile, key: "file" };
      const body = { name, tags, description: description ?? "" };
      const sticker = await this.client.rest.post(Routes.guildStickers(this.guild.id), {
        appendToFormData: true,
        body,
        files: [file],
        reason
      });
      return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;
    }
    async edit(sticker, options = {}) {
      const stickerId = this.resolveId(sticker);
      if (!stickerId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      const d = await this.client.rest.patch(Routes.guildSticker(this.guild.id, stickerId), {
        body: options,
        reason: options.reason
      });
      const existing = this.cache.get(stickerId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      return this._add(d);
    }
    async delete(sticker, reason) {
      sticker = this.resolveId(sticker);
      if (!sticker)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      await this.client.rest.delete(Routes.guildSticker(this.guild.id, sticker), { reason });
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const sticker = await this.client.rest.get(Routes.guildSticker(this.guild.id, id));
        return this._add(sticker, cache);
      }
      const data = await this.client.rest.get(Routes.guildStickers(this.guild.id));
      return new Collection(data.map((sticker) => [sticker.id, this._add(sticker, cache)]));
    }
    async fetchUser(sticker) {
      sticker = this.resolve(sticker);
      if (!sticker)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      const data = await this.client.rest.get(Routes.guildSticker(this.guild.id, sticker.id));
      sticker._patch(data);
      return sticker.user;
    }
  }
  module.exports = GuildStickerManager;
});

// node_modules/discord.js/src/util/ActivityFlagsBitField.js
var require_ActivityFlagsBitField = __commonJS((exports, module) => {
  var { ActivityFlags } = require_v106();
  var BitField = require_BitField();

  class ActivityFlagsBitField extends BitField {
    static Flags = ActivityFlags;
  }
  module.exports = ActivityFlagsBitField;
});

// node_modules/discord.js/src/structures/Presence.js
var require_Presence = __commonJS((exports) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();
  var ActivityFlagsBitField = require_ActivityFlagsBitField();
  var { flatten } = require_Util();

  class Presence extends Base {
    constructor(client, data = {}) {
      super(client);
      this.userId = data.user.id;
      this.guild = data.guild ?? null;
      this._patch(data);
    }
    get user() {
      return this.client.users.resolve(this.userId);
    }
    get member() {
      return this.guild.members.resolve(this.userId);
    }
    _patch(data) {
      if ("status" in data) {
        this.status = data.status;
      } else {
        this.status ??= "offline";
      }
      if ("activities" in data) {
        this.activities = data.activities.map((activity) => new Activity(this, activity));
      } else {
        this.activities ??= [];
      }
      if ("client_status" in data) {
        this.clientStatus = data.client_status;
      } else {
        this.clientStatus ??= null;
      }
      return this;
    }
    _clone() {
      const clone = Object.assign(Object.create(this), this);
      clone.activities = this.activities.map((activity) => activity._clone());
      return clone;
    }
    equals(presence) {
      return this === presence || presence && this.status === presence.status && this.clientStatus?.web === presence.clientStatus?.web && this.clientStatus?.mobile === presence.clientStatus?.mobile && this.clientStatus?.desktop === presence.clientStatus?.desktop && this.activities.length === presence.activities.length && this.activities.every((activity, index) => activity.equals(presence.activities[index]));
    }
    toJSON() {
      return flatten(this);
    }
  }

  class Activity {
    constructor(presence, data) {
      Object.defineProperty(this, "presence", { value: presence });
      this.name = data.name;
      this.type = data.type;
      this.url = data.url ?? null;
      this.details = data.details ?? null;
      this.state = data.state ?? null;
      this.applicationId = data.application_id ?? null;
      this.timestamps = data.timestamps ? {
        start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
        end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null
      } : null;
      this.party = data.party ?? null;
      this.syncId = data.sync_id ?? null;
      this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;
      this.flags = new ActivityFlagsBitField(data.flags).freeze();
      this.emoji = data.emoji ? new Emoji(presence.client, data.emoji) : null;
      this.buttons = data.buttons ?? [];
      this.createdTimestamp = data.created_at;
    }
    equals(activity) {
      return this === activity || activity && this.name === activity.name && this.type === activity.type && this.url === activity.url && this.state === activity.state && this.details === activity.details && this.emoji?.id === activity.emoji?.id && this.emoji?.name === activity.emoji?.name;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toString() {
      return this.name;
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
  }

  class RichPresenceAssets {
    constructor(activity, assets) {
      Object.defineProperty(this, "activity", { value: activity });
      this.largeText = assets.large_text ?? null;
      this.smallText = assets.small_text ?? null;
      this.largeImage = assets.large_image ?? null;
      this.smallImage = assets.small_image ?? null;
    }
    smallImageURL(options = {}) {
      if (!this.smallImage)
        return null;
      if (this.smallImage.includes(":")) {
        const [platform, id] = this.smallImage.split(":");
        switch (platform) {
          case "mp":
            return `https://media.discordapp.net/${id}`;
          default:
            return null;
        }
      }
      return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.smallImage, options);
    }
    largeImageURL(options = {}) {
      if (!this.largeImage)
        return null;
      if (this.largeImage.includes(":")) {
        const [platform, id] = this.largeImage.split(":");
        switch (platform) {
          case "mp":
            return `https://media.discordapp.net/${id}`;
          case "spotify":
            return `https://i.scdn.co/image/${id}`;
          case "youtube":
            return `https://i.ytimg.com/vi/${id}/hqdefault_live.jpg`;
          case "twitch":
            return `https://static-cdn.jtvnw.net/previews-ttv/live_user_${id}.png`;
          default:
            return null;
        }
      }
      return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.largeImage, options);
    }
  }
  exports.Presence = Presence;
  exports.Activity = Activity;
  exports.RichPresenceAssets = RichPresenceAssets;
});

// node_modules/discord.js/src/managers/PresenceManager.js
var require_PresenceManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var { Presence } = require_Presence();

  class PresenceManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Presence, iterable);
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.user.id });
    }
    resolve(presence) {
      const presenceResolvable = super.resolve(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const userId = this.client.users.resolveId(presence);
      return super.cache.get(userId) ?? null;
    }
    resolveId(presence) {
      const presenceResolvable = super.resolveId(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const userId = this.client.users.resolveId(presence);
      return this.cache.has(userId) ? userId : null;
    }
  }
  module.exports = PresenceManager;
});

// node_modules/discord.js/src/managers/RoleManager.js
var require_RoleManager = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var { Collection } = require_dist6();
  var { DiscordAPIError } = require_dist5();
  var { RESTJSONErrorCodes, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { Role } = require_Role();
  var { resolveImage } = require_DataResolver();
  var PermissionsBitField = require_PermissionsBitField();
  var { setPosition, resolveColor } = require_Util();
  var cacheWarningEmitted = false;

  class RoleManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Role, iterable);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (!id) {
        const data = await this.client.rest.get(Routes.guildRoles(this.guild.id));
        const roles = new Collection;
        for (const role of data)
          roles.set(role.id, this._add(role, cache));
        return roles;
      }
      if (!force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      try {
        const data = await this.client.rest.get(Routes.guildRole(this.guild.id, id));
        return this._add(data, cache);
      } catch (error) {
        if (error instanceof DiscordAPIError && error.code === RESTJSONErrorCodes.UnknownRole) {
          return null;
        }
        throw error;
      }
    }
    async create(options = {}) {
      let { name, color, hoist, permissions, position, mentionable, reason, icon, unicodeEmoji } = options;
      color &&= resolveColor(color);
      if (permissions !== undefined)
        permissions = new PermissionsBitField(permissions);
      if (icon) {
        const guildEmojiURL = this.guild.emojis.resolve(icon)?.imageURL();
        icon = guildEmojiURL ? await resolveImage(guildEmojiURL) : await resolveImage(icon);
        if (typeof icon !== "string")
          icon = undefined;
      }
      const data = await this.client.rest.post(Routes.guildRoles(this.guild.id), {
        body: {
          name,
          color,
          hoist,
          permissions,
          mentionable,
          icon,
          unicode_emoji: unicodeEmoji
        },
        reason
      });
      const { role } = this.client.actions.GuildRoleCreate.handle({
        guild_id: this.guild.id,
        role: data
      });
      if (position)
        return this.setPosition(role, position, { reason });
      return role;
    }
    async edit(role, options) {
      role = this.resolve(role);
      if (!role)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "RoleResolvable");
      if (typeof options.position === "number") {
        await this.setPosition(role, options.position, { reason: options.reason });
      }
      let icon = options.icon;
      if (icon) {
        const guildEmojiURL = this.guild.emojis.resolve(icon)?.imageURL();
        icon = guildEmojiURL ? await resolveImage(guildEmojiURL) : await resolveImage(icon);
        if (typeof icon !== "string")
          icon = undefined;
      }
      const body = {
        name: options.name,
        color: options.color === undefined ? undefined : resolveColor(options.color),
        hoist: options.hoist,
        permissions: options.permissions === undefined ? undefined : new PermissionsBitField(options.permissions),
        mentionable: options.mentionable,
        icon,
        unicode_emoji: options.unicodeEmoji
      };
      const d = await this.client.rest.patch(Routes.guildRole(this.guild.id, role.id), { body, reason: options.reason });
      const clone = role._clone();
      clone._patch(d);
      return clone;
    }
    async delete(role, reason) {
      const id = this.resolveId(role);
      await this.client.rest.delete(Routes.guildRole(this.guild.id, id), { reason });
      this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });
    }
    async setPosition(role, position, { relative, reason } = {}) {
      role = this.resolve(role);
      if (!role)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "RoleResolvable");
      const updatedRoles = await setPosition(role, position, relative, this.guild._sortedRoles(), this.client, Routes.guildRoles(this.guild.id), reason);
      this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: updatedRoles
      });
      return role;
    }
    async setPositions(rolePositions) {
      rolePositions = rolePositions.map((rolePosition) => ({
        id: this.resolveId(rolePosition.role),
        position: rolePosition.position
      }));
      await this.client.rest.patch(Routes.guildRoles(this.guild.id), { body: rolePositions });
      return this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: rolePositions
      }).guild;
    }
    comparePositions(role1, role2) {
      const resolvedRole1 = this.resolve(role1);
      const resolvedRole2 = this.resolve(role2);
      if (!resolvedRole1 || !resolvedRole2) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "Role nor a Snowflake");
      }
      const role1Position = resolvedRole1.position;
      const role2Position = resolvedRole2.position;
      if (role1Position === role2Position) {
        return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));
      }
      return role1Position - role2Position;
    }
    botRoleFor(user) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        return null;
      return this.cache.find((role) => role.tags?.botId === userId) ?? null;
    }
    get everyone() {
      return this.cache.get(this.guild.id);
    }
    get premiumSubscriberRole() {
      return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
  }
  module.exports = RoleManager;
});

// node_modules/discord.js/src/managers/StageInstanceManager.js
var require_StageInstanceManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors();
  var { StageInstance } = require_StageInstance();

  class StageInstanceManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, StageInstance, iterable);
      this.guild = guild;
    }
    async create(channel, options) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const { guildScheduledEvent, topic, privacyLevel, sendStartNotification } = options;
      const guildScheduledEventId = guildScheduledEvent && this.resolveId(guildScheduledEvent);
      const data = await this.client.rest.post(Routes.stageInstances(), {
        body: {
          channel_id: channelId,
          topic,
          privacy_level: privacyLevel,
          send_start_notification: sendStartNotification,
          guild_scheduled_event_id: guildScheduledEventId
        }
      });
      return this._add(data);
    }
    async fetch(channel, { cache = true, force = false } = {}) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      if (!force) {
        const existing = this.cache.find((stageInstance) => stageInstance.channelId === channelId);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.stageInstance(channelId));
      return this._add(data, cache);
    }
    async edit(channel, options) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      let { topic, privacyLevel } = options;
      const data = await this.client.rest.patch(Routes.stageInstance(channelId), {
        body: {
          topic,
          privacy_level: privacyLevel
        }
      });
      if (this.cache.has(data.id)) {
        const clone = this.cache.get(data.id)._clone();
        clone._patch(data);
        return clone;
      }
      return this._add(data);
    }
    async delete(channel) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      await this.client.rest.delete(Routes.stageInstance(channelId));
    }
  }
  module.exports = StageInstanceManager;
});

// node_modules/discord.js/src/managers/VoiceStateManager.js
var require_VoiceStateManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var VoiceState = require_VoiceState();

  class VoiceStateManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, VoiceState, iterable);
      this.guild = guild;
    }
    _add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (existing)
        return existing._patch(data);
      const entry = new this.holds(this.guild, data);
      if (cache)
        this.cache.set(data.user_id, entry);
      return entry;
    }
    async fetch(member, { cache = true, force = false } = {}) {
      const id = member === "@me" ? member : this.guild.members.resolveId(member);
      if (!force) {
        const existing = this.cache.get(id === "@me" ? this.client.user.id : id);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildVoiceState(this.guild.id, id));
      return this._add(data, cache);
    }
  }
  module.exports = VoiceStateManager;
});

// node_modules/discord.js/src/util/SystemChannelFlagsBitField.js
var require_SystemChannelFlagsBitField = __commonJS((exports, module) => {
  var { GuildSystemChannelFlags } = require_v106();
  var BitField = require_BitField();

  class SystemChannelFlagsBitField extends BitField {
    static Flags = GuildSystemChannelFlags;
  }
  module.exports = SystemChannelFlagsBitField;
});

// node_modules/discord.js/src/structures/Guild.js
var require_Guild = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var { ChannelType, GuildPremiumTier, Routes, GuildFeature } = require_v106();
  var AnonymousGuild = require_AnonymousGuild();
  var GuildAuditLogs = require_GuildAuditLogs();
  var { GuildOnboarding } = require_GuildOnboarding();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Integration = require_Integration();
  var Webhook = require_Webhook();
  var WelcomeScreen = require_WelcomeScreen();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var AutoModerationRuleManager = require_AutoModerationRuleManager();
  var GuildApplicationCommandManager = require_GuildApplicationCommandManager();
  var GuildBanManager = require_GuildBanManager();
  var GuildChannelManager = require_GuildChannelManager();
  var GuildEmojiManager = require_GuildEmojiManager();
  var GuildInviteManager = require_GuildInviteManager();
  var GuildMemberManager = require_GuildMemberManager();
  var GuildScheduledEventManager = require_GuildScheduledEventManager();
  var { GuildSoundboardSoundManager } = require_GuildSoundboardSoundManager();
  var GuildStickerManager = require_GuildStickerManager();
  var PresenceManager = require_PresenceManager();
  var RoleManager = require_RoleManager();
  var StageInstanceManager = require_StageInstanceManager();
  var VoiceStateManager = require_VoiceStateManager();
  var { resolveImage } = require_DataResolver();
  var Status = require_Status();
  var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  var { _transformAPIIncidentsData } = require_Transformers();
  var { discordSort, getSortableGroupTypes, resolvePartialEmoji } = require_Util();

  class Guild extends AnonymousGuild {
    constructor(client, data) {
      super(client, data, false);
      this.commands = new GuildApplicationCommandManager(this);
      this.members = new GuildMemberManager(this);
      this.channels = new GuildChannelManager(this);
      this.bans = new GuildBanManager(this);
      this.roles = new RoleManager(this);
      this.presences = new PresenceManager(this.client);
      this.voiceStates = new VoiceStateManager(this);
      this.stageInstances = new StageInstanceManager(this);
      this.invites = new GuildInviteManager(this);
      this.scheduledEvents = new GuildScheduledEventManager(this);
      this.autoModerationRules = new AutoModerationRuleManager(this);
      this.soundboardSounds = new GuildSoundboardSoundManager(this);
      if (!data)
        return;
      if (data.unavailable) {
        this.available = false;
      } else {
        this._patch(data);
        if (!data.channels)
          this.available = false;
      }
      this.shardId = data.shardId;
    }
    get shard() {
      return this.client.ws.shards.get(this.shardId);
    }
    _patch(data) {
      super._patch(data);
      this.id = data.id;
      if ("name" in data)
        this.name = data.name;
      if ("icon" in data)
        this.icon = data.icon;
      if ("unavailable" in data) {
        this.available = !data.unavailable;
      } else {
        this.available ??= true;
      }
      if ("discovery_splash" in data) {
        this.discoverySplash = data.discovery_splash;
      }
      if ("member_count" in data) {
        this.memberCount = data.member_count;
      }
      if ("large" in data) {
        this.large = Boolean(data.large);
      }
      if ("premium_progress_bar_enabled" in data) {
        this.premiumProgressBarEnabled = data.premium_progress_bar_enabled;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      }
      if ("afk_timeout" in data) {
        this.afkTimeout = data.afk_timeout;
      }
      if ("afk_channel_id" in data) {
        this.afkChannelId = data.afk_channel_id;
      }
      if ("system_channel_id" in data) {
        this.systemChannelId = data.system_channel_id;
      }
      if ("premium_tier" in data) {
        this.premiumTier = data.premium_tier;
      }
      if ("widget_enabled" in data) {
        this.widgetEnabled = data.widget_enabled;
      } else {
        this.widgetEnabled ??= null;
      }
      if ("widget_channel_id" in data) {
        this.widgetChannelId = data.widget_channel_id;
      } else {
        this.widgetChannelId ??= null;
      }
      if ("explicit_content_filter" in data) {
        this.explicitContentFilter = data.explicit_content_filter;
      }
      if ("mfa_level" in data) {
        this.mfaLevel = data.mfa_level;
      }
      if ("joined_at" in data) {
        this.joinedTimestamp = Date.parse(data.joined_at);
      }
      if ("default_message_notifications" in data) {
        this.defaultMessageNotifications = data.default_message_notifications;
      }
      if ("system_channel_flags" in data) {
        this.systemChannelFlags = new SystemChannelFlagsBitField(data.system_channel_flags).freeze();
      }
      if ("max_members" in data) {
        this.maximumMembers = data.max_members;
      } else {
        this.maximumMembers ??= null;
      }
      if ("max_presences" in data) {
        this.maximumPresences = data.max_presences;
      } else {
        this.maximumPresences ??= null;
      }
      if ("max_video_channel_users" in data) {
        this.maxVideoChannelUsers = data.max_video_channel_users;
      } else {
        this.maxVideoChannelUsers ??= null;
      }
      if ("max_stage_video_channel_users" in data) {
        this.maxStageVideoChannelUsers = data.max_stage_video_channel_users;
      } else {
        this.maxStageVideoChannelUsers ??= null;
      }
      if ("approximate_member_count" in data) {
        this.approximateMemberCount = data.approximate_member_count;
      } else {
        this.approximateMemberCount ??= null;
      }
      if ("approximate_presence_count" in data) {
        this.approximatePresenceCount = data.approximate_presence_count;
      } else {
        this.approximatePresenceCount ??= null;
      }
      this.vanityURLUses ??= null;
      if ("rules_channel_id" in data) {
        this.rulesChannelId = data.rules_channel_id;
      }
      if ("public_updates_channel_id" in data) {
        this.publicUpdatesChannelId = data.public_updates_channel_id;
      }
      if ("preferred_locale" in data) {
        this.preferredLocale = data.preferred_locale;
      }
      if ("safety_alerts_channel_id" in data) {
        this.safetyAlertsChannelId = data.safety_alerts_channel_id;
      } else {
        this.safetyAlertsChannelId ??= null;
      }
      if (data.channels) {
        this.channels.cache.clear();
        for (const rawChannel of data.channels) {
          this.client.channels._add(rawChannel, this);
        }
      }
      if (data.threads) {
        for (const rawThread of data.threads) {
          this.client.channels._add(rawThread, this);
        }
      }
      if (data.roles) {
        this.roles.cache.clear();
        for (const role of data.roles)
          this.roles._add(role);
      }
      if (data.members) {
        this.members.cache.clear();
        for (const guildUser of data.members)
          this.members._add(guildUser);
      }
      if ("owner_id" in data) {
        this.ownerId = data.owner_id;
      }
      if (data.presences) {
        for (const presence of data.presences) {
          this.presences._add(Object.assign(presence, { guild: this }));
        }
      }
      if (data.stage_instances) {
        this.stageInstances.cache.clear();
        for (const stageInstance of data.stage_instances) {
          this.stageInstances._add(stageInstance);
        }
      }
      if (data.guild_scheduled_events) {
        this.scheduledEvents.cache.clear();
        for (const scheduledEvent of data.guild_scheduled_events) {
          this.scheduledEvents._add(scheduledEvent);
        }
      }
      if (data.voice_states) {
        this.voiceStates.cache.clear();
        for (const voiceState of data.voice_states) {
          this.voiceStates._add(voiceState);
        }
      }
      if (!this.emojis) {
        this.emojis = new GuildEmojiManager(this);
        if (data.emojis)
          for (const emoji of data.emojis)
            this.emojis._add(emoji);
      } else if (data.emojis) {
        this.client.actions.GuildEmojisUpdate.handle({
          guild_id: this.id,
          emojis: data.emojis
        });
      }
      if (!this.stickers) {
        this.stickers = new GuildStickerManager(this);
        if (data.stickers)
          for (const sticker of data.stickers)
            this.stickers._add(sticker);
      } else if (data.stickers) {
        this.client.actions.GuildStickersUpdate.handle({
          guild_id: this.id,
          stickers: data.stickers
        });
      }
      if ("incidents_data" in data) {
        this.incidentsData = data.incidents_data && _transformAPIIncidentsData(data.incidents_data);
      } else {
        this.incidentsData ??= null;
      }
      if (data.soundboard_sounds) {
        this.soundboardSounds.cache.clear();
        for (const soundboardSound of data.soundboard_sounds) {
          this.soundboardSounds._add(soundboardSound);
        }
      }
    }
    get joinedAt() {
      return new Date(this.joinedTimestamp);
    }
    discoverySplashURL(options = {}) {
      return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
    }
    async fetchOwner(options) {
      if (!this.ownerId) {
        throw new DiscordjsError(ErrorCodes.FetchOwnerId, "guild");
      }
      const member = await this.members.fetch({ ...options, user: this.ownerId });
      return member;
    }
    get afkChannel() {
      return this.client.channels.resolve(this.afkChannelId);
    }
    get systemChannel() {
      return this.client.channels.resolve(this.systemChannelId);
    }
    get widgetChannel() {
      return this.client.channels.resolve(this.widgetChannelId);
    }
    get rulesChannel() {
      return this.client.channels.resolve(this.rulesChannelId);
    }
    get publicUpdatesChannel() {
      return this.client.channels.resolve(this.publicUpdatesChannelId);
    }
    get safetyAlertsChannel() {
      return this.client.channels.resolve(this.safetyAlertsChannelId);
    }
    get maximumBitrate() {
      if (this.features.includes(GuildFeature.VIPRegions)) {
        return 384000;
      }
      switch (this.premiumTier) {
        case GuildPremiumTier.Tier1:
          return 128000;
        case GuildPremiumTier.Tier2:
          return 256000;
        case GuildPremiumTier.Tier3:
          return 384000;
        default:
          return 96000;
      }
    }
    async fetchIntegrations() {
      const data = await this.client.rest.get(Routes.guildIntegrations(this.id));
      return data.reduce((collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)), new Collection);
    }
    async fetchTemplates() {
      const templates = await this.client.rest.get(Routes.guildTemplates(this.id));
      return templates.reduce((col, data) => col.set(data.code, new GuildTemplate(this.client, data)), new Collection);
    }
    async fetchWelcomeScreen() {
      const data = await this.client.rest.get(Routes.guildWelcomeScreen(this.id));
      return new WelcomeScreen(this, data);
    }
    async createTemplate(name, description) {
      const data = await this.client.rest.post(Routes.guildTemplates(this.id), { body: { name, description } });
      return new GuildTemplate(this.client, data);
    }
    async fetchPreview() {
      const data = await this.client.rest.get(Routes.guildPreview(this.id));
      return new GuildPreview(this.client, data);
    }
    async fetchVanityData() {
      const data = await this.client.rest.get(Routes.guildVanityUrl(this.id));
      this.vanityURLCode = data.code;
      this.vanityURLUses = data.uses;
      return data;
    }
    async fetchWebhooks() {
      const apiHooks = await this.client.rest.get(Routes.guildWebhooks(this.id));
      const hooks = new Collection;
      for (const hook of apiHooks)
        hooks.set(hook.id, new Webhook(this.client, hook));
      return hooks;
    }
    fetchWidget() {
      return this.client.fetchGuildWidget(this.id);
    }
    async fetchWidgetSettings() {
      const data = await this.client.rest.get(Routes.guildWidgetSettings(this.id));
      this.widgetEnabled = data.enabled;
      this.widgetChannelId = data.channel_id;
      return {
        enabled: data.enabled,
        channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null
      };
    }
    widgetImageURL(style) {
      return this.client.guilds.widgetImageURL(this.id, style);
    }
    async fetchAuditLogs({ before, after, limit, user, type } = {}) {
      const query = makeURLSearchParams({
        before: before?.id ?? before,
        after: after?.id ?? after,
        limit,
        action_type: type
      });
      if (user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
        query.set("user_id", userId);
      }
      const data = await this.client.rest.get(Routes.guildAuditLog(this.id), { query });
      return new GuildAuditLogs(this, data);
    }
    async fetchOnboarding() {
      const data = await this.client.rest.get(Routes.guildOnboarding(this.id));
      return new GuildOnboarding(this.client, data);
    }
    async edit({
      verificationLevel,
      defaultMessageNotifications,
      explicitContentFilter,
      afkChannel,
      afkTimeout,
      icon,
      owner,
      splash,
      discoverySplash,
      banner,
      systemChannel,
      systemChannelFlags,
      rulesChannel,
      publicUpdatesChannel,
      preferredLocale,
      premiumProgressBarEnabled,
      safetyAlertsChannel,
      ...options
    }) {
      const data = await this.client.rest.patch(Routes.guild(this.id), {
        body: {
          ...options,
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          afk_channel_id: afkChannel && this.client.channels.resolveId(afkChannel),
          afk_timeout: afkTimeout,
          icon: icon && await resolveImage(icon),
          owner_id: owner && this.client.users.resolveId(owner),
          splash: splash && await resolveImage(splash),
          discovery_splash: discoverySplash && await resolveImage(discoverySplash),
          banner: banner && await resolveImage(banner),
          system_channel_id: systemChannel && this.client.channels.resolveId(systemChannel),
          system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags),
          rules_channel_id: rulesChannel && this.client.channels.resolveId(rulesChannel),
          public_updates_channel_id: publicUpdatesChannel && this.client.channels.resolveId(publicUpdatesChannel),
          preferred_locale: preferredLocale,
          premium_progress_bar_enabled: premiumProgressBarEnabled,
          safety_alerts_channel_id: safetyAlertsChannel && this.client.channels.resolveId(safetyAlertsChannel)
        },
        reason: options.reason
      });
      return this.client.actions.GuildUpdate.handle(data).updated;
    }
    async editOnboarding(options) {
      const newData = await this.client.rest.put(Routes.guildOnboarding(this.id), {
        body: {
          prompts: options.prompts?.map((prompt) => ({
            id: prompt.id ?? DiscordSnowflake.generate().toString(),
            title: prompt.title,
            single_select: prompt.singleSelect,
            required: prompt.required,
            in_onboarding: prompt.inOnboarding,
            type: prompt.type,
            options: prompt.options.map((option) => {
              const emoji = resolvePartialEmoji(option.emoji);
              return {
                id: option.id,
                channel_ids: option.channels?.map((channel) => this.channels.resolveId(channel)),
                role_ids: option.roles?.map((role) => this.roles.resolveId(role)),
                title: option.title,
                description: option.description,
                emoji_animated: emoji?.animated,
                emoji_id: emoji?.id,
                emoji_name: emoji?.name
              };
            })
          })),
          default_channel_ids: options.defaultChannels?.map((channel) => this.channels.resolveId(channel)),
          enabled: options.enabled,
          mode: options.mode
        },
        reason: options.reason
      });
      return new GuildOnboarding(this.client, newData);
    }
    async editWelcomeScreen(options) {
      const { enabled, description, welcomeChannels } = options;
      const welcome_channels = welcomeChannels?.map((welcomeChannelData) => {
        const emoji = this.emojis.resolve(welcomeChannelData.emoji);
        return {
          emoji_id: emoji?.id,
          emoji_name: emoji?.name ?? welcomeChannelData.emoji,
          channel_id: this.channels.resolveId(welcomeChannelData.channel),
          description: welcomeChannelData.description
        };
      });
      const patchData = await this.client.rest.patch(Routes.guildWelcomeScreen(this.id), {
        body: {
          welcome_channels,
          description,
          enabled
        }
      });
      return new WelcomeScreen(this, patchData);
    }
    setExplicitContentFilter(explicitContentFilter, reason) {
      return this.edit({ explicitContentFilter, reason });
    }
    setDefaultMessageNotifications(defaultMessageNotifications, reason) {
      return this.edit({ defaultMessageNotifications, reason });
    }
    setSystemChannelFlags(systemChannelFlags, reason) {
      return this.edit({ systemChannelFlags, reason });
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setVerificationLevel(verificationLevel, reason) {
      return this.edit({ verificationLevel, reason });
    }
    setAFKChannel(afkChannel, reason) {
      return this.edit({ afkChannel, reason });
    }
    setSystemChannel(systemChannel, reason) {
      return this.edit({ systemChannel, reason });
    }
    setAFKTimeout(afkTimeout, reason) {
      return this.edit({ afkTimeout, reason });
    }
    setIcon(icon, reason) {
      return this.edit({ icon, reason });
    }
    setOwner(owner, reason) {
      return this.edit({ owner, reason });
    }
    setSplash(splash, reason) {
      return this.edit({ splash, reason });
    }
    setDiscoverySplash(discoverySplash, reason) {
      return this.edit({ discoverySplash, reason });
    }
    setBanner(banner, reason) {
      return this.edit({ banner, reason });
    }
    setRulesChannel(rulesChannel, reason) {
      return this.edit({ rulesChannel, reason });
    }
    setPublicUpdatesChannel(publicUpdatesChannel, reason) {
      return this.edit({ publicUpdatesChannel, reason });
    }
    setPreferredLocale(preferredLocale, reason) {
      return this.edit({ preferredLocale, reason });
    }
    setPremiumProgressBarEnabled(enabled = true, reason) {
      return this.edit({ premiumProgressBarEnabled: enabled, reason });
    }
    setSafetyAlertsChannel(safetyAlertsChannel, reason) {
      return this.edit({ safetyAlertsChannel, reason });
    }
    async setWidgetSettings(settings, reason) {
      await this.client.rest.patch(Routes.guildWidgetSettings(this.id), {
        body: {
          enabled: settings.enabled,
          channel_id: this.channels.resolveId(settings.channel)
        },
        reason
      });
      return this;
    }
    async setMFALevel(level, reason) {
      await this.client.rest.post(Routes.guildMFA(this.id), {
        body: {
          level
        },
        reason
      });
      return this;
    }
    async leave() {
      if (this.ownerId === this.client.user.id)
        throw new DiscordjsError(ErrorCodes.GuildOwned);
      await this.client.rest.delete(Routes.userGuild(this.id));
      return this;
    }
    async delete() {
      await this.client.rest.delete(Routes.guild(this.id));
      return this;
    }
    async disableInvites(disabled = true) {
      const features = this.features.filter((feature) => feature !== GuildFeature.InvitesDisabled);
      if (disabled)
        features.push(GuildFeature.InvitesDisabled);
      return this.edit({ features });
    }
    async setIncidentActions(incidentActions) {
      return this.client.guilds.setIncidentActions(this.id, incidentActions);
    }
    equals(guild) {
      return guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerId === guild.ownerId && this.verificationLevel === guild.verificationLevel && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));
    }
    toJSON() {
      const json = super.toJSON({
        available: false,
        createdTimestamp: true,
        nameAcronym: true,
        presences: false,
        voiceStates: false
      });
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      json.discoverySplashURL = this.discoverySplashURL();
      json.bannerURL = this.bannerURL();
      return json;
    }
    get voiceAdapterCreator() {
      return (methods) => {
        this.client.voice.adapters.set(this.id, methods);
        return {
          sendPayload: (data) => {
            if (this.shard.status !== Status.Ready)
              return false;
            this.shard.send(data);
            return true;
          },
          destroy: () => {
            this.client.voice.adapters.delete(this.id);
          }
        };
      };
    }
    _sortedRoles() {
      return discordSort(this.roles.cache);
    }
    _sortedChannels(channel) {
      const channelIsCategory = channel.type === ChannelType.GuildCategory;
      const types = getSortableGroupTypes(channel.type);
      return discordSort(this.channels.cache.filter(({ parentId, type }) => types.includes(type) && (channelIsCategory || parentId === channel.parentId)));
    }
  }
  exports.Guild = Guild;
});

// node_modules/discord.js/src/structures/OAuth2Guild.js
var require_OAuth2Guild = __commonJS((exports, module) => {
  var BaseGuild = require_BaseGuild();
  var PermissionsBitField = require_PermissionsBitField();

  class OAuth2Guild extends BaseGuild {
    constructor(client, data) {
      super(client, data);
      this.owner = data.owner;
      this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();
    }
  }
  module.exports = OAuth2Guild;
});

// node_modules/discord.js/src/managers/GuildManager.js
var require_GuildManager = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = import.meta.require("timers");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { GatewayOpcodes, Routes, RouteBases } = require_v106();
  var CachedManager = require_CachedManager();
  var { ErrorCodes, DiscordjsError } = require_errors();
  var ShardClientUtil = require_ShardClientUtil();
  var { Guild } = require_Guild();
  var GuildChannel = require_GuildChannel();
  var GuildEmoji = require_GuildEmoji();
  var { GuildMember } = require_GuildMember();
  var Invite = require_Invite();
  var OAuth2Guild = require_OAuth2Guild();
  var { Role } = require_Role();
  var { resolveImage } = require_DataResolver();
  var Events = require_Events();
  var PermissionsBitField = require_PermissionsBitField();
  var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  var { _transformAPIIncidentsData } = require_Transformers();
  var { resolveColor } = require_Util();
  var cacheWarningEmitted = false;

  class GuildManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Guild, iterable);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
    }
    resolve(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {
        return super.resolve(guild.guild);
      }
      return super.resolve(guild);
    }
    resolveId(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {
        return super.resolveId(guild.guild.id);
      }
      return super.resolveId(guild);
    }
    async create({
      name,
      icon = null,
      verificationLevel,
      defaultMessageNotifications,
      explicitContentFilter,
      roles = [],
      channels = [],
      afkChannelId,
      afkTimeout,
      systemChannelId,
      systemChannelFlags
    }) {
      const data = await this.client.rest.post(Routes.guilds(), {
        body: {
          name,
          icon: icon && await resolveImage(icon),
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          roles: roles.map(({ color, permissions, ...options }) => ({
            ...options,
            color: color && resolveColor(color),
            permissions: permissions === undefined ? undefined : PermissionsBitField.resolve(permissions).toString()
          })),
          channels: channels.map(({
            parentId,
            userLimit,
            rtcRegion,
            videoQualityMode,
            permissionOverwrites,
            rateLimitPerUser,
            ...options
          }) => ({
            ...options,
            parent_id: parentId,
            user_limit: userLimit,
            rtc_region: rtcRegion,
            video_quality_mode: videoQualityMode,
            permission_overwrites: permissionOverwrites?.map(({ allow, deny, ...permissionOverwriteOptions }) => ({
              ...permissionOverwriteOptions,
              allow: allow === undefined ? undefined : PermissionsBitField.resolve(allow).toString(),
              deny: deny === undefined ? undefined : PermissionsBitField.resolve(deny).toString()
            })),
            rate_limit_per_user: rateLimitPerUser
          })),
          afk_channel_id: afkChannelId,
          afk_timeout: afkTimeout,
          system_channel_id: systemChannelId,
          system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags)
        }
      });
      return this.client.guilds.cache.get(data.id) ?? new Promise((resolve) => {
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            clearTimeout2(timeout);
            this.client.decrementMaxListeners();
            resolve(guild);
          }
        };
        this.client.incrementMaxListeners();
        this.client.once(Events.GuildCreate, handleGuild);
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.GuildCreate, handleGuild);
          this.client.decrementMaxListeners();
          resolve(this.client.guilds._add(data));
        }, 1e4).unref();
      });
    }
    async fetch(options = {}) {
      const id = this.resolveId(options) ?? this.resolveId(options.guild);
      if (id) {
        if (!options.force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data2 = await this.client.rest.get(Routes.guild(id), {
          query: makeURLSearchParams({ with_counts: options.withCounts ?? true })
        });
        data2.shardId = ShardClientUtil.shardIdForGuildId(id, this.client.options.shardCount);
        return this._add(data2, options.cache);
      }
      const data = await this.client.rest.get(Routes.userGuilds(), { query: makeURLSearchParams(options) });
      return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection);
    }
    async fetchSoundboardSounds({ guildIds, time = 1e4 }) {
      const shardCount = this.client.options.shardCount;
      const shardIds = new Map;
      for (const guildId of guildIds) {
        const shardId = ShardClientUtil.shardIdForGuildId(guildId, shardCount);
        const group = shardIds.get(shardId);
        if (group)
          group.push(guildId);
        else
          shardIds.set(shardId, [guildId]);
      }
      for (const [shardId, shardGuildIds] of shardIds) {
        this.client.ws.shards.get(shardId).send({
          op: GatewayOpcodes.RequestSoundboardSounds,
          d: {
            guild_ids: shardGuildIds
          }
        });
      }
      return new Promise((resolve, reject) => {
        const remainingGuildIds = new Set(guildIds);
        const fetchedSoundboardSounds = new Collection;
        const handler = (soundboardSounds, guild) => {
          timeout.refresh();
          if (!remainingGuildIds.has(guild.id))
            return;
          fetchedSoundboardSounds.set(guild.id, soundboardSounds);
          remainingGuildIds.delete(guild.id);
          if (remainingGuildIds.size === 0) {
            clearTimeout2(timeout);
            this.client.removeListener(Events.SoundboardSounds, handler);
            this.client.decrementMaxListeners();
            resolve(fetchedSoundboardSounds);
          }
        };
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.SoundboardSounds, handler);
          this.client.decrementMaxListeners();
          reject(new DiscordjsError(ErrorCodes.GuildSoundboardSoundsTimeout));
        }, time).unref();
        this.client.incrementMaxListeners();
        this.client.on(Events.SoundboardSounds, handler);
      });
    }
    async setIncidentActions(guild, { invitesDisabledUntil, dmsDisabledUntil }) {
      const guildId = this.resolveId(guild);
      const data = await this.client.rest.put(Routes.guildIncidentActions(guildId), {
        body: {
          invites_disabled_until: invitesDisabledUntil && new Date(invitesDisabledUntil).toISOString(),
          dms_disabled_until: dmsDisabledUntil && new Date(dmsDisabledUntil).toISOString()
        }
      });
      const parsedData = _transformAPIIncidentsData(data);
      const resolvedGuild = this.resolve(guild);
      if (resolvedGuild) {
        resolvedGuild.incidentsData = parsedData;
      }
      return parsedData;
    }
    widgetImageURL(guild, style) {
      const urlSearchParams = String(makeURLSearchParams({ style }));
      return `${RouteBases.api}${Routes.guildWidgetImage(this.resolveId(guild))}${urlSearchParams ? `?${urlSearchParams}` : ""}`;
    }
  }
  module.exports = GuildManager;
});

// node_modules/discord.js/src/managers/UserManager.js
var require_UserManager = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var { GuildMember } = require_GuildMember();
  var { Message } = require_Message();
  var ThreadMember = require_ThreadMember();
  var User = require_User();
  var { emitDeprecationWarningForUserFetchFlags } = require_Util();

  class UserManager extends CachedManager {
    constructor(client, iterable) {
      super(client, User, iterable);
    }
    dmChannel(userId) {
      return this.client.channels.cache.find((channel) => channel.type === ChannelType.DM && channel.recipientId === userId) ?? null;
    }
    async createDM(user, { cache = true, force = false } = {}) {
      const id = this.resolveId(user);
      if (!force) {
        const dmChannel = this.dmChannel(id);
        if (dmChannel && !dmChannel.partial)
          return dmChannel;
      }
      const data = await this.client.rest.post(Routes.userChannels(), { body: { recipient_id: id } });
      return this.client.channels._add(data, null, { cache });
    }
    async deleteDM(user) {
      const id = this.resolveId(user);
      const dmChannel = this.dmChannel(id);
      if (!dmChannel)
        throw new DiscordjsError(ErrorCodes.UserNoDMChannel);
      await this.client.rest.delete(Routes.channel(dmChannel.id));
      this.client.channels._remove(dmChannel.id);
      return dmChannel;
    }
    async fetch(user, { cache = true, force = false } = {}) {
      const id = this.resolveId(user);
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.user(id));
      return this._add(data, cache);
    }
    async fetchFlags(user, options) {
      emitDeprecationWarningForUserFetchFlags(this.constructor.name);
      return (await this.fetch(user, options)).flags;
    }
    async send(user, options) {
      return (await this.createDM(user)).send(options);
    }
    resolve(user) {
      if (user instanceof GuildMember || user instanceof ThreadMember)
        return user.user;
      if (user instanceof Message)
        return user.author;
      return super.resolve(user);
    }
    resolveId(user) {
      if (user instanceof ThreadMember)
        return user.id;
      if (user instanceof GuildMember)
        return user.user.id;
      if (user instanceof Message)
        return user.author.id;
      return super.resolveId(user);
    }
  }
  module.exports = UserManager;
});

// node_modules/discord.js/src/structures/ClientPresence.js
var require_ClientPresence = __commonJS((exports, module) => {
  var { GatewayOpcodes, ActivityType } = require_v106();
  var { Presence } = require_Presence();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class ClientPresence extends Presence {
    constructor(client, data = {}) {
      super(client, Object.assign(data, { status: data.status ?? "online", user: { id: null } }));
    }
    set(presence) {
      const packet = this._parse(presence);
      this._patch(packet);
      if (presence.shardId === undefined) {
        this.client.ws.broadcast({ op: GatewayOpcodes.PresenceUpdate, d: packet });
      } else if (Array.isArray(presence.shardId)) {
        for (const shardId of presence.shardId) {
          this.client.ws.shards.get(shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        }
      } else {
        this.client.ws.shards.get(presence.shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
      }
      return this;
    }
    _parse({ status, since, afk, activities }) {
      const data = {
        activities: [],
        afk: typeof afk === "boolean" ? afk : false,
        since: typeof since === "number" && !Number.isNaN(since) ? since : null,
        status: status ?? this.status
      };
      if (activities?.length) {
        for (const [i, activity] of activities.entries()) {
          if (typeof activity.name !== "string") {
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, `activities[${i}].name`, "string");
          }
          activity.type ??= ActivityType.Playing;
          if (activity.type === ActivityType.Custom && !activity.state) {
            activity.state = activity.name;
            activity.name = "Custom Status";
          }
          data.activities.push({
            type: activity.type,
            name: activity.name,
            state: activity.state,
            url: activity.url
          });
        }
      } else if (!activities && (status || afk || since) && this.activities.length) {
        data.activities.push(...this.activities.map((activity) => ({
          name: activity.name,
          state: activity.state ?? undefined,
          type: activity.type,
          url: activity.url ?? undefined
        })));
      }
      return data;
    }
  }
  module.exports = ClientPresence;
});

// node_modules/discord.js/src/structures/StickerPack.js
var require_StickerPack = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var { Sticker } = require_Sticker();

  class StickerPack extends Base {
    constructor(client, pack) {
      super(client);
      this.id = pack.id;
      this.stickers = new Collection(pack.stickers.map((sticker) => [sticker.id, new Sticker(client, sticker)]));
      this.name = pack.name;
      this.skuId = pack.sku_id;
      this.coverStickerId = pack.cover_sticker_id ?? null;
      this.description = pack.description;
      this.bannerId = pack.banner_asset_id ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get coverSticker() {
      return this.coverStickerId && this.stickers.get(this.coverStickerId);
    }
    bannerURL(options = {}) {
      return this.bannerId && this.client.rest.cdn.stickerPackBanner(this.bannerId, options);
    }
  }
  module.exports = StickerPack;
});

// node_modules/discord.js/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS((exports, module) => {
  var { flatten } = require_Util();

  class VoiceRegion {
    constructor(data) {
      this.id = data.id;
      this.name = data.name;
      this.deprecated = data.deprecated;
      this.optimal = data.optimal;
      this.custom = data.custom;
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = VoiceRegion;
});

// node_modules/discord.js/src/structures/WidgetMember.js
var require_WidgetMember = __commonJS((exports, module) => {
  var Base = require_Base();

  class WidgetMember extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.username = data.username;
      this.discriminator = data.discriminator;
      this.avatar = data.avatar;
      this.status = data.status;
      this.deaf = data.deaf ?? null;
      this.mute = data.mute ?? null;
      this.selfDeaf = data.self_deaf ?? null;
      this.selfMute = data.self_mute ?? null;
      this.suppress = data.suppress ?? null;
      this.channelId = data.channel_id ?? null;
      this.avatarURL = data.avatar_url;
      this.activity = data.activity ?? null;
    }
  }
  module.exports = WidgetMember;
});

// node_modules/discord.js/src/structures/Widget.js
var require_Widget = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var Base = require_Base();
  var WidgetMember = require_WidgetMember();

  class Widget extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("instant_invite" in data) {
        this.instantInvite = data.instant_invite;
      }
      this.channels = new Collection;
      for (const channel of data.channels) {
        this.channels.set(channel.id, channel);
      }
      this.members = new Collection;
      for (const member of data.members) {
        this.members.set(member.id, new WidgetMember(this.client, member));
      }
      if ("presence_count" in data) {
        this.presenceCount = data.presence_count;
      }
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guildWidgetJSON(this.id));
      this._patch(data);
      return this;
    }
    imageURL(style) {
      return this.client.guilds.widgetImageURL(this.id, style);
    }
  }
  module.exports = Widget;
});

// node_modules/discord.js/src/util/IntentsBitField.js
var require_IntentsBitField = __commonJS((exports, module) => {
  var { GatewayIntentBits } = require_v106();
  var BitField = require_BitField();

  class IntentsBitField extends BitField {
    static Flags = GatewayIntentBits;
  }
  module.exports = IntentsBitField;
});

// node_modules/discord.js/src/util/Sweepers.js
var require_Sweepers = __commonJS((exports, module) => {
  var { setInterval: setInterval2, clearInterval: clearInterval2 } = import.meta.require("timers");
  var { ThreadChannelTypes, SweeperKeys } = require_Constants();
  var Events = require_Events();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class Sweepers {
    constructor(client, options) {
      Object.defineProperty(this, "client", { value: client });
      this.options = options;
      this.intervals = Object.fromEntries(SweeperKeys.map((key) => [key, null]));
      for (const key of SweeperKeys) {
        if (!(key in options))
          continue;
        this._validateProperties(key);
        const clonedOptions = { ...this.options[key] };
        if (!("filter" in clonedOptions)) {
          switch (key) {
            case "invites":
              clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);
              break;
            case "messages":
              clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);
              break;
            case "threads":
              clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);
          }
        }
        this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);
      }
    }
    sweepApplicationCommands(filter) {
      const { guilds, items: guildCommands } = this._sweepGuildDirectProp("commands", filter, { emit: false });
      const globalCommands = this.client.application?.commands.cache.sweep(filter) ?? 0;
      this.client.emit(Events.CacheSweep, `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`);
      return guildCommands + globalCommands;
    }
    sweepAutoModerationRules(filter) {
      return this._sweepGuildDirectProp("autoModerationRules", filter).items;
    }
    sweepBans(filter) {
      return this._sweepGuildDirectProp("bans", filter).items;
    }
    sweepEmojis(filter) {
      return this._sweepGuildDirectProp("emojis", filter).items;
    }
    sweepEntitlements(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      const entitlements = this.client.application.entitlements.cache.sweep(filter);
      this.client.emit(Events.CacheSweep, `Swept ${entitlements} entitlements.`);
      return entitlements;
    }
    sweepInvites(filter) {
      return this._sweepGuildDirectProp("invites", filter).items;
    }
    sweepGuildMembers(filter) {
      return this._sweepGuildDirectProp("members", filter, { outputName: "guild members" }).items;
    }
    sweepMessages(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let channels = 0;
      let messages = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!channel.isTextBased())
          continue;
        channels++;
        messages += channel.messages.cache.sweep(filter);
      }
      this.client.emit(Events.CacheSweep, `Swept ${messages} messages in ${channels} text-based channels.`);
      return messages;
    }
    sweepPresences(filter) {
      return this._sweepGuildDirectProp("presences", filter).items;
    }
    sweepReactions(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let channels = 0;
      let messages = 0;
      let reactions = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!channel.isTextBased())
          continue;
        channels++;
        for (const message of channel.messages.cache.values()) {
          messages++;
          reactions += message.reactions.cache.sweep(filter);
        }
      }
      this.client.emit(Events.CacheSweep, `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`);
      return reactions;
    }
    sweepStageInstances(filter) {
      return this._sweepGuildDirectProp("stageInstances", filter, { outputName: "stage instances" }).items;
    }
    sweepStickers(filter) {
      return this._sweepGuildDirectProp("stickers", filter).items;
    }
    sweepThreadMembers(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let threads = 0;
      let members = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!ThreadChannelTypes.includes(channel.type))
          continue;
        threads++;
        members += channel.members.cache.sweep(filter);
      }
      this.client.emit(Events.CacheSweep, `Swept ${members} thread members in ${threads} threads.`);
      return members;
    }
    sweepThreads(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let threads = 0;
      for (const [key, val] of this.client.channels.cache.entries()) {
        if (!ThreadChannelTypes.includes(val.type))
          continue;
        if (filter(val, key, this.client.channels.cache)) {
          threads++;
          this.client.channels._remove(key);
        }
      }
      this.client.emit(Events.CacheSweep, `Swept ${threads} threads.`);
      return threads;
    }
    sweepUsers(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      const users = this.client.users.cache.sweep(filter);
      this.client.emit(Events.CacheSweep, `Swept ${users} users.`);
      return users;
    }
    sweepVoiceStates(filter) {
      return this._sweepGuildDirectProp("voiceStates", filter, { outputName: "voice states" }).items;
    }
    destroy() {
      for (const key of SweeperKeys) {
        if (this.intervals[key])
          clearInterval2(this.intervals[key]);
      }
    }
    static filterByLifetime({
      lifetime = 14400,
      getComparisonTimestamp = (e) => e?.createdTimestamp,
      excludeFromSweep = () => false
    } = {}) {
      if (typeof lifetime !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "lifetime", "number");
      }
      if (typeof getComparisonTimestamp !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "getComparisonTimestamp", "function");
      }
      if (typeof excludeFromSweep !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "excludeFromSweep", "function");
      }
      return () => {
        if (lifetime <= 0)
          return null;
        const lifetimeMs = lifetime * 1000;
        const now = Date.now();
        return (entry, key, coll) => {
          if (excludeFromSweep(entry, key, coll)) {
            return false;
          }
          const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);
          if (!comparisonTimestamp || typeof comparisonTimestamp !== "number")
            return false;
          return now - comparisonTimestamp > lifetimeMs;
        };
      };
    }
    static archivedThreadSweepFilter(lifetime = 14400) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (e) => e.archiveTimestamp,
        excludeFromSweep: (e) => !e.archived
      });
    }
    static expiredInviteSweepFilter(lifetime = 14400) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (i) => i.expiresTimestamp
      });
    }
    static outdatedMessageSweepFilter(lifetime = 3600) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (m) => m.editedTimestamp ?? m.createdTimestamp
      });
    }
    _sweepGuildDirectProp(key, filter, { emit = true, outputName } = {}) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let guilds = 0;
      let items = 0;
      for (const guild of this.client.guilds.cache.values()) {
        if (!guild.available)
          continue;
        const { cache } = guild[key];
        guilds++;
        items += cache.sweep(filter);
      }
      if (emit) {
        this.client.emit(Events.CacheSweep, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);
      }
      return { guilds, items };
    }
    _validateProperties(key) {
      const props = this.options[key];
      if (typeof props !== "object") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}`, "object", true);
      }
      if (typeof props.interval !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.interval`, "number");
      }
      if (["invites", "messages", "threads"].includes(key) && !("filter" in props)) {
        if (typeof props.lifetime !== "number") {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.lifetime`, "number");
        }
        return;
      }
      if (typeof props.filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.filter`, "function");
      }
    }
    _initInterval(intervalKey, sweepKey, opts) {
      if (opts.interval <= 0 || opts.interval === Infinity)
        return;
      this.intervals[intervalKey] = setInterval2(() => {
        const sweepFn = opts.filter();
        if (sweepFn === null)
          return;
        if (typeof sweepFn !== "function")
          throw new DiscordjsTypeError(ErrorCodes.SweepFilterReturn);
        this[sweepKey](sweepFn);
      }, opts.interval * 1000).unref();
    }
  }
  module.exports = Sweepers;
});

// node_modules/discord.js/src/client/Client.js
var require_Client = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { OAuth2Scopes, Routes } = require_v106();
  var BaseClient = require_BaseClient();
  var ActionsManager = require_ActionsManager();
  var ClientVoiceManager = require_ClientVoiceManager();
  var WebSocketManager = require_WebSocketManager();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors();
  var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  var ChannelManager = require_ChannelManager();
  var GuildManager = require_GuildManager();
  var UserManager = require_UserManager();
  var ShardClientUtil = require_ShardClientUtil();
  var ClientPresence = require_ClientPresence();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Invite = require_Invite();
  var { SoundboardSound } = require_SoundboardSound();
  var { Sticker } = require_Sticker();
  var StickerPack = require_StickerPack();
  var VoiceRegion = require_VoiceRegion();
  var Webhook = require_Webhook();
  var Widget = require_Widget();
  var { resolveInviteCode, resolveGuildTemplateCode } = require_DataResolver();
  var Events = require_Events();
  var IntentsBitField = require_IntentsBitField();
  var Options = require_Options();
  var PermissionsBitField = require_PermissionsBitField();
  var Status = require_Status();
  var Sweepers = require_Sweepers();
  var deprecationEmittedForPremiumStickerPacks = false;

  class Client extends BaseClient {
    constructor(options) {
      super(options);
      const data = import.meta.require("worker_threads").workerData ?? process2.env;
      const defaults = Options.createDefault();
      if (this.options.shards === defaults.shards) {
        if ("SHARDS" in data) {
          this.options.shards = JSON.parse(data.SHARDS);
        }
      }
      if (this.options.shardCount === defaults.shardCount) {
        if ("SHARD_COUNT" in data) {
          this.options.shardCount = Number(data.SHARD_COUNT);
        } else if (Array.isArray(this.options.shards)) {
          this.options.shardCount = this.options.shards.length;
        }
      }
      const typeofShards = typeof this.options.shards;
      if (typeofShards === "undefined" && typeof this.options.shardCount === "number") {
        this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);
      }
      if (typeofShards === "number")
        this.options.shards = [this.options.shards];
      if (Array.isArray(this.options.shards)) {
        this.options.shards = [
          ...new Set(this.options.shards.filter((item) => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)))
        ];
      }
      this._validateOptions();
      this.ws = new WebSocketManager(this);
      this.actions = new ActionsManager(this);
      this.voice = new ClientVoiceManager(this);
      this.shard = process2.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process2.env.SHARDING_MANAGER_MODE) : null;
      this.users = new UserManager(this);
      this.guilds = new GuildManager(this);
      this.channels = new ChannelManager(this);
      this.sweepers = new Sweepers(this, this.options.sweepers);
      this.presence = new ClientPresence(this, this.options.presence);
      Object.defineProperty(this, "token", { writable: true });
      if (!this.token && "DISCORD_TOKEN" in process2.env) {
        this.token = process2.env.DISCORD_TOKEN;
      } else {
        this.token = null;
      }
      this.user = null;
      this.application = null;
      this.readyTimestamp = null;
    }
    get emojis() {
      const emojis = new BaseGuildEmojiManager(this);
      for (const guild of this.guilds.cache.values()) {
        if (guild.available)
          for (const emoji of guild.emojis.cache.values())
            emojis.cache.set(emoji.id, emoji);
      }
      return emojis;
    }
    get readyAt() {
      return this.readyTimestamp && new Date(this.readyTimestamp);
    }
    get uptime() {
      return this.readyTimestamp && Date.now() - this.readyTimestamp;
    }
    async login(token = this.token) {
      if (!token || typeof token !== "string")
        throw new DiscordjsError(ErrorCodes.TokenInvalid);
      this.token = token = token.replace(/^(Bot|Bearer)\s*/i, "");
      this.rest.setToken(token);
      this.emit(Events.Debug, `Provided token: ${this._censoredToken}`);
      if (this.options.presence) {
        this.options.ws.presence = this.presence._parse(this.options.presence);
      }
      this.emit(Events.Debug, "Preparing to connect to the gateway...");
      try {
        await this.ws.connect();
        return this.token;
      } catch (error) {
        await this.destroy();
        throw error;
      }
    }
    isReady() {
      return !this.ws.destroyed && this.ws.status === Status.Ready;
    }
    async destroy() {
      super.destroy();
      this.sweepers.destroy();
      await this.ws.destroy();
      this.token = null;
      this.rest.setToken(null);
    }
    async fetchInvite(invite, options) {
      const code = resolveInviteCode(invite);
      const query = makeURLSearchParams({
        with_counts: true,
        with_expiration: true,
        guild_scheduled_event_id: options?.guildScheduledEventId
      });
      const data = await this.rest.get(Routes.invite(code), { query });
      return new Invite(this, data);
    }
    async fetchGuildTemplate(template) {
      const code = resolveGuildTemplateCode(template);
      const data = await this.rest.get(Routes.template(code));
      return new GuildTemplate(this, data);
    }
    async fetchWebhook(id, token) {
      const data = await this.rest.get(Routes.webhook(id, token), { auth: token === undefined });
      return new Webhook(this, { token, ...data });
    }
    async fetchVoiceRegions() {
      const apiRegions = await this.rest.get(Routes.voiceRegions());
      const regions = new Collection;
      for (const region of apiRegions)
        regions.set(region.id, new VoiceRegion(region));
      return regions;
    }
    async fetchSticker(id) {
      const data = await this.rest.get(Routes.sticker(id));
      return new Sticker(this, data);
    }
    async fetchStickerPacks({ packId } = {}) {
      if (packId) {
        const data2 = await this.rest.get(Routes.stickerPack(packId));
        return new StickerPack(this, data2);
      }
      const data = await this.rest.get(Routes.stickerPacks());
      return new Collection(data.sticker_packs.map((stickerPack) => [stickerPack.id, new StickerPack(this, stickerPack)]));
    }
    fetchPremiumStickerPacks() {
      if (!deprecationEmittedForPremiumStickerPacks) {
        process2.emitWarning("The Client#fetchPremiumStickerPacks() method is deprecated. Use Client#fetchStickerPacks() instead.", "DeprecationWarning");
        deprecationEmittedForPremiumStickerPacks = true;
      }
      return this.fetchStickerPacks();
    }
    async fetchDefaultSoundboardSounds() {
      const data = await this.rest.get(Routes.soundboardDefaultSounds());
      return new Collection(data.map((sound) => [sound.sound_id, new SoundboardSound(this, sound)]));
    }
    async fetchGuildPreview(guild) {
      const id = this.guilds.resolveId(guild);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
      const data = await this.rest.get(Routes.guildPreview(id));
      return new GuildPreview(this, data);
    }
    async fetchGuildWidget(guild) {
      const id = this.guilds.resolveId(guild);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
      const data = await this.rest.get(Routes.guildWidgetJSON(id));
      return new Widget(this, data);
    }
    generateInvite(options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      if (!this.application)
        throw new DiscordjsError(ErrorCodes.ClientNotReady, "generate an invite link");
      const { scopes } = options;
      if (scopes === undefined) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
      }
      if (!Array.isArray(scopes)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "scopes", "Array of Invite Scopes", true);
      }
      if (!scopes.some((scope) => [OAuth2Scopes.Bot, OAuth2Scopes.ApplicationsCommands].includes(scope))) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
      }
      if (!scopes.includes(OAuth2Scopes.Bot) && options.permissions) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidScopesWithPermissions);
      }
      const validScopes = Object.values(OAuth2Scopes);
      const invalidScope = scopes.find((scope) => !validScopes.includes(scope));
      if (invalidScope) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "scopes", invalidScope);
      }
      const query = makeURLSearchParams({
        client_id: this.application.id,
        scope: scopes.join(" "),
        disable_guild_select: options.disableGuildSelect
      });
      if (options.permissions) {
        const permissions = PermissionsBitField.resolve(options.permissions);
        if (permissions)
          query.set("permissions", permissions.toString());
      }
      if (options.guild) {
        const guildId = this.guilds.resolveId(options.guild);
        if (!guildId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.guild", "GuildResolvable");
        query.set("guild_id", guildId);
      }
      return `${this.options.rest.api}${Routes.oauth2Authorization()}?${query}`;
    }
    toJSON() {
      return super.toJSON({
        actions: false,
        presence: false
      });
    }
    get _censoredToken() {
      if (!this.token)
        return null;
      return this.token.split(".").map((val, i) => i > 1 ? val.replace(/./g, "*") : val).join(".");
    }
    _eval(script) {
      return eval(script);
    }
    _validateOptions(options = this.options) {
      if (options.intents === undefined) {
        throw new DiscordjsTypeError(ErrorCodes.ClientMissingIntents);
      } else {
        options.intents = new IntentsBitField(options.intents).freeze();
      }
      if (typeof options.shardCount !== "number" || isNaN(options.shardCount) || options.shardCount < 1) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardCount", "a number greater than or equal to 1");
      }
      if (options.shards && !(options.shards === "auto" || Array.isArray(options.shards))) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shards", "'auto', a number or array of numbers");
      }
      if (options.shards && !options.shards.length)
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidProvidedShards);
      if (typeof options.makeCache !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "makeCache", "a function");
      }
      if (typeof options.sweepers !== "object" || options.sweepers === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "sweepers", "an object");
      }
      if (!Array.isArray(options.partials)) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "partials", "an Array");
      }
      if (typeof options.waitGuildTimeout !== "number" || isNaN(options.waitGuildTimeout)) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "waitGuildTimeout", "a number");
      }
      if (typeof options.failIfNotExists !== "boolean") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "failIfNotExists", "a boolean");
      }
      if (typeof options.enforceNonce !== "boolean") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "enforceNonce", "a boolean");
      }
      if (typeof options.allowedMentions !== "object" && options.allowedMentions !== undefined || options.allowedMentions === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "allowedMentions", "an object");
      }
      if (typeof options.presence !== "object" || options.presence === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "presence", "an object");
      }
      if (typeof options.ws !== "object" || options.ws === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "ws", "an object");
      }
      if (typeof options.rest !== "object" || options.rest === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "rest", "an object");
      }
      if (typeof options.jsonTransformer !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "jsonTransformer", "a function");
      }
    }
  }
  module.exports = Client;
});

// node_modules/discord.js/src/util/ShardEvents.js
var require_ShardEvents = __commonJS((exports, module) => {
  module.exports = {
    Death: "death",
    Disconnect: "disconnect",
    Error: "error",
    Message: "message",
    Ready: "ready",
    Reconnecting: "reconnecting",
    Resume: "resume",
    Spawn: "spawn"
  };
});

// node_modules/discord.js/src/sharding/Shard.js
var require_Shard = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var path = import.meta.require("path");
  var process2 = import.meta.require("process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = import.meta.require("timers");
  var { setTimeout: sleep } = import.meta.require("timers/promises");
  var { SHARE_ENV } = import.meta.require("worker_threads");
  var { DiscordjsError, ErrorCodes } = require_errors();
  var ShardEvents = require_ShardEvents();
  var { makeError, makePlainError } = require_Util();
  var childProcess = null;
  var Worker = null;

  class Shard extends EventEmitter {
    constructor(manager, id) {
      super();
      switch (manager.mode) {
        case "process":
          childProcess = import.meta.require("child_process");
          break;
        case "worker":
          Worker = import.meta.require("worker_threads").Worker;
          break;
      }
      this.manager = manager;
      this.id = id;
      this.silent = manager.silent;
      this.args = manager.shardArgs ?? [];
      this.execArgv = manager.execArgv;
      this.env = Object.assign({}, process2.env, {
        SHARDING_MANAGER: true,
        SHARDS: this.id,
        SHARD_COUNT: this.manager.totalShards,
        DISCORD_TOKEN: this.manager.token
      });
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals = new Map;
      this._fetches = new Map;
      this._exitListener = null;
    }
    async spawn(timeout = 30000) {
      if (this.process)
        throw new DiscordjsError(ErrorCodes.ShardingProcessExists, this.id);
      if (this.worker)
        throw new DiscordjsError(ErrorCodes.ShardingWorkerExists, this.id);
      this._exitListener = this._handleExit.bind(this, undefined, timeout);
      switch (this.manager.mode) {
        case "process":
          this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
            env: this.env,
            execArgv: this.execArgv,
            silent: this.silent
          }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
          break;
        case "worker":
          this.worker = new Worker(path.resolve(this.manager.file), {
            workerData: this.env,
            env: SHARE_ENV,
            execArgv: this.execArgv,
            argv: this.args
          }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
          break;
      }
      this._evals.clear();
      this._fetches.clear();
      const child = this.process ?? this.worker;
      this.emit(ShardEvents.Spawn, child);
      if (timeout === -1 || timeout === Infinity)
        return child;
      return new Promise((resolve, reject) => {
        const cleanup = () => {
          clearTimeout2(spawnTimeoutTimer);
          this.off("ready", onReady);
          this.off("disconnect", onDisconnect);
          this.off("death", onDeath);
        };
        const onReady = () => {
          cleanup();
          resolve(child);
        };
        const onDisconnect = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyDisconnected, this.id));
        };
        const onDeath = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyDied, this.id));
        };
        const onTimeout = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyTimeout, this.id));
        };
        const spawnTimeoutTimer = setTimeout2(onTimeout, timeout);
        this.once("ready", onReady);
        this.once("disconnect", onDisconnect);
        this.once("death", onDeath);
      });
    }
    kill() {
      if (this.process) {
        this.process.removeListener("exit", this._exitListener);
        this.process.kill();
      } else {
        this.worker.removeListener("exit", this._exitListener);
        this.worker.terminate();
      }
      this._handleExit(false);
    }
    async respawn({ delay = 500, timeout = 30000 } = {}) {
      this.kill();
      if (delay > 0)
        await sleep(delay);
      return this.spawn(timeout);
    }
    send(message) {
      return new Promise((resolve, reject) => {
        if (this.process) {
          this.process.send(message, (err) => {
            if (err)
              reject(err);
            else
              resolve(this);
          });
        } else {
          this.worker.postMessage(message);
          resolve(this);
        }
      });
    }
    async fetchClientValue(prop) {
      if (!this.process && !this.worker) {
        throw new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id);
      }
      if (this._fetches.has(prop))
        return this._fetches.get(prop);
      const promise = new Promise((resolve, reject) => {
        const child = this.process ?? this.worker;
        const listener = (message) => {
          if (message?._fetchProp !== prop)
            return;
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._fetches.delete(prop);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(child);
        child.on("message", listener);
        this.send({ _fetchProp: prop }).catch((err) => {
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._fetches.delete(prop);
          reject(err);
        });
      });
      this._fetches.set(prop, promise);
      return promise;
    }
    async eval(script2, context) {
      const _eval = typeof script2 === "function" ? `(${script2})(this, ${JSON.stringify(context)})` : script2;
      if (!this.process && !this.worker) {
        throw new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id);
      }
      if (this._evals.has(_eval))
        return this._evals.get(_eval);
      const promise = new Promise((resolve, reject) => {
        const child = this.process ?? this.worker;
        const listener = (message) => {
          if (message?._eval !== _eval)
            return;
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._evals.delete(_eval);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(child);
        child.on("message", listener);
        this.send({ _eval }).catch((err) => {
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._evals.delete(_eval);
          reject(err);
        });
      });
      this._evals.set(_eval, promise);
      return promise;
    }
    _handleMessage(message) {
      if (message) {
        if (message._ready) {
          this.ready = true;
          this.emit(ShardEvents.Ready);
          return;
        }
        if (message._disconnect) {
          this.ready = false;
          this.emit(ShardEvents.Disconnect);
          return;
        }
        if (message._reconnecting) {
          this.ready = false;
          this.emit(ShardEvents.Reconnecting);
          return;
        }
        if (message._resume) {
          this.ready = true;
          this.emit(ShardEvents.Resume);
          return;
        }
        if (message._sFetchProp) {
          const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };
          this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then((results) => this.send({ ...resp, _result: results }), (err) => this.send({ ...resp, _error: makePlainError(err) }));
          return;
        }
        if (message._sEval) {
          const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };
          this.manager._performOnShards("eval", [message._sEval], message._sEvalShard).then((results) => this.send({ ...resp, _result: results }), (err) => this.send({ ...resp, _error: makePlainError(err) }));
          return;
        }
        if (message._sRespawnAll) {
          const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;
          this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {
          });
          return;
        }
      }
      this.emit(ShardEvents.Message, message);
    }
    _handleExit(respawn = this.manager.respawn, timeout) {
      this.emit(ShardEvents.Death, this.process ?? this.worker);
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals.clear();
      this._fetches.clear();
      if (respawn)
        this.spawn(timeout).catch((err) => this.emit(ShardEvents.Error, err));
    }
    incrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners - 1);
      }
    }
  }
  module.exports = Shard;
});

// node_modules/discord.js/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var process2 = import.meta.require("process");
  var { setTimeout: sleep } = import.meta.require("timers/promises");
  var { Collection } = require_dist6();
  var Shard = require_Shard();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors();
  var { fetchRecommendedShardCount } = require_Util();

  class ShardingManager extends EventEmitter {
    constructor(file, options) {
      super();
      const _options = {
        totalShards: "auto",
        mode: "process",
        respawn: true,
        silent: false,
        shardArgs: [],
        execArgv: [],
        token: process2.env.DISCORD_TOKEN,
        ...options
      };
      this.file = file;
      if (!file)
        throw new DiscordjsError(ErrorCodes.ClientInvalidOption, "File", "specified.");
      if (!path.isAbsolute(file))
        this.file = path.resolve(process2.cwd(), file);
      const stats = fs.statSync(this.file);
      if (!stats.isFile())
        throw new DiscordjsError(ErrorCodes.ClientInvalidOption, "File", "a file");
      this.shardList = _options.shardList ?? "auto";
      if (this.shardList !== "auto") {
        if (!Array.isArray(this.shardList)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardList", "an array.");
        }
        this.shardList = [...new Set(this.shardList)];
        if (this.shardList.length < 1) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "shardList", "at least 1 id.");
        }
        if (this.shardList.some((shardId) => typeof shardId !== "number" || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardList", "an array of positive integers.");
        }
      }
      this.totalShards = _options.totalShards || "auto";
      if (this.totalShards !== "auto") {
        if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "a number.");
        }
        if (this.totalShards < 1) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "at least 1.");
        }
        if (!Number.isInteger(this.totalShards)) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "an integer.");
        }
      }
      this.mode = _options.mode;
      if (this.mode !== "process" && this.mode !== "worker") {
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Sharding mode", '"process" or "worker"');
      }
      this.respawn = _options.respawn;
      this.silent = _options.silent;
      this.shardArgs = _options.shardArgs;
      this.execArgv = _options.execArgv;
      this.token = _options.token?.replace(/^Bot\s*/i, "") ?? null;
      this.shards = new Collection;
      process2.env.SHARDING_MANAGER = true;
      process2.env.SHARDING_MANAGER_MODE = this.mode;
      process2.env.DISCORD_TOKEN = this.token;
    }
    createShard(id = this.shards.size) {
      const shard = new Shard(this, id);
      this.shards.set(id, shard);
      this.emit("shardCreate", shard);
      return shard;
    }
    async spawn({ amount = this.totalShards, delay = 5500, timeout = 30000 } = {}) {
      if (amount === "auto") {
        amount = await fetchRecommendedShardCount(this.token);
      } else {
        if (typeof amount !== "number" || isNaN(amount)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "a number.");
        }
        if (amount < 1)
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "at least 1.");
        if (!Number.isInteger(amount)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "an integer.");
        }
      }
      if (this.shards.size >= amount)
        throw new DiscordjsError(ErrorCodes.ShardingAlreadySpawned, this.shards.size);
      if (this.shardList === "auto" || this.totalShards === "auto" || this.totalShards !== amount) {
        this.shardList = [...Array(amount).keys()];
      }
      if (this.totalShards === "auto" || this.totalShards !== amount) {
        this.totalShards = amount;
      }
      if (this.shardList.some((shardId) => shardId >= amount)) {
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "bigger than the highest shardId in the shardList option.");
      }
      for (const shardId of this.shardList) {
        const promises = [];
        const shard = this.createShard(shardId);
        promises.push(shard.spawn(timeout));
        if (delay > 0 && this.shards.size !== this.shardList.length)
          promises.push(sleep(delay));
        await Promise.all(promises);
      }
      return this.shards;
    }
    broadcast(message) {
      const promises = [];
      for (const shard of this.shards.values())
        promises.push(shard.send(message));
      return Promise.all(promises);
    }
    async broadcastEval(script2, options = {}) {
      if (typeof script2 !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast);
      }
      return this._performOnShards("eval", [`(${script2})(this, ${JSON.stringify(options.context)})`], options.shard);
    }
    fetchClientValues(prop, shard) {
      return this._performOnShards("fetchClientValue", [prop], shard);
    }
    async _performOnShards(method, args, shard) {
      if (this.shards.size === 0)
        throw new DiscordjsError(ErrorCodes.ShardingNoShards);
      if (typeof shard === "number") {
        if (this.shards.has(shard))
          return this.shards.get(shard)[method](...args);
        throw new DiscordjsError(ErrorCodes.ShardingShardNotFound, shard);
      }
      if (this.shards.size !== this.shardList.length) {
        throw new DiscordjsError(ErrorCodes.ShardingInProcess);
      }
      const promises = [];
      for (const sh of this.shards.values())
        promises.push(sh[method](...args));
      return Promise.all(promises);
    }
    async respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {
      let s = 0;
      for (const shard of this.shards.values()) {
        const promises = [shard.respawn({ delay: respawnDelay, timeout })];
        if (++s < this.shards.size && shardDelay > 0)
          promises.push(sleep(shardDelay));
        await Promise.all(promises);
      }
      return this.shards;
    }
  }
  module.exports = ShardingManager;
});

// node_modules/discord.js/src/util/Formatters.js
var require_Formatters = __commonJS((exports, module) => {
  var { deprecate } = import.meta.require("util");
  var {
    blockQuote,
    bold,
    channelMention,
    codeBlock,
    formatEmoji,
    hideLinkEmbed,
    hyperlink,
    inlineCode,
    italic,
    quote,
    roleMention,
    spoiler,
    strikethrough,
    time,
    TimestampStyles,
    underscore,
    userMention
  } = require_dist7();

  class Formatters extends null {
    static blockQuote = deprecate(blockQuote, "Formatters.blockQuote() is deprecated. Import this method directly from discord.js instead.");
    static bold = deprecate(bold, "Formatters.bold() is deprecated. Import this method directly from discord.js instead.");
    static channelMention = deprecate(channelMention, "Formatters.channelMention() is deprecated. Import this method directly from discord.js instead.");
    static codeBlock = deprecate(codeBlock, "Formatters.codeBlock() is deprecated. Import this method directly from discord.js instead.");
    static formatEmoji = deprecate(formatEmoji, "Formatters.formatEmoji() is deprecated. Import this method directly from discord.js instead.");
    static hideLinkEmbed = deprecate(hideLinkEmbed, "Formatters.hideLinkEmbed() is deprecated. Import this method directly from discord.js instead.");
    static hyperlink = deprecate(hyperlink, "Formatters.hyperlink() is deprecated. Import this method directly from discord.js instead.");
    static inlineCode = deprecate(inlineCode, "Formatters.inlineCode() is deprecated. Import this method directly from discord.js instead.");
    static italic = deprecate(italic, "Formatters.italic() is deprecated. Import this method directly from discord.js instead.");
    static quote = deprecate(quote, "Formatters.quote() is deprecated. Import this method directly from discord.js instead.");
    static roleMention = deprecate(roleMention, "Formatters.roleMention() is deprecated. Import this method directly from discord.js instead.");
    static spoiler = deprecate(spoiler, "Formatters.spoiler() is deprecated. Import this method directly from discord.js instead.");
    static strikethrough = deprecate(strikethrough, "Formatters.strikethrough() is deprecated. Import this method directly from discord.js instead.");
    static time = deprecate(time, "Formatters.time() is deprecated. Import this method directly from discord.js instead.");
    static TimestampStyles = TimestampStyles;
    static underscore = deprecate(underscore, "Formatters.underscore() is deprecated. Import this method directly from discord.js instead.");
    static userMention = deprecate(userMention, "Formatters.userMention() is deprecated. Import this method directly from discord.js instead.");
  }
  module.exports = Formatters;
});

// node_modules/discord.js/src/structures/EmbedBuilder.js
var require_EmbedBuilder = __commonJS((exports, module) => {
  var { EmbedBuilder: BuildersEmbed, embedLength } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolveColor } = require_Util();

  class EmbedBuilder extends BuildersEmbed {
    constructor(data) {
      super(toSnakeCase(data));
    }
    setColor(color) {
      return super.setColor(color && resolveColor(color));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
    get length() {
      return embedLength(this.data);
    }
  }
  module.exports = EmbedBuilder;
});

// node_modules/discord.js/src/structures/AttachmentBuilder.js
var require_AttachmentBuilder = __commonJS((exports, module) => {
  var { basename, flatten } = require_Util();

  class AttachmentBuilder {
    constructor(attachment, data = {}) {
      this.attachment = attachment;
      this.name = data.name;
      this.description = data.description;
    }
    setDescription(description) {
      this.description = description;
      return this;
    }
    setFile(attachment) {
      this.attachment = attachment;
      return this;
    }
    setName(name) {
      this.name = name;
      return this;
    }
    setSpoiler(spoiler = true) {
      if (spoiler === this.spoiler)
        return this;
      if (!spoiler) {
        while (this.spoiler) {
          this.name = this.name.slice("SPOILER_".length);
        }
        return this;
      }
      this.name = `SPOILER_${this.name}`;
      return this;
    }
    get spoiler() {
      return basename(this.name).startsWith("SPOILER_");
    }
    toJSON() {
      return flatten(this);
    }
    static from(other) {
      return new AttachmentBuilder(other.attachment, {
        name: other.name,
        description: other.description
      });
    }
  }
  module.exports = AttachmentBuilder;
});

// node_modules/discord.js/src/structures/ModalBuilder.js
var require_ModalBuilder = __commonJS((exports, module) => {
  var { ModalBuilder: BuildersModal, ComponentBuilder } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class ModalBuilder extends BuildersModal {
    constructor({ components, ...data } = {}) {
      super({
        ...toSnakeCase(data),
        components: components?.map((component) => component instanceof ComponentBuilder ? component : toSnakeCase(component))
      });
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ModalBuilder;
});

// node_modules/discord.js/src/structures/SelectMenuBuilder.js
var require_SelectMenuBuilder = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  var deprecationEmitted = false;

  class SelectMenuBuilder2 extends StringSelectMenuBuilder {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuBuilder class is deprecated. Use StringSelectMenuBuilder instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuBuilder2;
});

// node_modules/discord.js/src/structures/SelectMenuComponent.js
var require_SelectMenuComponent = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var StringSelectMenuComponent = require_StringSelectMenuComponent();
  var deprecationEmitted = false;

  class SelectMenuComponent extends StringSelectMenuComponent {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuComponent class is deprecated. Use StringSelectMenuComponent instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuComponent;
});

// node_modules/discord.js/src/structures/SelectMenuInteraction.js
var require_SelectMenuInteraction = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  var deprecationEmitted = false;

  class SelectMenuInteraction extends StringSelectMenuInteraction {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuInteraction class is deprecated. Use StringSelectMenuInteraction instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuInteraction;
});

// node_modules/discord.js/src/structures/StringSelectMenuOptionBuilder.js
var require_StringSelectMenuOptionBuilder = __commonJS((exports, module) => {
  var { SelectMenuOptionBuilder: BuildersSelectMenuOption } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class StringSelectMenuOptionBuilder extends BuildersSelectMenuOption {
    constructor({ emoji, ...data } = {}) {
      super(toSnakeCase({
        ...data,
        emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
      }));
    }
    setEmoji(emoji) {
      if (typeof emoji === "string") {
        return super.setEmoji(resolvePartialEmoji(emoji));
      }
      return super.setEmoji(emoji);
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = StringSelectMenuOptionBuilder;
});

// node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js
var require_SelectMenuOptionBuilder = __commonJS((exports, module) => {
  var process2 = import.meta.require("process");
  var StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
  var deprecationEmitted = false;

  class SelectMenuOptionBuilder2 extends StringSelectMenuOptionBuilder {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuOptionBuilder class is deprecated. Use StringSelectMenuOptionBuilder instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuOptionBuilder2;
});

// node_modules/discord.js/src/index.js
var require_src = __commonJS((exports) => {
  var { polyfillDispose } = require_dist();
  var { __exportStar } = require_tslib();
  polyfillDispose();
  exports.BaseClient = require_BaseClient();
  exports.Client = require_Client();
  exports.Shard = require_Shard();
  exports.ShardClientUtil = require_ShardClientUtil();
  exports.ShardingManager = require_ShardingManager();
  exports.WebhookClient = require_WebhookClient();
  exports.DiscordjsError = require_DJSError().DiscordjsError;
  exports.DiscordjsTypeError = require_DJSError().DiscordjsTypeError;
  exports.DiscordjsRangeError = require_DJSError().DiscordjsRangeError;
  exports.DiscordjsErrorCodes = require_ErrorCodes();
  exports.ActivityFlagsBitField = require_ActivityFlagsBitField();
  exports.ApplicationFlagsBitField = require_ApplicationFlagsBitField();
  exports.AttachmentFlagsBitField = require_AttachmentFlagsBitField();
  exports.BaseManager = require_BaseManager();
  exports.BitField = require_BitField();
  exports.ChannelFlagsBitField = require_ChannelFlagsBitField();
  exports.Collection = require_dist6().Collection;
  exports.Constants = require_Constants();
  exports.Colors = require_Colors();
  exports.Events = require_Events();
  exports.Formatters = require_Formatters();
  exports.GuildMemberFlagsBitField = require_GuildMemberFlagsBitField().GuildMemberFlagsBitField;
  exports.IntentsBitField = require_IntentsBitField();
  exports.LimitedCollection = require_LimitedCollection();
  exports.MessageFlagsBitField = require_MessageFlagsBitField();
  exports.Options = require_Options();
  exports.Partials = require_Partials();
  exports.PermissionsBitField = require_PermissionsBitField();
  exports.RoleFlagsBitField = require_RoleFlagsBitField();
  exports.ShardEvents = require_ShardEvents();
  exports.SKUFlagsBitField = require_SKUFlagsBitField().SKUFlagsBitField;
  exports.Status = require_Status();
  exports.SnowflakeUtil = require_cjs().DiscordSnowflake;
  exports.Sweepers = require_Sweepers();
  exports.SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  exports.ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
  exports.UserFlagsBitField = require_UserFlagsBitField();
  __exportStar(require_Util(), exports);
  exports.WebSocketShardEvents = require_WebSocketShardEvents();
  exports.version = require_package().version;
  exports.ApplicationCommandManager = require_ApplicationCommandManager();
  exports.ApplicationEmojiManager = require_ApplicationEmojiManager();
  exports.ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  exports.AutoModerationRuleManager = require_AutoModerationRuleManager();
  exports.BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  exports.CachedManager = require_CachedManager();
  exports.ChannelManager = require_ChannelManager();
  exports.ClientVoiceManager = require_ClientVoiceManager();
  exports.DataManager = require_DataManager();
  exports.DMMessageManager = require_DMMessageManager();
  exports.EntitlementManager = require_EntitlementManager().EntitlementManager;
  exports.GuildApplicationCommandManager = require_GuildApplicationCommandManager();
  exports.GuildBanManager = require_GuildBanManager();
  exports.GuildChannelManager = require_GuildChannelManager();
  exports.GuildEmojiManager = require_GuildEmojiManager();
  exports.GuildEmojiRoleManager = require_GuildEmojiRoleManager();
  exports.GuildForumThreadManager = require_GuildForumThreadManager();
  exports.GuildInviteManager = require_GuildInviteManager();
  exports.GuildManager = require_GuildManager();
  exports.GuildMemberManager = require_GuildMemberManager();
  exports.GuildMemberRoleManager = require_GuildMemberRoleManager();
  exports.GuildMessageManager = require_GuildMessageManager();
  exports.GuildScheduledEventManager = require_GuildScheduledEventManager();
  exports.GuildSoundboardSoundManager = require_GuildSoundboardSoundManager().GuildSoundboardSoundManager;
  exports.GuildStickerManager = require_GuildStickerManager();
  exports.GuildTextThreadManager = require_GuildTextThreadManager();
  exports.MessageManager = require_MessageManager();
  exports.PermissionOverwriteManager = require_PermissionOverwriteManager();
  exports.PresenceManager = require_PresenceManager();
  exports.ReactionManager = require_ReactionManager();
  exports.ReactionUserManager = require_ReactionUserManager();
  exports.RoleManager = require_RoleManager();
  exports.StageInstanceManager = require_StageInstanceManager();
  exports.SubscriptionManager = require_SubscriptionManager().SubscriptionManager;
  exports.ThreadManager = require_ThreadManager();
  exports.ThreadMemberManager = require_ThreadMemberManager();
  exports.UserManager = require_UserManager();
  exports.VoiceStateManager = require_VoiceStateManager();
  exports.WebSocketManager = require_WebSocketManager();
  exports.WebSocketShard = require_WebSocketShard();
  exports.ActionRow = require_ActionRow();
  exports.ActionRowBuilder = require_ActionRowBuilder();
  exports.Activity = require_Presence().Activity;
  exports.AnonymousGuild = require_AnonymousGuild();
  exports.Application = require_Application();
  exports.ApplicationCommand = require_ApplicationCommand();
  exports.ApplicationEmoji = require_ApplicationEmoji();
  exports.ApplicationRoleConnectionMetadata = require_ApplicationRoleConnectionMetadata().ApplicationRoleConnectionMetadata;
  exports.AutocompleteInteraction = require_AutocompleteInteraction();
  exports.AutoModerationActionExecution = require_AutoModerationActionExecution();
  exports.AutoModerationRule = require_AutoModerationRule();
  exports.Base = require_Base();
  exports.BaseGuild = require_BaseGuild();
  exports.BaseGuildEmoji = require_BaseGuildEmoji();
  exports.BaseGuildTextChannel = require_BaseGuildTextChannel();
  exports.BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
  exports.ButtonBuilder = require_ButtonBuilder();
  exports.ButtonComponent = require_ButtonComponent();
  exports.ButtonInteraction = require_ButtonInteraction();
  exports.CategoryChannel = require_CategoryChannel();
  exports.BaseChannel = require_BaseChannel().BaseChannel;
  exports.ChatInputCommandInteraction = require_ChatInputCommandInteraction();
  exports.ClientApplication = require_ClientApplication();
  exports.ClientPresence = require_ClientPresence();
  exports.ClientUser = require_ClientUser();
  exports.CommandInteraction = require_CommandInteraction();
  exports.Collector = require_Collector();
  exports.CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  exports.Component = require_Component();
  exports.ContainerComponent = require_ContainerComponent();
  exports.ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
  exports.DMChannel = require_DMChannel();
  exports.Embed = require_Embed();
  exports.EmbedBuilder = require_EmbedBuilder();
  exports.Emoji = require_Emoji().Emoji;
  exports.Entitlement = require_Entitlement().Entitlement;
  exports.FileComponent = require_FileComponent();
  exports.ForumChannel = require_ForumChannel();
  exports.Guild = require_Guild().Guild;
  exports.GuildAuditLogs = require_GuildAuditLogs();
  exports.GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  exports.GuildBan = require_GuildBan();
  exports.GuildChannel = require_GuildChannel();
  exports.GuildEmoji = require_GuildEmoji();
  exports.GuildMember = require_GuildMember().GuildMember;
  exports.GuildOnboarding = require_GuildOnboarding().GuildOnboarding;
  exports.GuildOnboardingPrompt = require_GuildOnboardingPrompt().GuildOnboardingPrompt;
  exports.GuildOnboardingPromptOption = require_GuildOnboardingPromptOption().GuildOnboardingPromptOption;
  exports.GuildPreview = require_GuildPreview();
  exports.GuildPreviewEmoji = require_GuildPreviewEmoji();
  exports.GuildScheduledEvent = require_GuildScheduledEvent().GuildScheduledEvent;
  exports.GuildTemplate = require_GuildTemplate();
  exports.Integration = require_Integration();
  exports.IntegrationApplication = require_IntegrationApplication();
  exports.InteractionCallback = require_InteractionCallback();
  exports.InteractionCallbackResource = require_InteractionCallbackResource();
  exports.InteractionCallbackResponse = require_InteractionCallbackResponse();
  exports.BaseInteraction = require_BaseInteraction();
  exports.InteractionCollector = require_InteractionCollector();
  exports.InteractionResponse = require_InteractionResponse();
  exports.InteractionWebhook = require_InteractionWebhook();
  exports.Invite = require_Invite();
  exports.InviteStageInstance = require_InviteStageInstance();
  exports.InviteGuild = require_InviteGuild();
  exports.Message = require_Message().Message;
  exports.Attachment = require_Attachment();
  exports.AttachmentBuilder = require_AttachmentBuilder();
  exports.ModalBuilder = require_ModalBuilder();
  exports.MediaChannel = require_MediaChannel();
  exports.MediaGalleryComponent = require_MediaGalleryComponent();
  exports.MediaGalleryItem = require_MediaGalleryItem();
  exports.MessageCollector = require_MessageCollector();
  exports.MessageComponentInteraction = require_MessageComponentInteraction();
  exports.MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
  exports.MessageMentions = require_MessageMentions();
  exports.MessagePayload = require_MessagePayload();
  exports.MessageReaction = require_MessageReaction();
  exports.ModalSubmitInteraction = require_ModalSubmitInteraction();
  exports.ModalSubmitFields = require_ModalSubmitFields();
  exports.NewsChannel = require_NewsChannel();
  exports.OAuth2Guild = require_OAuth2Guild();
  exports.PartialGroupDMChannel = require_PartialGroupDMChannel();
  exports.PermissionOverwrites = require_PermissionOverwrites();
  exports.Poll = require_Poll().Poll;
  exports.PollAnswer = require_PollAnswer().PollAnswer;
  exports.Presence = require_Presence().Presence;
  exports.ReactionCollector = require_ReactionCollector();
  exports.ReactionEmoji = require_ReactionEmoji();
  exports.RichPresenceAssets = require_Presence().RichPresenceAssets;
  exports.Role = require_Role().Role;
  exports.SectionComponent = require_SectionComponent();
  exports.SelectMenuBuilder = require_SelectMenuBuilder();
  exports.ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
  exports.MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
  exports.RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
  exports.StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  exports.UserSelectMenuBuilder = require_UserSelectMenuBuilder();
  exports.BaseSelectMenuComponent = require_BaseSelectMenuComponent();
  exports.SelectMenuComponent = require_SelectMenuComponent();
  exports.ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
  exports.MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
  exports.RoleSelectMenuComponent = require_RoleSelectMenuComponent();
  exports.StringSelectMenuComponent = require_StringSelectMenuComponent();
  exports.UserSelectMenuComponent = require_UserSelectMenuComponent();
  exports.SelectMenuInteraction = require_SelectMenuInteraction();
  exports.ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
  exports.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  exports.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  exports.RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
  exports.StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  exports.UserSelectMenuInteraction = require_UserSelectMenuInteraction();
  exports.SelectMenuOptionBuilder = require_SelectMenuOptionBuilder();
  exports.SeparatorComponent = require_SeparatorComponent();
  exports.SKU = require_SKU().SKU;
  exports.SoundboardSound = require_SoundboardSound().SoundboardSound;
  exports.StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
  exports.StageChannel = require_StageChannel();
  exports.StageInstance = require_StageInstance().StageInstance;
  exports.Subscription = require_Subscription().Subscription;
  exports.Sticker = require_Sticker().Sticker;
  exports.StickerPack = require_StickerPack();
  exports.Team = require_Team();
  exports.TeamMember = require_TeamMember();
  exports.TextChannel = require_TextChannel();
  exports.TextDisplayComponent = require_TextDisplayComponent();
  exports.TextInputBuilder = require_TextInputBuilder();
  exports.TextInputComponent = require_TextInputComponent();
  exports.ThreadChannel = require_ThreadChannel();
  exports.ThreadMember = require_ThreadMember();
  exports.ThreadOnlyChannel = require_ThreadOnlyChannel();
  exports.ThumbnailComponent = require_ThumbnailComponent();
  exports.Typing = require_Typing();
  exports.UnfurledMediaItem = require_UnfurledMediaItem();
  exports.User = require_User();
  exports.UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
  exports.VoiceChannelEffect = require_VoiceChannelEffect();
  exports.VoiceChannel = require_VoiceChannel();
  exports.VoiceRegion = require_VoiceRegion();
  exports.VoiceState = require_VoiceState();
  exports.Webhook = require_Webhook();
  exports.Widget = require_Widget();
  exports.WidgetMember = require_WidgetMember();
  exports.WelcomeChannel = require_WelcomeChannel();
  exports.WelcomeScreen = require_WelcomeScreen();
  __exportStar(require_v106(), exports);
  __exportStar(require_dist8(), exports);
  __exportStar(require_dist7(), exports);
  __exportStar(require_dist5(), exports);
  __exportStar(require_dist(), exports);
  __exportStar(require_dist10(), exports);
});

// src/index.ts
var import_discord = __toESM(require_src(), 1);
import path from "path";
import fs from "fs";
var __dirname = "D:\\Projects\\RainyTS\\src";
var client = new import_discord.Client({
  intents: [
    import_discord.GatewayIntentBits.Guilds,
    import_discord.GatewayIntentBits.GuildMembers,
    import_discord.GatewayIntentBits.GuildMessages,
    import_discord.GatewayIntentBits.GuildPresences,
    import_discord.GatewayIntentBits.MessageContent
  ],
  presence: {
    activities: [
      {
        name: "Code Terminal",
        type: import_discord.ActivityType.Streaming
      }
    ],
    status: "idle"
  }
});
client.commands = new import_discord.Collection;
var foldersPath = path.join(__dirname, "commands");
var commandFolders = fs.readdirSync(foldersPath);
for (const folder of commandFolders) {
  const commandsPath = path.join(__dirname, folder);
  const commandFiles = fs.readdirSync(commandsPath).filter((file) => file.endsWith(".ts") || file.endsWith(".js"));
  for (const file of commandFiles) {
    const filePath = path.join(commandsPath, file);
    const command = await import(filePath).then((mod) => mod.default || mod);
    if ("data" in command && "execute" in command) {
      client.commands.set(command.data.name, command);
    } else {
      console.log("\x1B[33m%s\x1B[0m", `[W] ${filePath} is missing data and(or) execute property`);
    }
  }
}
var eventsPath = path.join(__dirname, "modules");
var eventFiles = fs.readdirSync(eventsPath).filter((file) => file.endsWith(".ts") || file.endsWith(".js"));
for (const file of eventFiles) {
  const filePath = path.join(eventsPath, file);
  const event = await import(filePath).then((mod) => mod.default || mod);
  if (event.once) {
    client.once(event.name, (...args) => event.execute(...args, client));
  } else {
    client.on(event.name, (...args) => event.execute(...args, client));
  }
}
client.login("MTMwMjk2Mjg3MzMxNTc1ODA5Ng.Gr5VnZ.8voi0yBKrWIE2XaRr16B6zyI7SYqNUZFt2Cwr8");
client.once("ready", () => {
  console.log("\x1B[32m%s\x1B[0m", `[I] Connected as ${client.user.tag}`);
  client.user?.setActivity({
    name: "Code Terminal",
    type: import_discord.ActivityType.Streaming,
    url: "https://www.twitch.tv/lofigirl"
  });
});
export {
  client
};
